// Copyright 2025 Supabase, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package multipoolermanagerdata;

import "clustermetadata.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";

option go_package = "github.com/multigres/multigres/go/pb/multipoolermanagerdata";

// Primary connection information parsed from PostgreSQL's primary_conninfo setting
message PrimaryConnInfo {
  // Primary server hostname
  string host = 1;

  // Primary server port
  int32 port = 2;

  // Database user for replication connection
  string user = 3;

  // Application name for this standby
  string application_name = 4;

  // Raw connection string (includes all parameters)
  string raw = 5;
}

// PostgreSQL replication status information
message ReplicationStatus {
  // Current replication LSN position (PostgreSQL format: X/XXXXXXXX)
  string lsn = 1;

  // Result of pg_is_wal_replay_paused()
  bool is_wal_replay_paused = 2;

  // Result of pg_get_wal_replay_pause_state()
  string wal_replay_pause_state = 3;

  // Replication lag (optional, may not always be available)
  google.protobuf.Duration lag = 4;

  // Result of pg_last_xact_replay_timestamp()
  string last_xact_replay_timestamp = 5;

  // Primary connection info parsed from primary_conninfo setting
  PrimaryConnInfo primary_conn_info = 6;
}

// Wait for PostgreSQL server to reach a specific LSN position
message WaitForLSNRequest {
  // Target LSN position to wait for (PostgreSQL LSN format: X/XXXXXXXX)
  string target_lsn = 1;

  // Timeout (zero duration means no timeout)
  google.protobuf.Duration timeout = 2;
}

message WaitForLSNResponse {
}

// Start PostgreSQL replication (calls pg_wal_replay_resume)
message StartReplicationRequest {
}

message StartReplicationResponse {
}


// SetPrimaryConnInfo sets the primary connection info for a standby server
message SetPrimaryConnInfoRequest {
  // Primary server hostname
  string host = 1;

  // Primary server port
  int32 port = 2;

  // Whether to stop replication before making changes
  bool stop_replication_before = 3;

  // Whether to start replication after making changes
  bool start_replication_after = 4;

  // Current term for consensus (used by MultiOrch during initialization)
  int64 current_term = 5;

  // Force the operation even if the term doesn't match
  bool force = 6;
}

message SetPrimaryConnInfoResponse {
}

// StopReplication stops WAL replay on standby
message StopReplicationRequest {
}

message StopReplicationResponse {
  // Replication status when replication was stopped
  ReplicationStatus status = 1;
}

// ReplicationStatus gets the current replication status
message ReplicationStatusRequest {
}

message ReplicationStatusResponse {
  // Current replication status
  ReplicationStatus status = 1;
}

// Synchronous replication configuration
message SynchronousReplicationConfiguration {
  // Synchronous commit level
  SynchronousCommitLevel synchronous_commit = 1;

  // Synchronous method (FIRST or ANY)
  SynchronousMethod synchronous_method = 2;

  // Number of synchronous standbys
  int32 num_sync = 3;

  // List of standby IDs that can participate in synchronous replication
  repeated clustermetadata.ID standby_ids = 4;
}

// PostgreSQL primary server status
message PrimaryStatus {
  // Current WAL LSN position (PostgreSQL format: X/XXXXXXXX)
  string lsn = 1;

  // Whether server is accepting connections
  bool ready = 2;

  // Follower servers that are currently connected to the primary (parsed from pg_stat_replication).
  // This only includes followers that have an active replication connection, not all configured standbys.
  // For a complete view of all configured standbys (connected and disconnected), use GetFollowers.
  repeated clustermetadata.ID connected_followers = 3;

  // Synchronous replication configuration (parsed from synchronous_standby_names and synchronous_commit)
  SynchronousReplicationConfiguration sync_replication_config = 4;
}

// PrimaryStatus gets the status of the primary server
message PrimaryStatusRequest {
}

message PrimaryStatusResponse {
  // Primary server status
  PrimaryStatus status = 1;
}

// PrimaryPosition gets the current LSN position of the primary
message PrimaryPositionRequest {
}

message PrimaryPositionResponse {
  // Current primary LSN position
  string lsn_position = 1;
}

// Replication statistics for a connected follower from pg_stat_replication
message ReplicationStats {
  // PostgreSQL backend process ID for this replication connection
  int32 pid = 1;

  // Client IP address of the follower
  string client_addr = 2;

  // Current WAL sender state (startup, catchup, streaming, backup, stopping)
  string state = 3;

  // Synchronous state (async, potential, sync, quorum)
  string sync_state = 4;

  // LSN of the last WAL location sent to this standby
  string sent_lsn = 5;

  // LSN of the last WAL location written to disk on this standby
  string write_lsn = 6;

  // LSN of the last WAL location flushed to disk on this standby
  string flush_lsn = 7;

  // LSN of the last WAL location replayed on this standby
  string replay_lsn = 8;

  // Time taken to write recent WAL locally (may be null)
  google.protobuf.Duration write_lag = 9;

  // Time taken to flush recent WAL locally (may be null)
  google.protobuf.Duration flush_lag = 10;

  // Time taken to replay recent WAL on standby (may be null)
  google.protobuf.Duration replay_lag = 11;
}

// Information about a follower that is part of the current cohort (configured in
// synchronous_standby_names). Includes connection status and replication stats if connected.
message FollowerInfo {
  // Cluster ID of the follower from synchronous_standby_names configuration
  clustermetadata.ID follower_id = 1;

  // Application name (format: {cell}_{name})
  string application_name = 2;

  // Whether this follower is currently connected to the primary
  bool is_connected = 3;

  // Replication statistics (only populated if is_connected is true)
  ReplicationStats replication_stats = 4;
}

// GetFollowers gets the list of follower servers with detailed replication status
message GetFollowersRequest {
}

message GetFollowersResponse {
  // Information about all followers configured in synchronous_standby_names.
  // Each entry indicates whether the follower is connected and includes replication
  // statistics if available. This provides a complete view of the expected cohort.
  repeated FollowerInfo followers = 1;

  // Current synchronous replication configuration for context
  SynchronousReplicationConfiguration sync_config = 2;
}

// Demote demotes the current leader server
// This is called during the Revocation stage of generalized consensus to safely
// transition a primary to read-only mode and prevent it from making further progress.
message DemoteRequest {
  // Consensus term for this demotion operation
  int64 consensus_term = 1;

  // Drain timeout - how long to wait for in-flight queries (default: 5s)
  google.protobuf.Duration drain_timeout = 2;

  // Force the operation even if term validation fails
  bool force = 3;
}

message DemoteResponse {
  // Whether the node was already demoted (idempotent check)
  bool was_already_demoted = 1;

  // Consensus term at the time of demotion
  int64 consensus_term = 2;

  // LSN position at the time of demotion (final position as primary)
  string lsn_position = 3;

  // Number of connections that were terminated
  int32 connections_terminated = 4;
}

// UndoDemote undoes a demotion
message UndoDemoteRequest {
}

message UndoDemoteResponse {
}

// StopReplicationAndGetStatus stops PostgreSQL replication and returns the status
message StopReplicationAndGetStatusRequest {
}

message StopReplicationAndGetStatusResponse {
  // Replication status before and after stopping
  ReplicationStatus status = 1;
}

// ChangeType changes the pooler type
message ChangeTypeRequest {
  // New pooler type (PRIMARY or REPLICA - maps to LEADER/FOLLOWER)
  clustermetadata.PoolerType pooler_type = 1;
}

message ChangeTypeResponse {
}

// Promote promotes a replica to leader (Multigres-level operation)
// This is called during the Propagate stage of generalized consensus
// to safely transition a standby to primary and reconfigure replication.
message PromoteRequest {
  // Consensus term for this promotion operation
  // Used to ensure this promotion corresponds to the correct term
  int64 consensus_term = 1;

  // Expected LSN position before promotion (optional, for validation)
  // By the Propagate stage, replication should already be stopped and the LSN frozen.
  // This is an assertion to verify the node has the expected durable state.
  // If the actual LSN doesn't match, this indicates an error in an earlier consensus stage.
  // If empty, skip LSN validation.
  string expected_lsn = 2;

  // Synchronous replication configuration to apply after promotion
  // This rewires the cohort for the new topology
  ConfigureSynchronousReplicationRequest sync_replication_config = 3;

  // Force the operation even if term validation fails
  // Should only be used in recovery scenarios
  bool force = 4;
}

message PromoteResponse {
  // LSN position after promotion
  string lsn_position = 1;

  // Whether the node was already promoted (idempotent check)
  bool was_already_primary = 2;

  // Consensus term at the time of promotion
  int64 consensus_term = 3;
}

// ResetReplication resets the standby's connection to its primary
message ResetReplicationRequest {
}

message ResetReplicationResponse {
  // Replication status when replication was reset
  ReplicationStatus status = 1;
}

// Synchronization method for standby servers
enum SynchronousMethod {
  // UNSPECIFIED means no synchronous replication (empty synchronous_standby_names)
  SYNCHRONOUS_METHOD_UNSPECIFIED = 0;

  // FIRST means wait for the first N standby servers (PostgreSQL default)
  SYNCHRONOUS_METHOD_FIRST = 1;

  // ANY means wait for any N standby servers
  SYNCHRONOUS_METHOD_ANY = 2;
}

// Enum representing the type of standby list modification
enum StandbyUpdateOperation {
  STANDBY_UPDATE_OPERATION_UNSPECIFIED = 0;
  STANDBY_UPDATE_OPERATION_ADD = 1;
  STANDBY_UPDATE_OPERATION_REMOVE = 2;
  STANDBY_UPDATE_OPERATION_REPLACE = 3;
}

// Synchronous commit level
enum SynchronousCommitLevel {
  // OFF disables synchronous commit
  SYNCHRONOUS_COMMIT_OFF = 0;

  // LOCAL waits for local flush to disk
  SYNCHRONOUS_COMMIT_LOCAL = 1;

  // REMOTE_WRITE waits for standby to receive and write WAL
  SYNCHRONOUS_COMMIT_REMOTE_WRITE = 2;

  // ON waits for standby to receive, write, and flush WAL (same as remote_apply in newer versions)
  SYNCHRONOUS_COMMIT_ON = 3;

  // REMOTE_APPLY waits for standby to receive, write, flush, and apply WAL
  SYNCHRONOUS_COMMIT_REMOTE_APPLY = 4;
}

// ConfigureSynchronousReplication configures PostgreSQL synchronous replication settings
message ConfigureSynchronousReplicationRequest {
  // Synchronous commit level (synchronous_commit setting)
  SynchronousCommitLevel synchronous_commit = 1;

  // Synchronization method (FIRST, ANY)
  SynchronousMethod synchronous_method = 2;

  // Number of standby servers to wait for (quorum count)
  int32 num_sync = 3;

  // List of standby multipooler IDs that can participate in synchronous replication
  // The application names will be generated as {cell}_{name} from these IDs
  repeated clustermetadata.ID standby_ids = 4;

  // Whether to reload configuration immediately
  bool reload_config = 5;
}

message ConfigureSynchronousReplicationResponse {
}

// Status gets the current status of the manager
message StatusRequest {
}

message StatusResponse {
  // Manager state (starting, ready, error)
  string state = 1;

  // Error message if state is error
  string error_message = 2;
}

// SetTerm sets the consensus term information
message SetTermRequest {
  // Consensus term information to set
  ConsensusTerm term = 1;
}

message SetTermResponse {
}

// UpdateSynchronousStandbyList updates the synchronous standby list
message UpdateSynchronousStandbyListRequest {
  // Operation to perform (add, remove, or replace)
  StandbyUpdateOperation operation = 1;

  // List of standby multipooler IDs to add/remove/replace
  // The application names will be generated as {cell}_{name} from these IDs
  repeated clustermetadata.ID standby_ids = 2;

  // Whether to reload configuration immediately
  bool reload_config = 3;

  // Consensus term (used by MultiOrch for term validation)
  int64 consensus_term = 4;

  // Force the operation even if the term doesn't match
  bool force = 5;
}

message UpdateSynchronousStandbyListResponse {
}

// ConsensusTerm represents the consensus term information for the pooler
// This is persisted to disk at $PGDATA/consensus/consensus_term.json
message ConsensusTerm {
  // Current consensus term
  int64 current_term = 1;

  // ID of the pooler this replica accepted as leader
  clustermetadata.ID accepted_leader = 2;

  // Timestamp of the last acceptance
  google.protobuf.Timestamp last_acceptance_time = 3;

  // ID of the leader of the current term
  clustermetadata.ID leader_id = 4;
}