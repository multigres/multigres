// Copyright 2025 Supabase, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package clustermetadata;

import "google/protobuf/timestamp.proto";

option go_package = "github.com/multigres/multigres/go/pb/clustermetadata";

// Topology Schemas for Multigres Cluster Management

// =============================================================================
// Global Topology
// =============================================================================

// TopoConfig defines the connection parameters for a topology service.
// It specifies the type of topology backend, where it's hosted, and the
// logical root path within that backend.
// This is not stored in the topo itself, but it's the entry point to
// configure the global topo.
message GlobalTopoConfig {
  // implementation indicates the type of topology service in use
  // (for example: "etcd2",  "memory").
  string implementation = 1;

  // server is the network address (host:port) of the topology service.
  // Can be a list list for HA setups.
  repeated string server_addresses = 2;

  // root is the logical root directory or namespace inside the topology backend
  // under which all cluster metadata will be stored.
  string root = 3;
}

// Cell describes how to connect to a cell topology.
// These records are stored in the global topology server.
message Cell {
  // name for this cell
  string name = 1;

  // server_address is the network address of the cell topology service.
  repeated string server_addresses = 2;

  // root is the namespace or directory path within the topology service
  // where this cell's metadata is stored. Used only when connecting to server_addresses.
  string root = 3;
}

message Database {
  // Name of the database
  string name = 1;

  // Backups location
  string backup_location = 2;

  // Durability policy used for consensus
  string durability_policy = 3;

  // List of cell identifiers where this database should be deployed
  repeated string cells = 4;

  // initialized indicates this database has been initialized and is ready to be used.
  bool initialized = 5;
}

// =============================================================================
// Cell Topology
// =============================================================================

// MultiPooler represents metadata about a running multipooler component instance in the cluster.
message MultiPooler {
  // id is the unique identifier of the multipooler in the cluster.
  ID id = 1;

  // Database name.
  string database = 2;

  // TableGroup name.
  string table_group = 3;

  // Shard name. If range based sharding is used, it should match
  // key_range.
  string shard = 4;

  // If range based sharding is used, range for the pooler's shard.
  KeyRange key_range = 5;

  // PoolerType is the kind of pooler: PRIMARY or REPLICA
  PoolerType type = 6;

  // PoolerServingStatus is the current type of the pooler.
  PoolerServingStatus serving_status = 7;

  // Fully qualified domain name of the host.
  string hostname = 8;

  // Map of named ports. These are ports that the pooler exposes. Initially, this will only be gRPC
  map<string, int32> port_map = 9;


}

// MultiGateway represents metadata about a running multigateway component instance in the cluster.
message MultiGateway {
  // id is the unique name of the multi gateway in the cluster.
  ID id = 1;

  // Fully qualified domain name of the host.
  string hostname = 2;

  // Map of named ports. Normally this should include postgres and grpc.
  map<string, int32> port_map = 3;
}

// MultiOrch represents information about a running instance of multiorch.
message MultiOrch {
  // id is the unique name of the MultiOrch in the cluster.
  ID id = 1;

  // Fully qualified domain name of the host.
  string hostname = 2;

  // Map of named ports. These are ports that MultiOrc exposes.
  map<string, int32> port_map = 3;
}

// ID is a globally unique pooler identifier.
message ID {
  // component identifies the type of Multigres component (multipooler, multigateway, or multiorch)
  ComponentType component = 1;

  // cell is the Multigres cell where the component is located
  string cell = 2;

  // name is a unique identifier for the component within the multigres
  // cluster.
  string name = 3;

  // =============================================================================
  // Auxiliary Data Types
  // =============================================================================

  // ComponentType represents the type of Multigres component
  enum ComponentType {
    // UNKNOWN represents an unknown or uninitialized component type
    UNKNOWN = 0;

    // MULTIPOOLER represents a multipooler component
    MULTIPOOLER = 1;

    // MULTIGATEWAY represents a multigateway component
    MULTIGATEWAY = 2;

    // MULTIORCH represents a multiorch component
    MULTIORCH = 3;
  }
}

// KeyRange represents a range of keys for sharding
message KeyRange {
  // start is the start key of the range (inclusive)
  bytes start = 1;

  // end is the end key of the range (exclusive)
  bytes end = 2;
}

// PoolerType represents the type of a given MultiPooler.
enum PoolerType {
  // UNKNOWN this is not a valid type.
  // It is useful during upgrades to detect when a value is not initialized
  UNKNOWN = 0;

  // PRIMARY is the primary server for the shard. Only PRIMARY allows DMLs.
  PRIMARY = 1;

  // REPLICA replicates from leader. It is used to read only traffic
  REPLICA = 2;
}

// PoolerServingStatus represents the serving status of the given MultiPooler.
enum PoolerServingStatus {
  // SERVING is the status a server during normal operations when it is serving traffic.
  SERVING = 0;

  // NOT_SERVING is the status of a server when it is not serving traffic.
  // This typically occurs during startup, shutdown, or when the server is
  // in an error state and cannot accept connections.
  NOT_SERVING = 1;

  // BACKUP is the status of a server when it is taking a backup. No queries
  // can be served in BACKUP mode.
  BACKUP = 2;

  // RESTORE is the status a server uses when restoring a backup, at
  // startup time.  No queries can be served in RESTORE mode.
  RESTORE = 3;

  // DRAINED is the status a server goes into when used by Multigres tools
  // to perform an offline action. It is a serving type (as
  // the tools processes may need to run queries), but it's not used
  // to route queries from Multigres users. In this state,
  // this multipooler is dedicated to the process that uses it.
  DRAINED = 4;

  // SERVING_RDONLY is the status of a server in read-only mode.
  // This is used during demotion when the server transitions from PRIMARY to REPLICA,
  // or for read-only replicas. The server accepts connections but only serves read queries.
  SERVING_RDONLY = 5;
}

// =============================================================================
// Durability Policy
// =============================================================================

// DurabilityPolicy defines consensus quorum rules for a shard.
// These policies are stored locally in each shard's postgres database
// and replicated via postgres streaming replication.
message DurabilityPolicy {
  // policy_name references Database.durability_policy (e.g., "any-two")
  string policy_name = 1;

  // policy_version allows policy evolution over time
  int64 policy_version = 2;

  // quorum_rule defines the actual quorum requirements
  QuorumRule quorum_rule = 3;

  // is_active indicates if this is the current active policy
  bool is_active = 4;

  // Audit timestamps
  google.protobuf.Timestamp created_at = 5;
  google.protobuf.Timestamp updated_at = 6;
}

// QuorumRule defines how many nodes are required for quorum
message QuorumRule {
  // quorum_type determines which quorum algorithm to use
  QuorumType quorum_type = 1;

  // required_count: number of nodes/cells required
  // - For QUORUM_TYPE_ANY_N: number of nodes required from discovered cohort
  // - For QUORUM_TYPE_MULTI_CELL_ANY_N: number of distinct cells required,
  //   with at least one node from each cell
  int32 required_count = 2;

  // Human-readable description
  string description = 3;

  // async_fallback defines behavior when insufficient standbys are available
  // for synchronous replication. Defaults to ALLOW if unset.
  AsyncReplicationFallbackMode async_fallback = 4;
}

// QuorumType enumerates supported quorum algorithms
enum QuorumType {
  // QUORUM_TYPE_UNKNOWN represents an unknown or uninitialized quorum type
  QUORUM_TYPE_UNKNOWN = 0;

  // QUORUM_TYPE_ANY_N requires any N nodes from discovered cohort
  QUORUM_TYPE_ANY_N = 1;

  // QUORUM_TYPE_MULTI_CELL_ANY_N requires nodes from multiple cells (availability zones)
  // with at least one node from each of the required cells
  QUORUM_TYPE_MULTI_CELL_ANY_N = 2;
}

// AsyncReplicationFallbackMode defines the behavior when insufficient standbys are available
// for synchronous replication to meet the quorum requirement
enum AsyncReplicationFallbackMode {
  // ASYNC_REPLICATION_FALLBACK_MODE_UNKNOWN represents an unknown or uninitialized mode
  ASYNC_REPLICATION_FALLBACK_MODE_UNKNOWN = 0;

  // ASYNC_REPLICATION_FALLBACK_MODE_ALLOW permits falling back to async replication
  // when no standby servers are available. This is the default behavior.
  ASYNC_REPLICATION_FALLBACK_MODE_ALLOW = 1;

  // ASYNC_REPLICATION_FALLBACK_MODE_REJECT rejects the leader appointment
  // if synchronous replication cannot be established to meet quorum requirements
  ASYNC_REPLICATION_FALLBACK_MODE_REJECT = 2;
}
