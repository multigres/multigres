// Copyright 2025 Supabase, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package multiadmin;

import "clustermetadata.proto";
import "google/api/annotations.proto";
import "google/protobuf/timestamp.proto";
import "multipoolermanagerdata.proto";

option go_package = "github.com/multigres/multigres/go/pb/multiadmin";

// MultiAdminService provides administrative gRPC APIs for querying cluster metadata
service MultiAdminService {
  // GetCell retrieves information about a specific cell
  rpc GetCell(GetCellRequest) returns (GetCellResponse) {
    option (google.api.http) = {get: "/api/v1/cells/{name}"};
  }

  // GetDatabase retrieves information about a specific database
  rpc GetDatabase(GetDatabaseRequest) returns (GetDatabaseResponse) {
    option (google.api.http) = {get: "/api/v1/databases/{name}"};
  }

  // GetCellNames retrieves all cell names in the cluster
  rpc GetCellNames(GetCellNamesRequest) returns (GetCellNamesResponse) {
    option (google.api.http) = {get: "/api/v1/cells"};
  }

  // GetDatabaseNames retrieves all database names in the cluster
  rpc GetDatabaseNames(GetDatabaseNamesRequest) returns (GetDatabaseNamesResponse) {
    option (google.api.http) = {get: "/api/v1/databases"};
  }

  // GetGateways retrieves gateways filtered by cells
  rpc GetGateways(GetGatewaysRequest) returns (GetGatewaysResponse) {
    option (google.api.http) = {get: "/api/v1/gateways"};
  }

  // GetPoolers retrieves poolers filtered by cells and/or database
  rpc GetPoolers(GetPoolersRequest) returns (GetPoolersResponse) {
    option (google.api.http) = {get: "/api/v1/poolers"};
  }

  // GetOrchs retrieves orchestrators filtered by cells
  rpc GetOrchs(GetOrchsRequest) returns (GetOrchsResponse) {
    option (google.api.http) = {get: "/api/v1/orchs"};
  }

  // Backup starts an async backup of a specific shard
  rpc Backup(BackupRequest) returns (BackupResponse) {
    option (google.api.http) = {
      post: "/api/v1/backups"
      body: "*"
    };
  }

  // RestoreFromBackup starts an async restore of a specific shard from a backup
  rpc RestoreFromBackup(RestoreFromBackupRequest) returns (RestoreFromBackupResponse) {
    option (google.api.http) = {
      post: "/api/v1/restores"
      body: "*"
    };
  }

  // GetBackupJobStatus checks the status of a backup or restore job
  rpc GetBackupJobStatus(GetBackupJobStatusRequest) returns (GetBackupJobStatusResponse) {
    option (google.api.http) = {get: "/api/v1/jobs/{job_id}"};
  }

  // GetBackups lists backup artifacts with optional filtering
  rpc GetBackups(GetBackupsRequest) returns (GetBackupsResponse) {
    option (google.api.http) = {get: "/api/v1/backups"};
  }

  //
  // Pooler Status (proxy methods)
  //

  // GetPoolerStatus retrieves the unified status of a specific pooler.
  // This proxies the request to the target pooler's MultiPoolerManager.Status RPC.
  rpc GetPoolerStatus(GetPoolerStatusRequest) returns (GetPoolerStatusResponse) {
    option (google.api.http) = {get: "/api/v1/poolers/{pooler_id.cell}/{pooler_id.name}/status"};
  }
}

// GetCellRequest specifies the cell to retrieve
message GetCellRequest {
  // name is the name of the cell to retrieve
  string name = 1;
}

// GetCellResponse contains the cell information
message GetCellResponse {
  // cell contains the Cell protobuf object
  clustermetadata.Cell cell = 1;
}

// GetDatabaseRequest specifies the database to retrieve
message GetDatabaseRequest {
  // name is the name of the database to retrieve
  string name = 1;
}

// GetDatabaseResponse contains the database information
message GetDatabaseResponse {
  // database contains the Database protobuf object
  clustermetadata.Database database = 1;
}

// GetCellNamesRequest requests all cell names
message GetCellNamesRequest {
}

// GetCellNamesResponse contains all cell names
message GetCellNamesResponse {
  repeated string names = 1;
}

// GetDatabaseNamesRequest requests all database names
message GetDatabaseNamesRequest {
}

// GetDatabaseNamesResponse contains all database names
message GetDatabaseNamesResponse {
  repeated string names = 1;
}

// GetGatewaysRequest requests gateways with optional filtering
message GetGatewaysRequest {
  // cells is a comma-separated list of cell names to filter by (optional)
  repeated string cells = 1;
}

// GetGatewaysResponse contains the filtered gateways
message GetGatewaysResponse {
  repeated clustermetadata.MultiGateway gateways = 1;
}

// GetPoolersRequest requests poolers with optional filtering
message GetPoolersRequest {
  // cells is a comma-separated list of cell names to filter by (optional)
  repeated string cells = 1;
  // database name to filter by (optional)
  string database = 2;
  // shard name to filter by (optional)
  string shard = 3;
}

// GetPoolersResponse contains the filtered poolers
message GetPoolersResponse {
  repeated clustermetadata.MultiPooler poolers = 1;
}

// GetOrchsRequest requests orchestrators with optional filtering
message GetOrchsRequest {
  // cells is a comma-separated list of cell names to filter by (optional)
  repeated string cells = 1;
}

// GetOrchsResponse contains the filtered orchestrators
message GetOrchsResponse {
  // protolint:disable:next REPEATED_FIELD_NAMES_PLURALIZED
  repeated clustermetadata.MultiOrch orchs = 1;
}

// Backup operation messages

// BackupRequest requests an async backup of a specific shard
message BackupRequest {
  // database name (required)
  string database = 1;
  // table_group name (required)
  string table_group = 2;
  // shard name (required)
  string shard = 3;
  // type of backup: "full", "differential", or "incremental" (required)
  string type = 4;
  // force_primary forces the backup to run on the primary instead of a replica.
  // This should typically be false because backups on replicas reduce load on the primary.
  bool force_primary = 5;
}

// BackupResponse contains the job ID for tracking the async backup
message BackupResponse {
  // job_id is the unique identifier for tracking this backup job
  string job_id = 1;
}

// RestoreFromBackup operation messages

// RestoreFromBackupRequest requests an async restore of a specific shard
message RestoreFromBackupRequest {
  // database name (required)
  string database = 1;
  // table_group name (required)
  string table_group = 2;
  // shard name (required)
  string shard = 3;
  // backup_id to restore from (optional, empty means "latest backup")
  string backup_id = 4;
  // pooler_id identifies which multipooler to restore to (required).
  // This is needed because a cell can have multiple poolers for the same
  // database/table_group/shard combination. Restores are only allowed to standbys.
  clustermetadata.ID pooler_id = 5;
}

// RestoreFromBackupResponse contains the job ID for tracking the async restore
message RestoreFromBackupResponse {
  // job_id is the unique identifier for tracking this restore job
  string job_id = 1;
}

// GetBackupJobStatus operation messages

// GetBackupJobStatusRequest requests the status of a backup or restore job
message GetBackupJobStatusRequest {
  // job_id to query (required)
  string job_id = 1;

  // Shard context for fallback lookup via MultiPooler when job is not in memory.
  // Required when job may have been lost due to process restart.
  string database = 2;
  string table_group = 3;
  string shard = 4;
}

// GetBackupJobStatusResponse contains the current status of a backup or restore job
message GetBackupJobStatusResponse {
  // job_id is the unique identifier for this job
  string job_id = 1;
  // job_type indicates whether this is a backup or restore job
  JobType job_type = 2;
  // status indicates the current state of the job
  JobStatus status = 3;
  // error_message contains the error if status is FAILED
  string error_message = 4;

  // Original request context
  string database = 5;
  string table_group = 6;
  string shard = 7;

  // For backup jobs
  string backup_type = 8; // "full", "differential", "incremental"

  // For restore jobs
  string requested_backup_id = 10; // What was requested (may be empty for "latest")

  // Results (set when status = COMPLETED)
  // For backup: created backup_id
  // For restore: backup_id that was restored
  string backup_id = 11;
}

// JobType indicates the type of async job
enum JobType {
  JOB_TYPE_UNKNOWN = 0;
  JOB_TYPE_BACKUP = 1;
  JOB_TYPE_RESTORE = 2;
}

// JobStatus indicates the current state of an async job
enum JobStatus {
  JOB_STATUS_UNKNOWN = 0;
  JOB_STATUS_PENDING = 1;
  JOB_STATUS_RUNNING = 2;
  JOB_STATUS_COMPLETED = 3;
  JOB_STATUS_FAILED = 4;
}

// GetBackups operation messages

// GetBackupsRequest requests a list of backup artifacts with optional filtering
message GetBackupsRequest {
  // database name to filter by (optional, empty means all databases)
  string database = 1;
  // table_group name to filter by (optional, empty means all table groups)
  string table_group = 2;
  // shard name to filter by (optional, empty means all shards)
  string shard = 3;
  // limit on number of results (optional, 0 means no limit)
  uint32 limit = 4;
}

// GetBackupsResponse contains the list of backup artifacts
message GetBackupsResponse {
  // backups is the list of backup information
  repeated BackupInfo backups = 1;
}

// BackupInfo contains information about a single backup artifact
message BackupInfo {
  // backup_id uniquely identifies this backup (e.g., "20250117-123456F")
  string backup_id = 1;
  // database name
  string database = 2;
  // table_group name
  string table_group = 3;
  // shard name
  string shard = 4;
  // type of backup: "full", "differential", or "incremental"
  string type = 5;
  // status of the backup
  BackupStatus status = 6;
  // backup_time is when the backup was created
  google.protobuf.Timestamp backup_time = 7;
  // backup_size_bytes is the size of the backup in bytes
  uint64 backup_size_bytes = 8;
  // multipooler_service_id is the ID of the multipooler that reported the backup
  string multipooler_service_id = 9;
  // pooler_type is the type of the multipooler (PRIMARY or REPLICA)
  clustermetadata.PoolerType pooler_type = 10;
}

// BackupStatus indicates the state of a backup artifact
enum BackupStatus {
  BACKUP_STATUS_UNKNOWN = 0;
  BACKUP_STATUS_INCOMPLETE = 1;
  BACKUP_STATUS_COMPLETE = 2;
  BACKUP_STATUS_FAILED = 3;
}

// GetPoolerStatus operation messages

// GetPoolerStatusRequest requests the status of a specific pooler
message GetPoolerStatusRequest {
  // pooler_id identifies which pooler to query (required)
  clustermetadata.ID pooler_id = 1;
}

// GetPoolerStatusResponse contains the pooler's unified status
message GetPoolerStatusResponse {
  // status contains the pooler's unified status from MultiPoolerManager.Status
  multipoolermanagerdata.Status status = 1;
}
