/*
Copyright 2025 Supabase, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// This file contains the RPC service definition for multipooler.

syntax = "proto3";

package multipoolerservice;

import "clustermetadata.proto";
import "mtrpc.proto";
import "query.proto";

option go_package = "github.com/multigres/multigres/go/pb/multipoolerservice";

// MultiPoolerService provides connection pooling and query execution
service MultiPoolerService {
  // ExecuteQuery executes a SQL query and returns the result
  // This should be used sparingly only when we know the result set is small,
  // otherwise StreamExecute should be used.
  rpc ExecuteQuery(ExecuteQueryRequest) returns (ExecuteQueryResponse);

  // StreamExecute executes a SQL query and streams the results back
  rpc StreamExecute(StreamExecuteRequest) returns (stream query.QueryResultPayload);

  // PortalStreamExecute executes a portal (bound prepared statement) and streams results
  // Returns reserved connection information for session affinity
  rpc PortalStreamExecute(PortalStreamExecuteRequest) returns (stream PortalStreamExecuteResponse);

  // Describe returns metadata about a prepared statement or portal
  rpc Describe(DescribeRequest) returns (DescribeResponse);

  // GetAuthCredentials retrieves authentication credentials for a user.
  // Used by multigateway to get SCRAM password hashes for client authentication.
  //
  // NOTE: This API may change. Currently fetches credentials one user at a time.
  // Future iterations could switch to a streaming model where multigateway maintains
  // an up-to-date cache of all password hashes and by real-time updates from multipooler
  // when any credentials change.
  rpc GetAuthCredentials(GetAuthCredentialsRequest) returns (GetAuthCredentialsResponse);

  // CopyBidiExecute handles bidirectional streaming operations (e.g., COPY commands).
  // The gateway sends the initial command and then streams data/messages.
  // The pooler responds with protocol-specific messages and final result.
  rpc CopyBidiExecute(stream CopyBidiExecuteRequest) returns (stream CopyBidiExecuteResponse);

  // ReserveStreamExecute creates a reserved connection and executes a query.
  // Based on ReservationOptions.reason, may execute BEGIN before the query (for transactions).
  // Returns the reserved connection ID for subsequent queries.
  rpc ReserveStreamExecute(ReserveStreamExecuteRequest) returns (stream ReserveStreamExecuteResponse);

  // ConcludeTransaction concludes a transaction on a reserved connection with COMMIT or ROLLBACK.
  // The connection may remain reserved if there are other reasons to keep it (e.g., temp tables).
  // Returns the reserved state - if non-empty, the connection is still reserved.
  rpc ConcludeTransaction(ConcludeTransactionRequest) returns (ConcludeTransactionResponse);

  // ReleaseReservedConnection forcefully releases a reserved connection regardless of reason.
  // Used during client disconnect to clean up all reserved connections on the multipooler.
  // If the connection has a transaction, ROLLBACK is executed.
  // If the connection has an active COPY, CopyFail is sent.
  // If the connection has portals, they are released.
  // If any cleanup step fails, the connection is tainted and closed.
  rpc ReleaseReservedConnection(ReleaseReservedConnectionRequest) returns (ReleaseReservedConnectionResponse);
}

// ExecuteQueryRequest represents a request to execute a SQL query
message ExecuteQueryRequest {
  string query = 1;

  // target specifies the routing destination (tablegroup, shard, pooler type)
  query.Target target = 2;

  uint64 max_rows = 3;

  // caller_id identifies the caller. This is the effective caller ID,
  // set by the application to further identify the caller.
  mtrpc.CallerID caller_id = 4;

  // options contains execution options including session state needed for query execution.
  query.ExecuteOptions options = 5;
}

// ExecuteQueryResponse represents the response from executing a SQL query
message ExecuteQueryResponse {
  query.QueryResult result = 1;
}

// StreamExecuteRequest represents a request to execute a SQL query with streaming results
message StreamExecuteRequest {
  // query is the SQL query to execute
  string query = 1;

  // target specifies the routing destination (tablegroup, shard, pooler type)
  query.Target target = 2;

  // caller_id identifies the caller. This is the effective caller ID,
  // set by the application to further identify the caller.
  mtrpc.CallerID caller_id = 3;

  // options contains execution options including session state needed for query execution.
  query.ExecuteOptions options = 4;
}

// StreamExecuteResponse represents a single response in the stream of query results
message StreamExecuteResponse {
  // result contains the query result data (rows, fields, etc.)
  query.QueryResult result = 1;
}

// PortalStreamExecuteRequest represents a request to execute a portal with streaming results
message PortalStreamExecuteRequest {
  // target specifies the routing destination (tablegroup, shard, pooler type)
  query.Target target = 1;

  // prepared_statement contains the prepared statement to execute
  query.PreparedStatement prepared_statement = 2;

  // portal contains the portal with bound parameters
  query.Portal portal = 3;

  // caller_id identifies the caller
  mtrpc.CallerID caller_id = 4;

  // options contains execution options including max rows and reserved connection ID
  query.ExecuteOptions options = 5;
}

// PortalStreamExecuteResponse represents a response in the portal execution stream
message PortalStreamExecuteResponse {
  // result contains the query result data (rows, fields, etc.) or diagnostics
  query.QueryResultPayload result = 1;

  // reserved_connection_id is the ID of the reserved connection
  // This is returned in the first response and should be used for subsequent queries
  uint64 reserved_connection_id = 2;

  // pooler_id identifies which multipooler instance owns the reserved connection
  clustermetadata.ID pooler_id = 3;
}

// DescribeRequest represents a request to describe a prepared statement or portal
message DescribeRequest {
  // target specifies the routing destination (tablegroup, shard, pooler type)
  query.Target target = 1;

  // prepared_statement is the prepared statement to describe (nil if describing a portal)
  query.PreparedStatement prepared_statement = 2;

  // portal is the portal to describe (nil if describing a prepared statement)
  query.Portal portal = 3;

  // caller_id identifies the caller
  mtrpc.CallerID caller_id = 4;

  // options contains execution options including reserved connection ID
  query.ExecuteOptions options = 5;
}

// DescribeResponse represents the response from describing a statement or portal
message DescribeResponse {
  // description contains the statement metadata (fields, parameter types, etc.)
  query.StatementDescription description = 1;
}

// GetAuthCredentialsRequest represents a request to get authentication credentials for a user.
message GetAuthCredentialsRequest {
  // database is the database the user is connecting to.
  string database = 1;

  // username is the PostgreSQL username to authenticate.
  string username = 2;
}

// GetAuthCredentialsResponse represents the response containing authentication credentials.
// Returns codes.NotFound if the user does not exist.
message GetAuthCredentialsResponse {
  // scram_hash is the stored SCRAM-SHA-256 password hash from pg_authid.
  // Format: SCRAM-SHA-256$<iterations>:<salt>$<stored_key>:<server_key>
  // Empty if user exists but has no password set.
  string scram_hash = 1;
}

// CopyBidiExecuteRequest represents a message in the bidirectional execute stream from gateway to pooler.
// Used for commands that require bidirectional streaming (e.g., COPY FROM STDIN, COPY TO STDOUT).
message CopyBidiExecuteRequest {
  // Phase indicates which phase of the operation this message represents
  enum Phase {
    INITIATE = 0;  // Initial command
    DATA = 1;      // Data chunk (for COPY FROM STDIN)
    DONE = 2;      // Finalize operation (all data sent for COPY FROM, or ready to receive for COPY TO)
    FAIL = 3;      // Abort operation
  }

  // phase indicates the current phase
  Phase phase = 1;

  // query is the SQL command to execute (only for INITIATE phase)
  string query = 2;

  // target specifies the routing destination (only for INITIATE phase)
  query.Target target = 3;

  // caller_id identifies the caller (only for INITIATE phase)
  mtrpc.CallerID caller_id = 4;

  // options contains execution options (only for INITIATE phase)
  query.ExecuteOptions options = 5;

  // data contains the data chunk (for DATA and DONE phases in COPY FROM STDIN)
  bytes data = 6;

  // error_message contains the error message (for FAIL phase)
  string error_message = 7;
}

// CopyBidiExecuteResponse represents a message in the bidirectional execute stream from pooler to gateway.
// Used for responses to commands that require bidirectional streaming.
message CopyBidiExecuteResponse {
  // Phase indicates which phase of the response this represents
  enum Phase {
    READY = 0;    // Command initiated successfully, ready for data streaming
    // For COPY FROM STDIN: PostgreSQL sent CopyInResponse
    // For COPY TO STDOUT: PostgreSQL sent CopyOutResponse
    DATA = 1;     // Data chunk (for COPY TO STDOUT)
    RESULT = 2;   // Final result (CommandComplete)
    ERROR = 3;    // Error occurred
  }

  // phase indicates the current phase
  Phase phase = 1;

  // reserved_connection_id is the ID of the reserved connection (for READY phase)
  uint64 reserved_connection_id = 2;

  // pooler_id identifies which multipooler instance owns the reserved connection (for READY phase)
  clustermetadata.ID pooler_id = 3;

  // format indicates the COPY format (for READY phase with COPY commands)
  // 0 = text, 1 = binary
  int32 format = 4;

  // column_formats contains the format code for each column (for READY phase with COPY commands)
  // Each value is 0 (text) or 1 (binary)
  repeated int32 column_formats = 8;

  // data contains the data chunk (for DATA phase in COPY TO STDOUT)
  bytes data = 5;

  // result contains the final query result (for RESULT phase)
  query.QueryResult result = 6;

  // error contains the error message (for ERROR phase)
  string error = 7;
}

// ReservationReason indicates why a connection needs to be reserved.
// Values are powers of 2 to allow combining multiple reasons via bitwise OR.
// A connection can be reserved for multiple reasons simultaneously (e.g., transaction + temp table).
// The connection is only released when all reasons are cleared.
enum ReservationReason {
  RESERVATION_REASON_UNSPECIFIED = 0;
  // Connection is reserved for a transaction - execute BEGIN before the query
  RESERVATION_REASON_TRANSACTION = 1;  // 0b001
  // Connection is reserved due to temporary tables - no BEGIN needed
  RESERVATION_REASON_TEMP_TABLE = 2;   // 0b010
  // Connection is reserved for portal/cursor operations
  RESERVATION_REASON_PORTAL = 4;       // 0b0100
  // Connection is reserved for an active COPY operation
  RESERVATION_REASON_COPY = 8;         // 0b1000
}

// ReservationOptions specifies options when creating a reserved connection.
// This is extensible for future options (e.g., isolation level, read-only mode).
message ReservationOptions {
  // reasons is a bitmask of ReservationReason values indicating why the connection is being reserved.
  // Multiple reasons can be ORed together (e.g., TRANSACTION | TEMP_TABLE).
  uint32 reasons = 1;
}

// TransactionConclusion specifies how to conclude a transaction.
enum TransactionConclusion {
  TRANSACTION_CONCLUSION_UNSPECIFIED = 0;
  // Execute COMMIT to commit the transaction
  TRANSACTION_CONCLUSION_COMMIT = 1;
  // Execute ROLLBACK to rollback the transaction
  TRANSACTION_CONCLUSION_ROLLBACK = 2;
}

// ReserveStreamExecuteRequest represents a request to create a reserved connection and execute a query.
message ReserveStreamExecuteRequest {
  // query is the SQL query to execute
  string query = 1;

  // target specifies the routing destination (tablegroup, shard, pooler type)
  query.Target target = 2;

  // caller_id identifies the caller
  mtrpc.CallerID caller_id = 3;

  // options contains execution options including session state
  query.ExecuteOptions options = 4;

  // reservation_options specifies why the connection is being reserved and what setup to perform
  ReservationOptions reservation_options = 5;
}

// ReserveStreamExecuteResponse represents a response in the stream of query results.
message ReserveStreamExecuteResponse {
  // result contains the query result data (rows, fields, etc.)
  query.QueryResult result = 1;

  // reserved_connection_id is the ID of the reserved connection
  // This is returned in the first response and should be used for subsequent queries
  uint64 reserved_connection_id = 2;

  // pooler_id identifies which multipooler instance owns the reserved connection
  clustermetadata.ID pooler_id = 3;
}

// ConcludeTransactionRequest represents a request to conclude a transaction on a reserved connection.
// The connection may or may not be released back to the pool depending on whether there are
// other reasons to keep it reserved (e.g., temporary tables).
message ConcludeTransactionRequest {
  // target specifies the routing destination (tablegroup, shard, pooler type)
  query.Target target = 1;

  // caller_id identifies the caller
  mtrpc.CallerID caller_id = 2;

  // options must include reserved_connection_id to identify the connection
  query.ExecuteOptions options = 3;

  // conclusion specifies whether to COMMIT or ROLLBACK the transaction
  TransactionConclusion conclusion = 4;
}

// ConcludeTransactionResponse represents the response from concluding a transaction.
message ConcludeTransactionResponse {
  // result contains the result of the COMMIT or ROLLBACK command
  query.QueryResult result = 1;

  // remaining_reasons is a bitmask of ReservationReason values indicating why the connection
  // is still reserved. Zero means the connection was released and ScatterConn should clear its state.
  uint32 remaining_reasons = 2;
}

// ReleaseReservedConnectionRequest requests forceful release of a reserved connection.
// The multipooler will handle all cleanup internally (rollback, COPY abort, portal release).
// If any cleanup step fails, the connection is tainted and closed so the pool creates a fresh one.
message ReleaseReservedConnectionRequest {
  // target specifies the routing destination (tablegroup, shard, pooler type)
  query.Target target = 1;

  // caller_id identifies the caller
  mtrpc.CallerID caller_id = 2;

  // options must include reserved_connection_id to identify the connection
  query.ExecuteOptions options = 3;
}

// ReleaseReservedConnectionResponse is the response from releasing a reserved connection.
// Intentionally minimal since this is a forceful cleanup operation.
message ReleaseReservedConnectionResponse {
}