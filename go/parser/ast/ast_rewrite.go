// Copyright 2025 Supabase, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package ast

// Code generated by asthelpergen. DO NOT EDIT.
// Function Generation Source: InterfaceMethod
func (a *application) rewriteNode(parent Node, node Node, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	switch node := node.(type) {
	case *A_ArrayExpr:
		return a.rewriteRefOfA_ArrayExpr(parent, node, replacer)
	case *A_Const:
		return a.rewriteRefOfA_Const(parent, node, replacer)
	case *A_Expr:
		return a.rewriteRefOfA_Expr(parent, node, replacer)
	case *A_Indices:
		return a.rewriteRefOfA_Indices(parent, node, replacer)
	case *A_Indirection:
		return a.rewriteRefOfA_Indirection(parent, node, replacer)
	case *A_Star:
		return a.rewriteRefOfA_Star(parent, node, replacer)
	case *AccessPriv:
		return a.rewriteRefOfAccessPriv(parent, node, replacer)
	case *Aggref:
		return a.rewriteRefOfAggref(parent, node, replacer)
	case *Alias:
		return a.rewriteRefOfAlias(parent, node, replacer)
	case *AlterCollationStmt:
		return a.rewriteRefOfAlterCollationStmt(parent, node, replacer)
	case *AlterCompositeTypeStmt:
		return a.rewriteRefOfAlterCompositeTypeStmt(parent, node, replacer)
	case *AlterDatabaseRefreshCollStmt:
		return a.rewriteRefOfAlterDatabaseRefreshCollStmt(parent, node, replacer)
	case *AlterDatabaseSetStmt:
		return a.rewriteRefOfAlterDatabaseSetStmt(parent, node, replacer)
	case *AlterDatabaseStmt:
		return a.rewriteRefOfAlterDatabaseStmt(parent, node, replacer)
	case *AlterDefaultPrivilegesStmt:
		return a.rewriteRefOfAlterDefaultPrivilegesStmt(parent, node, replacer)
	case *AlterDomainStmt:
		return a.rewriteRefOfAlterDomainStmt(parent, node, replacer)
	case *AlterEnumStmt:
		return a.rewriteRefOfAlterEnumStmt(parent, node, replacer)
	case *AlterEventTrigStmt:
		return a.rewriteRefOfAlterEventTrigStmt(parent, node, replacer)
	case *AlterExtensionContentsStmt:
		return a.rewriteRefOfAlterExtensionContentsStmt(parent, node, replacer)
	case *AlterExtensionStmt:
		return a.rewriteRefOfAlterExtensionStmt(parent, node, replacer)
	case *AlterFdwStmt:
		return a.rewriteRefOfAlterFdwStmt(parent, node, replacer)
	case *AlterForeignServerStmt:
		return a.rewriteRefOfAlterForeignServerStmt(parent, node, replacer)
	case *AlterFunctionStmt:
		return a.rewriteRefOfAlterFunctionStmt(parent, node, replacer)
	case *AlterObjectDependsStmt:
		return a.rewriteRefOfAlterObjectDependsStmt(parent, node, replacer)
	case *AlterObjectSchemaStmt:
		return a.rewriteRefOfAlterObjectSchemaStmt(parent, node, replacer)
	case *AlterOpFamilyStmt:
		return a.rewriteRefOfAlterOpFamilyStmt(parent, node, replacer)
	case *AlterOperatorStmt:
		return a.rewriteRefOfAlterOperatorStmt(parent, node, replacer)
	case *AlterOwnerStmt:
		return a.rewriteRefOfAlterOwnerStmt(parent, node, replacer)
	case *AlterPolicyStmt:
		return a.rewriteRefOfAlterPolicyStmt(parent, node, replacer)
	case *AlterPublicationStmt:
		return a.rewriteRefOfAlterPublicationStmt(parent, node, replacer)
	case *AlterRoleSetStmt:
		return a.rewriteRefOfAlterRoleSetStmt(parent, node, replacer)
	case *AlterRoleStmt:
		return a.rewriteRefOfAlterRoleStmt(parent, node, replacer)
	case *AlterSeqStmt:
		return a.rewriteRefOfAlterSeqStmt(parent, node, replacer)
	case *AlterStatsStmt:
		return a.rewriteRefOfAlterStatsStmt(parent, node, replacer)
	case *AlterSubscriptionStmt:
		return a.rewriteRefOfAlterSubscriptionStmt(parent, node, replacer)
	case *AlterSystemStmt:
		return a.rewriteRefOfAlterSystemStmt(parent, node, replacer)
	case *AlterTSConfigurationStmt:
		return a.rewriteRefOfAlterTSConfigurationStmt(parent, node, replacer)
	case *AlterTSDictionaryStmt:
		return a.rewriteRefOfAlterTSDictionaryStmt(parent, node, replacer)
	case *AlterTableCmd:
		return a.rewriteRefOfAlterTableCmd(parent, node, replacer)
	case *AlterTableMoveAllStmt:
		return a.rewriteRefOfAlterTableMoveAllStmt(parent, node, replacer)
	case *AlterTableSpaceStmt:
		return a.rewriteRefOfAlterTableSpaceStmt(parent, node, replacer)
	case *AlterTableStmt:
		return a.rewriteRefOfAlterTableStmt(parent, node, replacer)
	case *AlterTypeStmt:
		return a.rewriteRefOfAlterTypeStmt(parent, node, replacer)
	case *AlterUserMappingStmt:
		return a.rewriteRefOfAlterUserMappingStmt(parent, node, replacer)
	case *AlternativeSubPlan:
		return a.rewriteRefOfAlternativeSubPlan(parent, node, replacer)
	case *ArrayCoerceExpr:
		return a.rewriteRefOfArrayCoerceExpr(parent, node, replacer)
	case *ArrayExpr:
		return a.rewriteRefOfArrayExpr(parent, node, replacer)
	case *BaseExpr:
		return a.rewriteRefOfBaseExpr(parent, node, replacer)
	case *BaseNode:
		return a.rewriteRefOfBaseNode(parent, node, replacer)
	case *BitString:
		return a.rewriteRefOfBitString(parent, node, replacer)
	case *BoolExpr:
		return a.rewriteRefOfBoolExpr(parent, node, replacer)
	case *Boolean:
		return a.rewriteRefOfBoolean(parent, node, replacer)
	case *BooleanTest:
		return a.rewriteRefOfBooleanTest(parent, node, replacer)
	case *CTECycleClause:
		return a.rewriteRefOfCTECycleClause(parent, node, replacer)
	case *CTESearchClause:
		return a.rewriteRefOfCTESearchClause(parent, node, replacer)
	case *CallStmt:
		return a.rewriteRefOfCallStmt(parent, node, replacer)
	case *CaseExpr:
		return a.rewriteRefOfCaseExpr(parent, node, replacer)
	case *CaseTestExpr:
		return a.rewriteRefOfCaseTestExpr(parent, node, replacer)
	case *CaseWhen:
		return a.rewriteRefOfCaseWhen(parent, node, replacer)
	case *CheckPointStmt:
		return a.rewriteRefOfCheckPointStmt(parent, node, replacer)
	case *ClosePortalStmt:
		return a.rewriteRefOfClosePortalStmt(parent, node, replacer)
	case *ClusterStmt:
		return a.rewriteRefOfClusterStmt(parent, node, replacer)
	case *CoalesceExpr:
		return a.rewriteRefOfCoalesceExpr(parent, node, replacer)
	case *CoerceToDomain:
		return a.rewriteRefOfCoerceToDomain(parent, node, replacer)
	case *CoerceToDomainValue:
		return a.rewriteRefOfCoerceToDomainValue(parent, node, replacer)
	case *CoerceViaIO:
		return a.rewriteRefOfCoerceViaIO(parent, node, replacer)
	case *CollateClause:
		return a.rewriteRefOfCollateClause(parent, node, replacer)
	case *CollateExpr:
		return a.rewriteRefOfCollateExpr(parent, node, replacer)
	case *ColumnDef:
		return a.rewriteRefOfColumnDef(parent, node, replacer)
	case *ColumnRef:
		return a.rewriteRefOfColumnRef(parent, node, replacer)
	case *CommentStmt:
		return a.rewriteRefOfCommentStmt(parent, node, replacer)
	case *CommonTableExpr:
		return a.rewriteRefOfCommonTableExpr(parent, node, replacer)
	case *CompositeTypeStmt:
		return a.rewriteRefOfCompositeTypeStmt(parent, node, replacer)
	case *Const:
		return a.rewriteRefOfConst(parent, node, replacer)
	case *Constraint:
		return a.rewriteRefOfConstraint(parent, node, replacer)
	case *ConstraintsSetStmt:
		return a.rewriteRefOfConstraintsSetStmt(parent, node, replacer)
	case *ConvertRowtypeExpr:
		return a.rewriteRefOfConvertRowtypeExpr(parent, node, replacer)
	case *CopyStmt:
		return a.rewriteRefOfCopyStmt(parent, node, replacer)
	case *CreateAmStmt:
		return a.rewriteRefOfCreateAmStmt(parent, node, replacer)
	case *CreateAssertionStmt:
		return a.rewriteRefOfCreateAssertionStmt(parent, node, replacer)
	case *CreateCastStmt:
		return a.rewriteRefOfCreateCastStmt(parent, node, replacer)
	case *CreateConversionStmt:
		return a.rewriteRefOfCreateConversionStmt(parent, node, replacer)
	case *CreateDomainStmt:
		return a.rewriteRefOfCreateDomainStmt(parent, node, replacer)
	case *CreateEnumStmt:
		return a.rewriteRefOfCreateEnumStmt(parent, node, replacer)
	case *CreateEventTrigStmt:
		return a.rewriteRefOfCreateEventTrigStmt(parent, node, replacer)
	case *CreateExtensionStmt:
		return a.rewriteRefOfCreateExtensionStmt(parent, node, replacer)
	case *CreateFdwStmt:
		return a.rewriteRefOfCreateFdwStmt(parent, node, replacer)
	case *CreateForeignServerStmt:
		return a.rewriteRefOfCreateForeignServerStmt(parent, node, replacer)
	case *CreateForeignTableStmt:
		return a.rewriteRefOfCreateForeignTableStmt(parent, node, replacer)
	case *CreateFunctionStmt:
		return a.rewriteRefOfCreateFunctionStmt(parent, node, replacer)
	case *CreateOpClassItem:
		return a.rewriteRefOfCreateOpClassItem(parent, node, replacer)
	case *CreateOpClassStmt:
		return a.rewriteRefOfCreateOpClassStmt(parent, node, replacer)
	case *CreateOpFamilyStmt:
		return a.rewriteRefOfCreateOpFamilyStmt(parent, node, replacer)
	case *CreatePLangStmt:
		return a.rewriteRefOfCreatePLangStmt(parent, node, replacer)
	case *CreatePolicyStmt:
		return a.rewriteRefOfCreatePolicyStmt(parent, node, replacer)
	case *CreatePublicationStmt:
		return a.rewriteRefOfCreatePublicationStmt(parent, node, replacer)
	case *CreateRangeStmt:
		return a.rewriteRefOfCreateRangeStmt(parent, node, replacer)
	case *CreateRoleStmt:
		return a.rewriteRefOfCreateRoleStmt(parent, node, replacer)
	case *CreateSchemaStmt:
		return a.rewriteRefOfCreateSchemaStmt(parent, node, replacer)
	case *CreateSeqStmt:
		return a.rewriteRefOfCreateSeqStmt(parent, node, replacer)
	case *CreateStatsStmt:
		return a.rewriteRefOfCreateStatsStmt(parent, node, replacer)
	case *CreateStmt:
		return a.rewriteRefOfCreateStmt(parent, node, replacer)
	case *CreateSubscriptionStmt:
		return a.rewriteRefOfCreateSubscriptionStmt(parent, node, replacer)
	case *CreateTableAsStmt:
		return a.rewriteRefOfCreateTableAsStmt(parent, node, replacer)
	case *CreateTableSpaceStmt:
		return a.rewriteRefOfCreateTableSpaceStmt(parent, node, replacer)
	case *CreateTransformStmt:
		return a.rewriteRefOfCreateTransformStmt(parent, node, replacer)
	case *CreateTriggerStmt:
		return a.rewriteRefOfCreateTriggerStmt(parent, node, replacer)
	case *CreateUserMappingStmt:
		return a.rewriteRefOfCreateUserMappingStmt(parent, node, replacer)
	case *CreatedbStmt:
		return a.rewriteRefOfCreatedbStmt(parent, node, replacer)
	case *CurrentOfExpr:
		return a.rewriteRefOfCurrentOfExpr(parent, node, replacer)
	case *DeallocateStmt:
		return a.rewriteRefOfDeallocateStmt(parent, node, replacer)
	case *DeclareCursorStmt:
		return a.rewriteRefOfDeclareCursorStmt(parent, node, replacer)
	case *DefElem:
		return a.rewriteRefOfDefElem(parent, node, replacer)
	case *DefineStmt:
		return a.rewriteRefOfDefineStmt(parent, node, replacer)
	case *DeleteStmt:
		return a.rewriteRefOfDeleteStmt(parent, node, replacer)
	case *DiscardStmt:
		return a.rewriteRefOfDiscardStmt(parent, node, replacer)
	case *DoStmt:
		return a.rewriteRefOfDoStmt(parent, node, replacer)
	case *DropOwnedStmt:
		return a.rewriteRefOfDropOwnedStmt(parent, node, replacer)
	case *DropRoleStmt:
		return a.rewriteRefOfDropRoleStmt(parent, node, replacer)
	case *DropStmt:
		return a.rewriteRefOfDropStmt(parent, node, replacer)
	case *DropTableSpaceStmt:
		return a.rewriteRefOfDropTableSpaceStmt(parent, node, replacer)
	case *DropUserMappingStmt:
		return a.rewriteRefOfDropUserMappingStmt(parent, node, replacer)
	case *DropdbStmt:
		return a.rewriteRefOfDropdbStmt(parent, node, replacer)
	case *ExecuteStmt:
		return a.rewriteRefOfExecuteStmt(parent, node, replacer)
	case *ExplainStmt:
		return a.rewriteRefOfExplainStmt(parent, node, replacer)
	case *FetchStmt:
		return a.rewriteRefOfFetchStmt(parent, node, replacer)
	case *FieldSelect:
		return a.rewriteRefOfFieldSelect(parent, node, replacer)
	case *FieldStore:
		return a.rewriteRefOfFieldStore(parent, node, replacer)
	case *Float:
		return a.rewriteRefOfFloat(parent, node, replacer)
	case *FromExpr:
		return a.rewriteRefOfFromExpr(parent, node, replacer)
	case *FuncCall:
		return a.rewriteRefOfFuncCall(parent, node, replacer)
	case *FuncExpr:
		return a.rewriteRefOfFuncExpr(parent, node, replacer)
	case *FunctionParameter:
		return a.rewriteRefOfFunctionParameter(parent, node, replacer)
	case *GrantRoleStmt:
		return a.rewriteRefOfGrantRoleStmt(parent, node, replacer)
	case *GrantStmt:
		return a.rewriteRefOfGrantStmt(parent, node, replacer)
	case *GroupingFunc:
		return a.rewriteRefOfGroupingFunc(parent, node, replacer)
	case *GroupingSet:
		return a.rewriteRefOfGroupingSet(parent, node, replacer)
	case *Identifier:
		return a.rewriteRefOfIdentifier(parent, node, replacer)
	case *ImportForeignSchemaStmt:
		return a.rewriteRefOfImportForeignSchemaStmt(parent, node, replacer)
	case *IndexElem:
		return a.rewriteRefOfIndexElem(parent, node, replacer)
	case *IndexStmt:
		return a.rewriteRefOfIndexStmt(parent, node, replacer)
	case *InferClause:
		return a.rewriteRefOfInferClause(parent, node, replacer)
	case *InferenceElem:
		return a.rewriteRefOfInferenceElem(parent, node, replacer)
	case *InsertStmt:
		return a.rewriteRefOfInsertStmt(parent, node, replacer)
	case *Integer:
		return a.rewriteRefOfInteger(parent, node, replacer)
	case *IntoClause:
		return a.rewriteRefOfIntoClause(parent, node, replacer)
	case *JoinExpr:
		return a.rewriteRefOfJoinExpr(parent, node, replacer)
	case *JsonAggConstructor:
		return a.rewriteRefOfJsonAggConstructor(parent, node, replacer)
	case *JsonArgument:
		return a.rewriteRefOfJsonArgument(parent, node, replacer)
	case *JsonArrayAgg:
		return a.rewriteRefOfJsonArrayAgg(parent, node, replacer)
	case *JsonArrayConstructor:
		return a.rewriteRefOfJsonArrayConstructor(parent, node, replacer)
	case *JsonArrayQueryConstructor:
		return a.rewriteRefOfJsonArrayQueryConstructor(parent, node, replacer)
	case *JsonBehavior:
		return a.rewriteRefOfJsonBehavior(parent, node, replacer)
	case *JsonConstructorExpr:
		return a.rewriteRefOfJsonConstructorExpr(parent, node, replacer)
	case *JsonExpr:
		return a.rewriteRefOfJsonExpr(parent, node, replacer)
	case *JsonFormat:
		return a.rewriteRefOfJsonFormat(parent, node, replacer)
	case *JsonFuncExpr:
		return a.rewriteRefOfJsonFuncExpr(parent, node, replacer)
	case *JsonIsPredicate:
		return a.rewriteRefOfJsonIsPredicate(parent, node, replacer)
	case *JsonKeyValue:
		return a.rewriteRefOfJsonKeyValue(parent, node, replacer)
	case *JsonObjectAgg:
		return a.rewriteRefOfJsonObjectAgg(parent, node, replacer)
	case *JsonObjectConstructor:
		return a.rewriteRefOfJsonObjectConstructor(parent, node, replacer)
	case *JsonOutput:
		return a.rewriteRefOfJsonOutput(parent, node, replacer)
	case *JsonParseExpr:
		return a.rewriteRefOfJsonParseExpr(parent, node, replacer)
	case *JsonReturning:
		return a.rewriteRefOfJsonReturning(parent, node, replacer)
	case *JsonScalarExpr:
		return a.rewriteRefOfJsonScalarExpr(parent, node, replacer)
	case *JsonSerializeExpr:
		return a.rewriteRefOfJsonSerializeExpr(parent, node, replacer)
	case *JsonTable:
		return a.rewriteRefOfJsonTable(parent, node, replacer)
	case *JsonTableColumn:
		return a.rewriteRefOfJsonTableColumn(parent, node, replacer)
	case *JsonTablePath:
		return a.rewriteRefOfJsonTablePath(parent, node, replacer)
	case *JsonTablePathScan:
		return a.rewriteRefOfJsonTablePathScan(parent, node, replacer)
	case *JsonTablePathSpec:
		return a.rewriteRefOfJsonTablePathSpec(parent, node, replacer)
	case *JsonTablePlan:
		return a.rewriteRefOfJsonTablePlan(parent, node, replacer)
	case *JsonTableSiblingJoin:
		return a.rewriteRefOfJsonTableSiblingJoin(parent, node, replacer)
	case *JsonValueExpr:
		return a.rewriteRefOfJsonValueExpr(parent, node, replacer)
	case *KeyAction:
		return a.rewriteRefOfKeyAction(parent, node, replacer)
	case *KeyActions:
		return a.rewriteRefOfKeyActions(parent, node, replacer)
	case *ListenStmt:
		return a.rewriteRefOfListenStmt(parent, node, replacer)
	case *LoadStmt:
		return a.rewriteRefOfLoadStmt(parent, node, replacer)
	case *LockStmt:
		return a.rewriteRefOfLockStmt(parent, node, replacer)
	case *LockingClause:
		return a.rewriteRefOfLockingClause(parent, node, replacer)
	case *MergeAction:
		return a.rewriteRefOfMergeAction(parent, node, replacer)
	case *MergeStmt:
		return a.rewriteRefOfMergeStmt(parent, node, replacer)
	case *MergeSupportFunc:
		return a.rewriteRefOfMergeSupportFunc(parent, node, replacer)
	case *MergeWhenClause:
		return a.rewriteRefOfMergeWhenClause(parent, node, replacer)
	case *MinMaxExpr:
		return a.rewriteRefOfMinMaxExpr(parent, node, replacer)
	case *MultiAssignRef:
		return a.rewriteRefOfMultiAssignRef(parent, node, replacer)
	case *NamedArgExpr:
		return a.rewriteRefOfNamedArgExpr(parent, node, replacer)
	case *NextValueExpr:
		return a.rewriteRefOfNextValueExpr(parent, node, replacer)
	case *NodeList:
		return a.rewriteRefOfNodeList(parent, node, replacer)
	case *NotifyStmt:
		return a.rewriteRefOfNotifyStmt(parent, node, replacer)
	case *Null:
		return a.rewriteRefOfNull(parent, node, replacer)
	case *NullTest:
		return a.rewriteRefOfNullTest(parent, node, replacer)
	case *ObjectWithArgs:
		return a.rewriteRefOfObjectWithArgs(parent, node, replacer)
	case *OnConflictClause:
		return a.rewriteRefOfOnConflictClause(parent, node, replacer)
	case *OnConflictExpr:
		return a.rewriteRefOfOnConflictExpr(parent, node, replacer)
	case *OpExpr:
		return a.rewriteRefOfOpExpr(parent, node, replacer)
	case *PLAssignStmt:
		return a.rewriteRefOfPLAssignStmt(parent, node, replacer)
	case *Param:
		return a.rewriteRefOfParam(parent, node, replacer)
	case *ParamRef:
		return a.rewriteRefOfParamRef(parent, node, replacer)
	case *ParenExpr:
		return a.rewriteRefOfParenExpr(parent, node, replacer)
	case *PartitionBoundSpec:
		return a.rewriteRefOfPartitionBoundSpec(parent, node, replacer)
	case *PartitionCmd:
		return a.rewriteRefOfPartitionCmd(parent, node, replacer)
	case *PartitionElem:
		return a.rewriteRefOfPartitionElem(parent, node, replacer)
	case *PartitionRangeDatum:
		return a.rewriteRefOfPartitionRangeDatum(parent, node, replacer)
	case *PartitionSpec:
		return a.rewriteRefOfPartitionSpec(parent, node, replacer)
	case *PrepareStmt:
		return a.rewriteRefOfPrepareStmt(parent, node, replacer)
	case *PublicationObjSpec:
		return a.rewriteRefOfPublicationObjSpec(parent, node, replacer)
	case *PublicationTable:
		return a.rewriteRefOfPublicationTable(parent, node, replacer)
	case *Query:
		return a.rewriteRefOfQuery(parent, node, replacer)
	case *RTEPermissionInfo:
		return a.rewriteRefOfRTEPermissionInfo(parent, node, replacer)
	case *RangeFunction:
		return a.rewriteRefOfRangeFunction(parent, node, replacer)
	case *RangeSubselect:
		return a.rewriteRefOfRangeSubselect(parent, node, replacer)
	case *RangeTableFunc:
		return a.rewriteRefOfRangeTableFunc(parent, node, replacer)
	case *RangeTableFuncCol:
		return a.rewriteRefOfRangeTableFuncCol(parent, node, replacer)
	case *RangeTableSample:
		return a.rewriteRefOfRangeTableSample(parent, node, replacer)
	case *RangeTblEntry:
		return a.rewriteRefOfRangeTblEntry(parent, node, replacer)
	case *RangeTblFunction:
		return a.rewriteRefOfRangeTblFunction(parent, node, replacer)
	case *RangeTblRef:
		return a.rewriteRefOfRangeTblRef(parent, node, replacer)
	case *RangeVar:
		return a.rewriteRefOfRangeVar(parent, node, replacer)
	case *RawStmt:
		return a.rewriteRefOfRawStmt(parent, node, replacer)
	case *ReassignOwnedStmt:
		return a.rewriteRefOfReassignOwnedStmt(parent, node, replacer)
	case *RefreshMatViewStmt:
		return a.rewriteRefOfRefreshMatViewStmt(parent, node, replacer)
	case *ReindexStmt:
		return a.rewriteRefOfReindexStmt(parent, node, replacer)
	case *RelabelType:
		return a.rewriteRefOfRelabelType(parent, node, replacer)
	case *RenameStmt:
		return a.rewriteRefOfRenameStmt(parent, node, replacer)
	case *ReplicaIdentityStmt:
		return a.rewriteRefOfReplicaIdentityStmt(parent, node, replacer)
	case *ResTarget:
		return a.rewriteRefOfResTarget(parent, node, replacer)
	case *ReturnStmt:
		return a.rewriteRefOfReturnStmt(parent, node, replacer)
	case *RoleSpec:
		return a.rewriteRefOfRoleSpec(parent, node, replacer)
	case RootNode:
		return a.rewriteRootNode(parent, node, replacer)
	case *RowCompareExpr:
		return a.rewriteRefOfRowCompareExpr(parent, node, replacer)
	case *RowExpr:
		return a.rewriteRefOfRowExpr(parent, node, replacer)
	case *RowMarkClause:
		return a.rewriteRefOfRowMarkClause(parent, node, replacer)
	case *RuleStmt:
		return a.rewriteRefOfRuleStmt(parent, node, replacer)
	case *SQLValueFunction:
		return a.rewriteRefOfSQLValueFunction(parent, node, replacer)
	case *ScalarArrayOpExpr:
		return a.rewriteRefOfScalarArrayOpExpr(parent, node, replacer)
	case *SecLabelStmt:
		return a.rewriteRefOfSecLabelStmt(parent, node, replacer)
	case *SelectStmt:
		return a.rewriteRefOfSelectStmt(parent, node, replacer)
	case *SetOperationStmt:
		return a.rewriteRefOfSetOperationStmt(parent, node, replacer)
	case *SetToDefault:
		return a.rewriteRefOfSetToDefault(parent, node, replacer)
	case *SinglePartitionSpec:
		return a.rewriteRefOfSinglePartitionSpec(parent, node, replacer)
	case *SortBy:
		return a.rewriteRefOfSortBy(parent, node, replacer)
	case *SortGroupClause:
		return a.rewriteRefOfSortGroupClause(parent, node, replacer)
	case *StatsElem:
		return a.rewriteRefOfStatsElem(parent, node, replacer)
	case *String:
		return a.rewriteRefOfString(parent, node, replacer)
	case *SubLink:
		return a.rewriteRefOfSubLink(parent, node, replacer)
	case *SubPlan:
		return a.rewriteRefOfSubPlan(parent, node, replacer)
	case *SubscriptingRef:
		return a.rewriteRefOfSubscriptingRef(parent, node, replacer)
	case *TableFunc:
		return a.rewriteRefOfTableFunc(parent, node, replacer)
	case *TableLikeClause:
		return a.rewriteRefOfTableLikeClause(parent, node, replacer)
	case *TableSampleClause:
		return a.rewriteRefOfTableSampleClause(parent, node, replacer)
	case *TargetEntry:
		return a.rewriteRefOfTargetEntry(parent, node, replacer)
	case *TransactionStmt:
		return a.rewriteRefOfTransactionStmt(parent, node, replacer)
	case *TriggerTransition:
		return a.rewriteRefOfTriggerTransition(parent, node, replacer)
	case *TruncateStmt:
		return a.rewriteRefOfTruncateStmt(parent, node, replacer)
	case *TypeCast:
		return a.rewriteRefOfTypeCast(parent, node, replacer)
	case *TypeName:
		return a.rewriteRefOfTypeName(parent, node, replacer)
	case *UnlistenStmt:
		return a.rewriteRefOfUnlistenStmt(parent, node, replacer)
	case *UpdateStmt:
		return a.rewriteRefOfUpdateStmt(parent, node, replacer)
	case *VacuumRelation:
		return a.rewriteRefOfVacuumRelation(parent, node, replacer)
	case *VacuumStmt:
		return a.rewriteRefOfVacuumStmt(parent, node, replacer)
	case *Var:
		return a.rewriteRefOfVar(parent, node, replacer)
	case *VariableSetStmt:
		return a.rewriteRefOfVariableSetStmt(parent, node, replacer)
	case *VariableShowStmt:
		return a.rewriteRefOfVariableShowStmt(parent, node, replacer)
	case *ViewStmt:
		return a.rewriteRefOfViewStmt(parent, node, replacer)
	case *WindowClause:
		return a.rewriteRefOfWindowClause(parent, node, replacer)
	case *WindowDef:
		return a.rewriteRefOfWindowDef(parent, node, replacer)
	case *WindowFunc:
		return a.rewriteRefOfWindowFunc(parent, node, replacer)
	case *WindowFuncRunCondition:
		return a.rewriteRefOfWindowFuncRunCondition(parent, node, replacer)
	case *WithCheckOption:
		return a.rewriteRefOfWithCheckOption(parent, node, replacer)
	case *WithClause:
		return a.rewriteRefOfWithClause(parent, node, replacer)
	case *XmlExpr:
		return a.rewriteRefOfXmlExpr(parent, node, replacer)
	case *XmlSerialize:
		return a.rewriteRefOfXmlSerialize(parent, node, replacer)
	default:
		// this should never happen
		return true
	}
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfA_ArrayExpr(parent Node, node *A_ArrayExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Elements, func(newNode, parent Node) {
		parent.(*A_ArrayExpr).Elements = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfA_Const(parent Node, node *A_Const, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteValue(node, node.Val, func(newNode, parent Node) {
		parent.(*A_Const).Val = newNode.(Value)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfA_Expr(parent Node, node *A_Expr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Name, func(newNode, parent Node) {
		parent.(*A_Expr).Name = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.Lexpr, func(newNode, parent Node) {
		parent.(*A_Expr).Lexpr = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.Rexpr, func(newNode, parent Node) {
		parent.(*A_Expr).Rexpr = newNode.(Node)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfA_Indices(parent Node, node *A_Indices, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteNode(node, node.Lidx, func(newNode, parent Node) {
		parent.(*A_Indices).Lidx = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.Uidx, func(newNode, parent Node) {
		parent.(*A_Indices).Uidx = newNode.(Node)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfA_Indirection(parent Node, node *A_Indirection, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteNode(node, node.Arg, func(newNode, parent Node) {
		parent.(*A_Indirection).Arg = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Indirection, func(newNode, parent Node) {
		parent.(*A_Indirection).Indirection = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfA_Star(parent Node, node *A_Star, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAccessPriv(parent Node, node *AccessPriv, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Cols, func(newNode, parent Node) {
		parent.(*AccessPriv).Cols = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAggref(parent Node, node *Aggref, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Aggdirectargs, func(newNode, parent Node) {
		parent.(*Aggref).Aggdirectargs = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Args, func(newNode, parent Node) {
		parent.(*Aggref).Args = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Aggorder, func(newNode, parent Node) {
		parent.(*Aggref).Aggorder = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Aggdistinct, func(newNode, parent Node) {
		parent.(*Aggref).Aggdistinct = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.Aggfilter, func(newNode, parent Node) {
		parent.(*Aggref).Aggfilter = newNode.(Node)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlias(parent Node, node *Alias, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.ColNames, func(newNode, parent Node) {
		parent.(*Alias).ColNames = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlterCollationStmt(parent Node, node *AlterCollationStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Collname, func(newNode, parent Node) {
		parent.(*AlterCollationStmt).Collname = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlterCompositeTypeStmt(parent Node, node *AlterCompositeTypeStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.TypeName, func(newNode, parent Node) {
		parent.(*AlterCompositeTypeStmt).TypeName = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Cmds, func(newNode, parent Node) {
		parent.(*AlterCompositeTypeStmt).Cmds = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlterDatabaseRefreshCollStmt(parent Node, node *AlterDatabaseRefreshCollStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlterDatabaseSetStmt(parent Node, node *AlterDatabaseSetStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfVariableSetStmt(node, node.Setstmt, func(newNode, parent Node) {
		parent.(*AlterDatabaseSetStmt).Setstmt = newNode.(*VariableSetStmt)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlterDatabaseStmt(parent Node, node *AlterDatabaseStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Options, func(newNode, parent Node) {
		parent.(*AlterDatabaseStmt).Options = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlterDefaultPrivilegesStmt(parent Node, node *AlterDefaultPrivilegesStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Options, func(newNode, parent Node) {
		parent.(*AlterDefaultPrivilegesStmt).Options = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfGrantStmt(node, node.Action, func(newNode, parent Node) {
		parent.(*AlterDefaultPrivilegesStmt).Action = newNode.(*GrantStmt)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlterDomainStmt(parent Node, node *AlterDomainStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.TypeName, func(newNode, parent Node) {
		parent.(*AlterDomainStmt).TypeName = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.Def, func(newNode, parent Node) {
		parent.(*AlterDomainStmt).Def = newNode.(Node)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlterEnumStmt(parent Node, node *AlterEnumStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.TypeName, func(newNode, parent Node) {
		parent.(*AlterEnumStmt).TypeName = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlterEventTrigStmt(parent Node, node *AlterEventTrigStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlterExtensionContentsStmt(parent Node, node *AlterExtensionContentsStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteNode(node, node.Object, func(newNode, parent Node) {
		parent.(*AlterExtensionContentsStmt).Object = newNode.(Node)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlterExtensionStmt(parent Node, node *AlterExtensionStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Options, func(newNode, parent Node) {
		parent.(*AlterExtensionStmt).Options = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlterFdwStmt(parent Node, node *AlterFdwStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.FuncOptions, func(newNode, parent Node) {
		parent.(*AlterFdwStmt).FuncOptions = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Options, func(newNode, parent Node) {
		parent.(*AlterFdwStmt).Options = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlterForeignServerStmt(parent Node, node *AlterForeignServerStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Options, func(newNode, parent Node) {
		parent.(*AlterForeignServerStmt).Options = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlterFunctionStmt(parent Node, node *AlterFunctionStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfObjectWithArgs(node, node.Func, func(newNode, parent Node) {
		parent.(*AlterFunctionStmt).Func = newNode.(*ObjectWithArgs)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Actions, func(newNode, parent Node) {
		parent.(*AlterFunctionStmt).Actions = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlterObjectDependsStmt(parent Node, node *AlterObjectDependsStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfRangeVar(node, node.Relation, func(newNode, parent Node) {
		parent.(*AlterObjectDependsStmt).Relation = newNode.(*RangeVar)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.Object, func(newNode, parent Node) {
		parent.(*AlterObjectDependsStmt).Object = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteRefOfString(node, node.Extname, func(newNode, parent Node) {
		parent.(*AlterObjectDependsStmt).Extname = newNode.(*String)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlterObjectSchemaStmt(parent Node, node *AlterObjectSchemaStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfRangeVar(node, node.Relation, func(newNode, parent Node) {
		parent.(*AlterObjectSchemaStmt).Relation = newNode.(*RangeVar)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.Object, func(newNode, parent Node) {
		parent.(*AlterObjectSchemaStmt).Object = newNode.(Node)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlterOpFamilyStmt(parent Node, node *AlterOpFamilyStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.OpFamilyName, func(newNode, parent Node) {
		parent.(*AlterOpFamilyStmt).OpFamilyName = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Items, func(newNode, parent Node) {
		parent.(*AlterOpFamilyStmt).Items = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlterOperatorStmt(parent Node, node *AlterOperatorStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfObjectWithArgs(node, node.Opername, func(newNode, parent Node) {
		parent.(*AlterOperatorStmt).Opername = newNode.(*ObjectWithArgs)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Options, func(newNode, parent Node) {
		parent.(*AlterOperatorStmt).Options = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlterOwnerStmt(parent Node, node *AlterOwnerStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfRangeVar(node, node.Relation, func(newNode, parent Node) {
		parent.(*AlterOwnerStmt).Relation = newNode.(*RangeVar)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.Object, func(newNode, parent Node) {
		parent.(*AlterOwnerStmt).Object = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteRefOfRoleSpec(node, node.Newowner, func(newNode, parent Node) {
		parent.(*AlterOwnerStmt).Newowner = newNode.(*RoleSpec)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlterPolicyStmt(parent Node, node *AlterPolicyStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfRangeVar(node, node.Table, func(newNode, parent Node) {
		parent.(*AlterPolicyStmt).Table = newNode.(*RangeVar)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Roles, func(newNode, parent Node) {
		parent.(*AlterPolicyStmt).Roles = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.Qual, func(newNode, parent Node) {
		parent.(*AlterPolicyStmt).Qual = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.WithCheck, func(newNode, parent Node) {
		parent.(*AlterPolicyStmt).WithCheck = newNode.(Node)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlterPublicationStmt(parent Node, node *AlterPublicationStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Options, func(newNode, parent Node) {
		parent.(*AlterPublicationStmt).Options = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.PubObjects, func(newNode, parent Node) {
		parent.(*AlterPublicationStmt).PubObjects = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlterRoleSetStmt(parent Node, node *AlterRoleSetStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfRoleSpec(node, node.Role, func(newNode, parent Node) {
		parent.(*AlterRoleSetStmt).Role = newNode.(*RoleSpec)
	}) {
		return false
	}
	if !a.rewriteRefOfVariableSetStmt(node, node.Setstmt, func(newNode, parent Node) {
		parent.(*AlterRoleSetStmt).Setstmt = newNode.(*VariableSetStmt)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlterRoleStmt(parent Node, node *AlterRoleStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfRoleSpec(node, node.Role, func(newNode, parent Node) {
		parent.(*AlterRoleStmt).Role = newNode.(*RoleSpec)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Options, func(newNode, parent Node) {
		parent.(*AlterRoleStmt).Options = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlterSeqStmt(parent Node, node *AlterSeqStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfRangeVar(node, node.Sequence, func(newNode, parent Node) {
		parent.(*AlterSeqStmt).Sequence = newNode.(*RangeVar)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Options, func(newNode, parent Node) {
		parent.(*AlterSeqStmt).Options = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlterStatsStmt(parent Node, node *AlterStatsStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.DefNames, func(newNode, parent Node) {
		parent.(*AlterStatsStmt).DefNames = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.StxStatTarget, func(newNode, parent Node) {
		parent.(*AlterStatsStmt).StxStatTarget = newNode.(Node)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlterSubscriptionStmt(parent Node, node *AlterSubscriptionStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Publication, func(newNode, parent Node) {
		parent.(*AlterSubscriptionStmt).Publication = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Options, func(newNode, parent Node) {
		parent.(*AlterSubscriptionStmt).Options = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlterSystemStmt(parent Node, node *AlterSystemStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfVariableSetStmt(node, node.Setstmt, func(newNode, parent Node) {
		parent.(*AlterSystemStmt).Setstmt = newNode.(*VariableSetStmt)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlterTSConfigurationStmt(parent Node, node *AlterTSConfigurationStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Cfgname, func(newNode, parent Node) {
		parent.(*AlterTSConfigurationStmt).Cfgname = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Tokentype, func(newNode, parent Node) {
		parent.(*AlterTSConfigurationStmt).Tokentype = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Dicts, func(newNode, parent Node) {
		parent.(*AlterTSConfigurationStmt).Dicts = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlterTSDictionaryStmt(parent Node, node *AlterTSDictionaryStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Dictname, func(newNode, parent Node) {
		parent.(*AlterTSDictionaryStmt).Dictname = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Options, func(newNode, parent Node) {
		parent.(*AlterTSDictionaryStmt).Options = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlterTableCmd(parent Node, node *AlterTableCmd, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfRoleSpec(node, node.Newowner, func(newNode, parent Node) {
		parent.(*AlterTableCmd).Newowner = newNode.(*RoleSpec)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.Def, func(newNode, parent Node) {
		parent.(*AlterTableCmd).Def = newNode.(Node)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlterTableMoveAllStmt(parent Node, node *AlterTableMoveAllStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Roles, func(newNode, parent Node) {
		parent.(*AlterTableMoveAllStmt).Roles = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlterTableSpaceStmt(parent Node, node *AlterTableSpaceStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Options, func(newNode, parent Node) {
		parent.(*AlterTableSpaceStmt).Options = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlterTableStmt(parent Node, node *AlterTableStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfRangeVar(node, node.Relation, func(newNode, parent Node) {
		parent.(*AlterTableStmt).Relation = newNode.(*RangeVar)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Cmds, func(newNode, parent Node) {
		parent.(*AlterTableStmt).Cmds = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlterTypeStmt(parent Node, node *AlterTypeStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.TypeName, func(newNode, parent Node) {
		parent.(*AlterTypeStmt).TypeName = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Options, func(newNode, parent Node) {
		parent.(*AlterTypeStmt).Options = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlterUserMappingStmt(parent Node, node *AlterUserMappingStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfRoleSpec(node, node.User, func(newNode, parent Node) {
		parent.(*AlterUserMappingStmt).User = newNode.(*RoleSpec)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Options, func(newNode, parent Node) {
		parent.(*AlterUserMappingStmt).Options = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfAlternativeSubPlan(parent Node, node *AlternativeSubPlan, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	for x, el := range node.Subplans {
		if !a.rewriteExpression(node, el, func(idx int) replacerFunc {
			return func(newNode, parent Node) {
				parent.(*AlternativeSubPlan).Subplans[x] = newNode.(Expression)
			}
		}(x)) {
			return false
		}
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfArrayCoerceExpr(parent Node, node *ArrayCoerceExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteExpression(node, node.Arg, func(newNode, parent Node) {
		parent.(*ArrayCoerceExpr).Arg = newNode.(Expression)
	}) {
		return false
	}
	if !a.rewriteExpression(node, node.Elemexpr, func(newNode, parent Node) {
		parent.(*ArrayCoerceExpr).Elemexpr = newNode.(Expression)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfArrayExpr(parent Node, node *ArrayExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Elements, func(newNode, parent Node) {
		parent.(*ArrayExpr).Elements = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfBaseExpr(parent Node, node *BaseExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfBaseNode(parent Node, node *BaseNode, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfBitString(parent Node, node *BitString, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfBoolExpr(parent Node, node *BoolExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Args, func(newNode, parent Node) {
		parent.(*BoolExpr).Args = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfBoolean(parent Node, node *Boolean, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfBooleanTest(parent Node, node *BooleanTest, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteExpression(node, node.Arg, func(newNode, parent Node) {
		parent.(*BooleanTest).Arg = newNode.(Expression)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCTECycleClause(parent Node, node *CTECycleClause, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.CycleColList, func(newNode, parent Node) {
		parent.(*CTECycleClause).CycleColList = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteExpression(node, node.CycleMarkValue, func(newNode, parent Node) {
		parent.(*CTECycleClause).CycleMarkValue = newNode.(Expression)
	}) {
		return false
	}
	if !a.rewriteExpression(node, node.CycleMarkDefault, func(newNode, parent Node) {
		parent.(*CTECycleClause).CycleMarkDefault = newNode.(Expression)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCTESearchClause(parent Node, node *CTESearchClause, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.SearchColList, func(newNode, parent Node) {
		parent.(*CTESearchClause).SearchColList = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCallStmt(parent Node, node *CallStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfFuncCall(node, node.Funccall, func(newNode, parent Node) {
		parent.(*CallStmt).Funccall = newNode.(*FuncCall)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCaseExpr(parent Node, node *CaseExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteNode(node, node.Arg, func(newNode, parent Node) {
		parent.(*CaseExpr).Arg = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Args, func(newNode, parent Node) {
		parent.(*CaseExpr).Args = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.Defresult, func(newNode, parent Node) {
		parent.(*CaseExpr).Defresult = newNode.(Node)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCaseTestExpr(parent Node, node *CaseTestExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCaseWhen(parent Node, node *CaseWhen, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteNode(node, node.Expr, func(newNode, parent Node) {
		parent.(*CaseWhen).Expr = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.Result, func(newNode, parent Node) {
		parent.(*CaseWhen).Result = newNode.(Node)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCheckPointStmt(parent Node, node *CheckPointStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfClosePortalStmt(parent Node, node *ClosePortalStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfClusterStmt(parent Node, node *ClusterStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfRangeVar(node, node.Relation, func(newNode, parent Node) {
		parent.(*ClusterStmt).Relation = newNode.(*RangeVar)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Params, func(newNode, parent Node) {
		parent.(*ClusterStmt).Params = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCoalesceExpr(parent Node, node *CoalesceExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Args, func(newNode, parent Node) {
		parent.(*CoalesceExpr).Args = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCoerceToDomain(parent Node, node *CoerceToDomain, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteExpression(node, node.Arg, func(newNode, parent Node) {
		parent.(*CoerceToDomain).Arg = newNode.(Expression)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCoerceToDomainValue(parent Node, node *CoerceToDomainValue, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCoerceViaIO(parent Node, node *CoerceViaIO, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteExpression(node, node.Arg, func(newNode, parent Node) {
		parent.(*CoerceViaIO).Arg = newNode.(Expression)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCollateClause(parent Node, node *CollateClause, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteNode(node, node.Arg, func(newNode, parent Node) {
		parent.(*CollateClause).Arg = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Collname, func(newNode, parent Node) {
		parent.(*CollateClause).Collname = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCollateExpr(parent Node, node *CollateExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteExpression(node, node.Arg, func(newNode, parent Node) {
		parent.(*CollateExpr).Arg = newNode.(Expression)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfColumnDef(parent Node, node *ColumnDef, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfTypeName(node, node.TypeName, func(newNode, parent Node) {
		parent.(*ColumnDef).TypeName = newNode.(*TypeName)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.RawDefault, func(newNode, parent Node) {
		parent.(*ColumnDef).RawDefault = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.CookedDefault, func(newNode, parent Node) {
		parent.(*ColumnDef).CookedDefault = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteRefOfRangeVar(node, node.IdentitySeq, func(newNode, parent Node) {
		parent.(*ColumnDef).IdentitySeq = newNode.(*RangeVar)
	}) {
		return false
	}
	if !a.rewriteRefOfCollateClause(node, node.Collclause, func(newNode, parent Node) {
		parent.(*ColumnDef).Collclause = newNode.(*CollateClause)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Constraints, func(newNode, parent Node) {
		parent.(*ColumnDef).Constraints = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Fdwoptions, func(newNode, parent Node) {
		parent.(*ColumnDef).Fdwoptions = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfColumnRef(parent Node, node *ColumnRef, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Fields, func(newNode, parent Node) {
		parent.(*ColumnRef).Fields = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCommentStmt(parent Node, node *CommentStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteNode(node, node.Object, func(newNode, parent Node) {
		parent.(*CommentStmt).Object = newNode.(Node)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCommonTableExpr(parent Node, node *CommonTableExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Aliascolnames, func(newNode, parent Node) {
		parent.(*CommonTableExpr).Aliascolnames = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.Ctequery, func(newNode, parent Node) {
		parent.(*CommonTableExpr).Ctequery = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteRefOfCTESearchClause(node, node.SearchClause, func(newNode, parent Node) {
		parent.(*CommonTableExpr).SearchClause = newNode.(*CTESearchClause)
	}) {
		return false
	}
	if !a.rewriteRefOfCTECycleClause(node, node.CycleClause, func(newNode, parent Node) {
		parent.(*CommonTableExpr).CycleClause = newNode.(*CTECycleClause)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Ctecolnames, func(newNode, parent Node) {
		parent.(*CommonTableExpr).Ctecolnames = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCompositeTypeStmt(parent Node, node *CompositeTypeStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfRangeVar(node, node.Typevar, func(newNode, parent Node) {
		parent.(*CompositeTypeStmt).Typevar = newNode.(*RangeVar)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Coldeflist, func(newNode, parent Node) {
		parent.(*CompositeTypeStmt).Coldeflist = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfConst(parent Node, node *Const, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfConstraint(parent Node, node *Constraint, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteNode(node, node.RawExpr, func(newNode, parent Node) {
		parent.(*Constraint).RawExpr = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Keys, func(newNode, parent Node) {
		parent.(*Constraint).Keys = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Including, func(newNode, parent Node) {
		parent.(*Constraint).Including = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Exclusions, func(newNode, parent Node) {
		parent.(*Constraint).Exclusions = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Options, func(newNode, parent Node) {
		parent.(*Constraint).Options = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.WhereClause, func(newNode, parent Node) {
		parent.(*Constraint).WhereClause = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteRefOfRangeVar(node, node.Pktable, func(newNode, parent Node) {
		parent.(*Constraint).Pktable = newNode.(*RangeVar)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.FkAttrs, func(newNode, parent Node) {
		parent.(*Constraint).FkAttrs = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.PkAttrs, func(newNode, parent Node) {
		parent.(*Constraint).PkAttrs = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.FkDelSetCols, func(newNode, parent Node) {
		parent.(*Constraint).FkDelSetCols = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfConstraintsSetStmt(parent Node, node *ConstraintsSetStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Constraints, func(newNode, parent Node) {
		parent.(*ConstraintsSetStmt).Constraints = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfConvertRowtypeExpr(parent Node, node *ConvertRowtypeExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteExpression(node, node.Arg, func(newNode, parent Node) {
		parent.(*ConvertRowtypeExpr).Arg = newNode.(Expression)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCopyStmt(parent Node, node *CopyStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfRangeVar(node, node.Relation, func(newNode, parent Node) {
		parent.(*CopyStmt).Relation = newNode.(*RangeVar)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.Query, func(newNode, parent Node) {
		parent.(*CopyStmt).Query = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Attlist, func(newNode, parent Node) {
		parent.(*CopyStmt).Attlist = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Options, func(newNode, parent Node) {
		parent.(*CopyStmt).Options = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.WhereClause, func(newNode, parent Node) {
		parent.(*CopyStmt).WhereClause = newNode.(Node)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCreateAmStmt(parent Node, node *CreateAmStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.HandlerName, func(newNode, parent Node) {
		parent.(*CreateAmStmt).HandlerName = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCreateAssertionStmt(parent Node, node *CreateAssertionStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Name, func(newNode, parent Node) {
		parent.(*CreateAssertionStmt).Name = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.CheckClause, func(newNode, parent Node) {
		parent.(*CreateAssertionStmt).CheckClause = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.ConstraintAttrSpec, func(newNode, parent Node) {
		parent.(*CreateAssertionStmt).ConstraintAttrSpec = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCreateCastStmt(parent Node, node *CreateCastStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfTypeName(node, node.SourceType, func(newNode, parent Node) {
		parent.(*CreateCastStmt).SourceType = newNode.(*TypeName)
	}) {
		return false
	}
	if !a.rewriteRefOfTypeName(node, node.TargetType, func(newNode, parent Node) {
		parent.(*CreateCastStmt).TargetType = newNode.(*TypeName)
	}) {
		return false
	}
	if !a.rewriteRefOfObjectWithArgs(node, node.Func, func(newNode, parent Node) {
		parent.(*CreateCastStmt).Func = newNode.(*ObjectWithArgs)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCreateConversionStmt(parent Node, node *CreateConversionStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.ConversionName, func(newNode, parent Node) {
		parent.(*CreateConversionStmt).ConversionName = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.FuncName, func(newNode, parent Node) {
		parent.(*CreateConversionStmt).FuncName = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCreateDomainStmt(parent Node, node *CreateDomainStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Domainname, func(newNode, parent Node) {
		parent.(*CreateDomainStmt).Domainname = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfTypeName(node, node.TypeName, func(newNode, parent Node) {
		parent.(*CreateDomainStmt).TypeName = newNode.(*TypeName)
	}) {
		return false
	}
	if !a.rewriteRefOfCollateClause(node, node.CollClause, func(newNode, parent Node) {
		parent.(*CreateDomainStmt).CollClause = newNode.(*CollateClause)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Constraints, func(newNode, parent Node) {
		parent.(*CreateDomainStmt).Constraints = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCreateEnumStmt(parent Node, node *CreateEnumStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.TypeName, func(newNode, parent Node) {
		parent.(*CreateEnumStmt).TypeName = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Vals, func(newNode, parent Node) {
		parent.(*CreateEnumStmt).Vals = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCreateEventTrigStmt(parent Node, node *CreateEventTrigStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.FuncName, func(newNode, parent Node) {
		parent.(*CreateEventTrigStmt).FuncName = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.WhenClause, func(newNode, parent Node) {
		parent.(*CreateEventTrigStmt).WhenClause = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCreateExtensionStmt(parent Node, node *CreateExtensionStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Options, func(newNode, parent Node) {
		parent.(*CreateExtensionStmt).Options = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCreateFdwStmt(parent Node, node *CreateFdwStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.FuncOptions, func(newNode, parent Node) {
		parent.(*CreateFdwStmt).FuncOptions = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Options, func(newNode, parent Node) {
		parent.(*CreateFdwStmt).Options = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCreateForeignServerStmt(parent Node, node *CreateForeignServerStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Options, func(newNode, parent Node) {
		parent.(*CreateForeignServerStmt).Options = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCreateForeignTableStmt(parent Node, node *CreateForeignTableStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfCreateStmt(node, node.Base, func(newNode, parent Node) {
		parent.(*CreateForeignTableStmt).Base = newNode.(*CreateStmt)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Options, func(newNode, parent Node) {
		parent.(*CreateForeignTableStmt).Options = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCreateFunctionStmt(parent Node, node *CreateFunctionStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.FuncName, func(newNode, parent Node) {
		parent.(*CreateFunctionStmt).FuncName = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Parameters, func(newNode, parent Node) {
		parent.(*CreateFunctionStmt).Parameters = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfTypeName(node, node.ReturnType, func(newNode, parent Node) {
		parent.(*CreateFunctionStmt).ReturnType = newNode.(*TypeName)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Options, func(newNode, parent Node) {
		parent.(*CreateFunctionStmt).Options = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.SQLBody, func(newNode, parent Node) {
		parent.(*CreateFunctionStmt).SQLBody = newNode.(Node)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCreateOpClassItem(parent Node, node *CreateOpClassItem, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfObjectWithArgs(node, node.Name, func(newNode, parent Node) {
		parent.(*CreateOpClassItem).Name = newNode.(*ObjectWithArgs)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.OrderFamily, func(newNode, parent Node) {
		parent.(*CreateOpClassItem).OrderFamily = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.ClassArgs, func(newNode, parent Node) {
		parent.(*CreateOpClassItem).ClassArgs = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfTypeName(node, node.StoredType, func(newNode, parent Node) {
		parent.(*CreateOpClassItem).StoredType = newNode.(*TypeName)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCreateOpClassStmt(parent Node, node *CreateOpClassStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.OpClassName, func(newNode, parent Node) {
		parent.(*CreateOpClassStmt).OpClassName = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.OpFamilyName, func(newNode, parent Node) {
		parent.(*CreateOpClassStmt).OpFamilyName = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfTypeName(node, node.DataType, func(newNode, parent Node) {
		parent.(*CreateOpClassStmt).DataType = newNode.(*TypeName)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Items, func(newNode, parent Node) {
		parent.(*CreateOpClassStmt).Items = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCreateOpFamilyStmt(parent Node, node *CreateOpFamilyStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.OpFamilyName, func(newNode, parent Node) {
		parent.(*CreateOpFamilyStmt).OpFamilyName = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCreatePLangStmt(parent Node, node *CreatePLangStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.PLHandler, func(newNode, parent Node) {
		parent.(*CreatePLangStmt).PLHandler = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.PLInline, func(newNode, parent Node) {
		parent.(*CreatePLangStmt).PLInline = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.PLValidator, func(newNode, parent Node) {
		parent.(*CreatePLangStmt).PLValidator = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCreatePolicyStmt(parent Node, node *CreatePolicyStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfRangeVar(node, node.Table, func(newNode, parent Node) {
		parent.(*CreatePolicyStmt).Table = newNode.(*RangeVar)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Roles, func(newNode, parent Node) {
		parent.(*CreatePolicyStmt).Roles = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.Qual, func(newNode, parent Node) {
		parent.(*CreatePolicyStmt).Qual = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.WithCheck, func(newNode, parent Node) {
		parent.(*CreatePolicyStmt).WithCheck = newNode.(Node)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCreatePublicationStmt(parent Node, node *CreatePublicationStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.PubObjects, func(newNode, parent Node) {
		parent.(*CreatePublicationStmt).PubObjects = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Options, func(newNode, parent Node) {
		parent.(*CreatePublicationStmt).Options = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCreateRangeStmt(parent Node, node *CreateRangeStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.TypeName, func(newNode, parent Node) {
		parent.(*CreateRangeStmt).TypeName = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Params, func(newNode, parent Node) {
		parent.(*CreateRangeStmt).Params = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCreateRoleStmt(parent Node, node *CreateRoleStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Options, func(newNode, parent Node) {
		parent.(*CreateRoleStmt).Options = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCreateSchemaStmt(parent Node, node *CreateSchemaStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfRoleSpec(node, node.Authrole, func(newNode, parent Node) {
		parent.(*CreateSchemaStmt).Authrole = newNode.(*RoleSpec)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.SchemaElts, func(newNode, parent Node) {
		parent.(*CreateSchemaStmt).SchemaElts = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCreateSeqStmt(parent Node, node *CreateSeqStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfRangeVar(node, node.Sequence, func(newNode, parent Node) {
		parent.(*CreateSeqStmt).Sequence = newNode.(*RangeVar)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Options, func(newNode, parent Node) {
		parent.(*CreateSeqStmt).Options = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCreateStatsStmt(parent Node, node *CreateStatsStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.DefNames, func(newNode, parent Node) {
		parent.(*CreateStatsStmt).DefNames = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.StatTypes, func(newNode, parent Node) {
		parent.(*CreateStatsStmt).StatTypes = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Exprs, func(newNode, parent Node) {
		parent.(*CreateStatsStmt).Exprs = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Relations, func(newNode, parent Node) {
		parent.(*CreateStatsStmt).Relations = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCreateStmt(parent Node, node *CreateStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfRangeVar(node, node.Relation, func(newNode, parent Node) {
		parent.(*CreateStmt).Relation = newNode.(*RangeVar)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.TableElts, func(newNode, parent Node) {
		parent.(*CreateStmt).TableElts = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.InhRelations, func(newNode, parent Node) {
		parent.(*CreateStmt).InhRelations = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfPartitionBoundSpec(node, node.PartBound, func(newNode, parent Node) {
		parent.(*CreateStmt).PartBound = newNode.(*PartitionBoundSpec)
	}) {
		return false
	}
	if !a.rewriteRefOfPartitionSpec(node, node.PartSpec, func(newNode, parent Node) {
		parent.(*CreateStmt).PartSpec = newNode.(*PartitionSpec)
	}) {
		return false
	}
	if !a.rewriteRefOfTypeName(node, node.OfTypename, func(newNode, parent Node) {
		parent.(*CreateStmt).OfTypename = newNode.(*TypeName)
	}) {
		return false
	}
	for x, el := range node.Constraints {
		if !a.rewriteRefOfConstraint(node, el, func(idx int) replacerFunc {
			return func(newNode, parent Node) {
				parent.(*CreateStmt).Constraints[x] = newNode.(*Constraint)
			}
		}(x)) {
			return false
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Options, func(newNode, parent Node) {
		parent.(*CreateStmt).Options = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCreateSubscriptionStmt(parent Node, node *CreateSubscriptionStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Publication, func(newNode, parent Node) {
		parent.(*CreateSubscriptionStmt).Publication = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Options, func(newNode, parent Node) {
		parent.(*CreateSubscriptionStmt).Options = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCreateTableAsStmt(parent Node, node *CreateTableAsStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteNode(node, node.Query, func(newNode, parent Node) {
		parent.(*CreateTableAsStmt).Query = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteRefOfIntoClause(node, node.Into, func(newNode, parent Node) {
		parent.(*CreateTableAsStmt).Into = newNode.(*IntoClause)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCreateTableSpaceStmt(parent Node, node *CreateTableSpaceStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfRoleSpec(node, node.Owner, func(newNode, parent Node) {
		parent.(*CreateTableSpaceStmt).Owner = newNode.(*RoleSpec)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Options, func(newNode, parent Node) {
		parent.(*CreateTableSpaceStmt).Options = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCreateTransformStmt(parent Node, node *CreateTransformStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfTypeName(node, node.TypeName, func(newNode, parent Node) {
		parent.(*CreateTransformStmt).TypeName = newNode.(*TypeName)
	}) {
		return false
	}
	if !a.rewriteRefOfObjectWithArgs(node, node.FromSql, func(newNode, parent Node) {
		parent.(*CreateTransformStmt).FromSql = newNode.(*ObjectWithArgs)
	}) {
		return false
	}
	if !a.rewriteRefOfObjectWithArgs(node, node.ToSql, func(newNode, parent Node) {
		parent.(*CreateTransformStmt).ToSql = newNode.(*ObjectWithArgs)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCreateTriggerStmt(parent Node, node *CreateTriggerStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfRangeVar(node, node.Relation, func(newNode, parent Node) {
		parent.(*CreateTriggerStmt).Relation = newNode.(*RangeVar)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Funcname, func(newNode, parent Node) {
		parent.(*CreateTriggerStmt).Funcname = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Args, func(newNode, parent Node) {
		parent.(*CreateTriggerStmt).Args = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Columns, func(newNode, parent Node) {
		parent.(*CreateTriggerStmt).Columns = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.WhenClause, func(newNode, parent Node) {
		parent.(*CreateTriggerStmt).WhenClause = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteRefOfRangeVar(node, node.Constrrel, func(newNode, parent Node) {
		parent.(*CreateTriggerStmt).Constrrel = newNode.(*RangeVar)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Transitions, func(newNode, parent Node) {
		parent.(*CreateTriggerStmt).Transitions = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCreateUserMappingStmt(parent Node, node *CreateUserMappingStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfRoleSpec(node, node.User, func(newNode, parent Node) {
		parent.(*CreateUserMappingStmt).User = newNode.(*RoleSpec)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Options, func(newNode, parent Node) {
		parent.(*CreateUserMappingStmt).Options = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCreatedbStmt(parent Node, node *CreatedbStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Options, func(newNode, parent Node) {
		parent.(*CreatedbStmt).Options = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfCurrentOfExpr(parent Node, node *CurrentOfExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfDeallocateStmt(parent Node, node *DeallocateStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfDeclareCursorStmt(parent Node, node *DeclareCursorStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteNode(node, node.Query, func(newNode, parent Node) {
		parent.(*DeclareCursorStmt).Query = newNode.(Node)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfDefElem(parent Node, node *DefElem, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteNode(node, node.Arg, func(newNode, parent Node) {
		parent.(*DefElem).Arg = newNode.(Node)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfDefineStmt(parent Node, node *DefineStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.DefNames, func(newNode, parent Node) {
		parent.(*DefineStmt).DefNames = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Args, func(newNode, parent Node) {
		parent.(*DefineStmt).Args = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Definition, func(newNode, parent Node) {
		parent.(*DefineStmt).Definition = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfDeleteStmt(parent Node, node *DeleteStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfRangeVar(node, node.Relation, func(newNode, parent Node) {
		parent.(*DeleteStmt).Relation = newNode.(*RangeVar)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.UsingClause, func(newNode, parent Node) {
		parent.(*DeleteStmt).UsingClause = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.WhereClause, func(newNode, parent Node) {
		parent.(*DeleteStmt).WhereClause = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.ReturningList, func(newNode, parent Node) {
		parent.(*DeleteStmt).ReturningList = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfWithClause(node, node.WithClause, func(newNode, parent Node) {
		parent.(*DeleteStmt).WithClause = newNode.(*WithClause)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfDiscardStmt(parent Node, node *DiscardStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfDoStmt(parent Node, node *DoStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Args, func(newNode, parent Node) {
		parent.(*DoStmt).Args = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfDropOwnedStmt(parent Node, node *DropOwnedStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Roles, func(newNode, parent Node) {
		parent.(*DropOwnedStmt).Roles = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfDropRoleStmt(parent Node, node *DropRoleStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Roles, func(newNode, parent Node) {
		parent.(*DropRoleStmt).Roles = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfDropStmt(parent Node, node *DropStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Objects, func(newNode, parent Node) {
		parent.(*DropStmt).Objects = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfDropTableSpaceStmt(parent Node, node *DropTableSpaceStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfDropUserMappingStmt(parent Node, node *DropUserMappingStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfRoleSpec(node, node.User, func(newNode, parent Node) {
		parent.(*DropUserMappingStmt).User = newNode.(*RoleSpec)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfDropdbStmt(parent Node, node *DropdbStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Options, func(newNode, parent Node) {
		parent.(*DropdbStmt).Options = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfExecuteStmt(parent Node, node *ExecuteStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Params, func(newNode, parent Node) {
		parent.(*ExecuteStmt).Params = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfExplainStmt(parent Node, node *ExplainStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteNode(node, node.Query, func(newNode, parent Node) {
		parent.(*ExplainStmt).Query = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Options, func(newNode, parent Node) {
		parent.(*ExplainStmt).Options = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfFetchStmt(parent Node, node *FetchStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfFieldSelect(parent Node, node *FieldSelect, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteExpression(node, node.Arg, func(newNode, parent Node) {
		parent.(*FieldSelect).Arg = newNode.(Expression)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfFieldStore(parent Node, node *FieldStore, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteExpression(node, node.Arg, func(newNode, parent Node) {
		parent.(*FieldStore).Arg = newNode.(Expression)
	}) {
		return false
	}
	for x, el := range node.Newvals {
		if !a.rewriteExpression(node, el, func(idx int) replacerFunc {
			return func(newNode, parent Node) {
				parent.(*FieldStore).Newvals[x] = newNode.(Expression)
			}
		}(x)) {
			return false
		}
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfFloat(parent Node, node *Float, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfFromExpr(parent Node, node *FromExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Fromlist, func(newNode, parent Node) {
		parent.(*FromExpr).Fromlist = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteExpression(node, node.Quals, func(newNode, parent Node) {
		parent.(*FromExpr).Quals = newNode.(Expression)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfFuncCall(parent Node, node *FuncCall, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Funcname, func(newNode, parent Node) {
		parent.(*FuncCall).Funcname = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Args, func(newNode, parent Node) {
		parent.(*FuncCall).Args = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.AggOrder, func(newNode, parent Node) {
		parent.(*FuncCall).AggOrder = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.AggFilter, func(newNode, parent Node) {
		parent.(*FuncCall).AggFilter = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteRefOfWindowDef(node, node.Over, func(newNode, parent Node) {
		parent.(*FuncCall).Over = newNode.(*WindowDef)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfFuncExpr(parent Node, node *FuncExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Args, func(newNode, parent Node) {
		parent.(*FuncExpr).Args = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfFunctionParameter(parent Node, node *FunctionParameter, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfTypeName(node, node.ArgType, func(newNode, parent Node) {
		parent.(*FunctionParameter).ArgType = newNode.(*TypeName)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.DefExpr, func(newNode, parent Node) {
		parent.(*FunctionParameter).DefExpr = newNode.(Node)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfGrantRoleStmt(parent Node, node *GrantRoleStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.GrantedRoles, func(newNode, parent Node) {
		parent.(*GrantRoleStmt).GrantedRoles = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.GranteeRoles, func(newNode, parent Node) {
		parent.(*GrantRoleStmt).GranteeRoles = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Opt, func(newNode, parent Node) {
		parent.(*GrantRoleStmt).Opt = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfRoleSpec(node, node.Grantor, func(newNode, parent Node) {
		parent.(*GrantRoleStmt).Grantor = newNode.(*RoleSpec)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfGrantStmt(parent Node, node *GrantStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Objects, func(newNode, parent Node) {
		parent.(*GrantStmt).Objects = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Privileges, func(newNode, parent Node) {
		parent.(*GrantStmt).Privileges = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Grantees, func(newNode, parent Node) {
		parent.(*GrantStmt).Grantees = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfRoleSpec(node, node.Grantor, func(newNode, parent Node) {
		parent.(*GrantStmt).Grantor = newNode.(*RoleSpec)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfGroupingFunc(parent Node, node *GroupingFunc, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Args, func(newNode, parent Node) {
		parent.(*GroupingFunc).Args = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Refs, func(newNode, parent Node) {
		parent.(*GroupingFunc).Refs = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Cols, func(newNode, parent Node) {
		parent.(*GroupingFunc).Cols = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfGroupingSet(parent Node, node *GroupingSet, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Content, func(newNode, parent Node) {
		parent.(*GroupingSet).Content = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfIdentifier(parent Node, node *Identifier, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfImportForeignSchemaStmt(parent Node, node *ImportForeignSchemaStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfString(node, node.ServerName, func(newNode, parent Node) {
		parent.(*ImportForeignSchemaStmt).ServerName = newNode.(*String)
	}) {
		return false
	}
	if !a.rewriteRefOfString(node, node.RemoteSchema, func(newNode, parent Node) {
		parent.(*ImportForeignSchemaStmt).RemoteSchema = newNode.(*String)
	}) {
		return false
	}
	if !a.rewriteRefOfString(node, node.LocalSchema, func(newNode, parent Node) {
		parent.(*ImportForeignSchemaStmt).LocalSchema = newNode.(*String)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.TableList, func(newNode, parent Node) {
		parent.(*ImportForeignSchemaStmt).TableList = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Options, func(newNode, parent Node) {
		parent.(*ImportForeignSchemaStmt).Options = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfIndexElem(parent Node, node *IndexElem, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteNode(node, node.Expr, func(newNode, parent Node) {
		parent.(*IndexElem).Expr = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Collation, func(newNode, parent Node) {
		parent.(*IndexElem).Collation = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Opclass, func(newNode, parent Node) {
		parent.(*IndexElem).Opclass = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Opclassopts, func(newNode, parent Node) {
		parent.(*IndexElem).Opclassopts = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfIndexStmt(parent Node, node *IndexStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfRangeVar(node, node.Relation, func(newNode, parent Node) {
		parent.(*IndexStmt).Relation = newNode.(*RangeVar)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.IndexParams, func(newNode, parent Node) {
		parent.(*IndexStmt).IndexParams = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.IndexIncludingParams, func(newNode, parent Node) {
		parent.(*IndexStmt).IndexIncludingParams = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Options, func(newNode, parent Node) {
		parent.(*IndexStmt).Options = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.WhereClause, func(newNode, parent Node) {
		parent.(*IndexStmt).WhereClause = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.ExcludeOpNames, func(newNode, parent Node) {
		parent.(*IndexStmt).ExcludeOpNames = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfInferClause(parent Node, node *InferClause, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.IndexElems, func(newNode, parent Node) {
		parent.(*InferClause).IndexElems = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.WhereClause, func(newNode, parent Node) {
		parent.(*InferClause).WhereClause = newNode.(Node)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfInferenceElem(parent Node, node *InferenceElem, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteNode(node, node.Expr, func(newNode, parent Node) {
		parent.(*InferenceElem).Expr = newNode.(Node)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfInsertStmt(parent Node, node *InsertStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfRangeVar(node, node.Relation, func(newNode, parent Node) {
		parent.(*InsertStmt).Relation = newNode.(*RangeVar)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Cols, func(newNode, parent Node) {
		parent.(*InsertStmt).Cols = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.SelectStmt, func(newNode, parent Node) {
		parent.(*InsertStmt).SelectStmt = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteRefOfOnConflictClause(node, node.OnConflictClause, func(newNode, parent Node) {
		parent.(*InsertStmt).OnConflictClause = newNode.(*OnConflictClause)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.ReturningList, func(newNode, parent Node) {
		parent.(*InsertStmt).ReturningList = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfWithClause(node, node.WithClause, func(newNode, parent Node) {
		parent.(*InsertStmt).WithClause = newNode.(*WithClause)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfInteger(parent Node, node *Integer, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfIntoClause(parent Node, node *IntoClause, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfRangeVar(node, node.Rel, func(newNode, parent Node) {
		parent.(*IntoClause).Rel = newNode.(*RangeVar)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.ColNames, func(newNode, parent Node) {
		parent.(*IntoClause).ColNames = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Options, func(newNode, parent Node) {
		parent.(*IntoClause).Options = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.ViewQuery, func(newNode, parent Node) {
		parent.(*IntoClause).ViewQuery = newNode.(Node)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJoinExpr(parent Node, node *JoinExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteNode(node, node.Larg, func(newNode, parent Node) {
		parent.(*JoinExpr).Larg = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.Rarg, func(newNode, parent Node) {
		parent.(*JoinExpr).Rarg = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.UsingClause, func(newNode, parent Node) {
		parent.(*JoinExpr).UsingClause = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfAlias(node, node.JoinUsingAlias, func(newNode, parent Node) {
		parent.(*JoinExpr).JoinUsingAlias = newNode.(*Alias)
	}) {
		return false
	}
	if !a.rewriteExpression(node, node.Quals, func(newNode, parent Node) {
		parent.(*JoinExpr).Quals = newNode.(Expression)
	}) {
		return false
	}
	if !a.rewriteRefOfAlias(node, node.Alias, func(newNode, parent Node) {
		parent.(*JoinExpr).Alias = newNode.(*Alias)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJsonAggConstructor(parent Node, node *JsonAggConstructor, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfJsonOutput(node, node.Output, func(newNode, parent Node) {
		parent.(*JsonAggConstructor).Output = newNode.(*JsonOutput)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.AggFilter, func(newNode, parent Node) {
		parent.(*JsonAggConstructor).AggFilter = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.AggOrder, func(newNode, parent Node) {
		parent.(*JsonAggConstructor).AggOrder = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfWindowDef(node, node.Over, func(newNode, parent Node) {
		parent.(*JsonAggConstructor).Over = newNode.(*WindowDef)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJsonArgument(parent Node, node *JsonArgument, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfJsonValueExpr(node, node.Val, func(newNode, parent Node) {
		parent.(*JsonArgument).Val = newNode.(*JsonValueExpr)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJsonArrayAgg(parent Node, node *JsonArrayAgg, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfJsonAggConstructor(node, node.Constructor, func(newNode, parent Node) {
		parent.(*JsonArrayAgg).Constructor = newNode.(*JsonAggConstructor)
	}) {
		return false
	}
	if !a.rewriteRefOfJsonValueExpr(node, node.Arg, func(newNode, parent Node) {
		parent.(*JsonArrayAgg).Arg = newNode.(*JsonValueExpr)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJsonArrayConstructor(parent Node, node *JsonArrayConstructor, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Exprs, func(newNode, parent Node) {
		parent.(*JsonArrayConstructor).Exprs = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfJsonOutput(node, node.Output, func(newNode, parent Node) {
		parent.(*JsonArrayConstructor).Output = newNode.(*JsonOutput)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJsonArrayQueryConstructor(parent Node, node *JsonArrayQueryConstructor, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteNode(node, node.Query, func(newNode, parent Node) {
		parent.(*JsonArrayQueryConstructor).Query = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteRefOfJsonOutput(node, node.Output, func(newNode, parent Node) {
		parent.(*JsonArrayQueryConstructor).Output = newNode.(*JsonOutput)
	}) {
		return false
	}
	if !a.rewriteRefOfJsonFormat(node, node.Format, func(newNode, parent Node) {
		parent.(*JsonArrayQueryConstructor).Format = newNode.(*JsonFormat)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJsonBehavior(parent Node, node *JsonBehavior, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteNode(node, node.Expr, func(newNode, parent Node) {
		parent.(*JsonBehavior).Expr = newNode.(Node)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJsonConstructorExpr(parent Node, node *JsonConstructorExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Args, func(newNode, parent Node) {
		parent.(*JsonConstructorExpr).Args = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteExpr(node, node.Func, func(newNode, parent Node) {
		parent.(*JsonConstructorExpr).Func = newNode.(Expr)
	}) {
		return false
	}
	if !a.rewriteExpr(node, node.Coercion, func(newNode, parent Node) {
		parent.(*JsonConstructorExpr).Coercion = newNode.(Expr)
	}) {
		return false
	}
	if !a.rewriteRefOfJsonReturning(node, node.Returning, func(newNode, parent Node) {
		parent.(*JsonConstructorExpr).Returning = newNode.(*JsonReturning)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJsonExpr(parent Node, node *JsonExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteNode(node, node.FormattedExpr, func(newNode, parent Node) {
		parent.(*JsonExpr).FormattedExpr = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteRefOfJsonFormat(node, node.Format, func(newNode, parent Node) {
		parent.(*JsonExpr).Format = newNode.(*JsonFormat)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.PathSpec, func(newNode, parent Node) {
		parent.(*JsonExpr).PathSpec = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteRefOfJsonReturning(node, node.Returning, func(newNode, parent Node) {
		parent.(*JsonExpr).Returning = newNode.(*JsonReturning)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.PassingValues, func(newNode, parent Node) {
		parent.(*JsonExpr).PassingValues = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfJsonBehavior(node, node.OnEmpty, func(newNode, parent Node) {
		parent.(*JsonExpr).OnEmpty = newNode.(*JsonBehavior)
	}) {
		return false
	}
	if !a.rewriteRefOfJsonBehavior(node, node.OnError, func(newNode, parent Node) {
		parent.(*JsonExpr).OnError = newNode.(*JsonBehavior)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJsonFormat(parent Node, node *JsonFormat, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJsonFuncExpr(parent Node, node *JsonFuncExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfJsonValueExpr(node, node.ContextItem, func(newNode, parent Node) {
		parent.(*JsonFuncExpr).ContextItem = newNode.(*JsonValueExpr)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.Pathspec, func(newNode, parent Node) {
		parent.(*JsonFuncExpr).Pathspec = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Passing, func(newNode, parent Node) {
		parent.(*JsonFuncExpr).Passing = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfJsonOutput(node, node.Output, func(newNode, parent Node) {
		parent.(*JsonFuncExpr).Output = newNode.(*JsonOutput)
	}) {
		return false
	}
	if !a.rewriteRefOfJsonBehavior(node, node.OnEmpty, func(newNode, parent Node) {
		parent.(*JsonFuncExpr).OnEmpty = newNode.(*JsonBehavior)
	}) {
		return false
	}
	if !a.rewriteRefOfJsonBehavior(node, node.OnError, func(newNode, parent Node) {
		parent.(*JsonFuncExpr).OnError = newNode.(*JsonBehavior)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJsonIsPredicate(parent Node, node *JsonIsPredicate, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteNode(node, node.Expr, func(newNode, parent Node) {
		parent.(*JsonIsPredicate).Expr = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteRefOfJsonFormat(node, node.Format, func(newNode, parent Node) {
		parent.(*JsonIsPredicate).Format = newNode.(*JsonFormat)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJsonKeyValue(parent Node, node *JsonKeyValue, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteExpr(node, node.Key, func(newNode, parent Node) {
		parent.(*JsonKeyValue).Key = newNode.(Expr)
	}) {
		return false
	}
	if !a.rewriteRefOfJsonValueExpr(node, node.Value, func(newNode, parent Node) {
		parent.(*JsonKeyValue).Value = newNode.(*JsonValueExpr)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJsonObjectAgg(parent Node, node *JsonObjectAgg, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfJsonAggConstructor(node, node.Constructor, func(newNode, parent Node) {
		parent.(*JsonObjectAgg).Constructor = newNode.(*JsonAggConstructor)
	}) {
		return false
	}
	if !a.rewriteRefOfJsonKeyValue(node, node.Arg, func(newNode, parent Node) {
		parent.(*JsonObjectAgg).Arg = newNode.(*JsonKeyValue)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJsonObjectConstructor(parent Node, node *JsonObjectConstructor, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Exprs, func(newNode, parent Node) {
		parent.(*JsonObjectConstructor).Exprs = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfJsonOutput(node, node.Output, func(newNode, parent Node) {
		parent.(*JsonObjectConstructor).Output = newNode.(*JsonOutput)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJsonOutput(parent Node, node *JsonOutput, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfTypeName(node, node.TypeName, func(newNode, parent Node) {
		parent.(*JsonOutput).TypeName = newNode.(*TypeName)
	}) {
		return false
	}
	if !a.rewriteRefOfJsonReturning(node, node.Returning, func(newNode, parent Node) {
		parent.(*JsonOutput).Returning = newNode.(*JsonReturning)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJsonParseExpr(parent Node, node *JsonParseExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfJsonValueExpr(node, node.Expr, func(newNode, parent Node) {
		parent.(*JsonParseExpr).Expr = newNode.(*JsonValueExpr)
	}) {
		return false
	}
	if !a.rewriteRefOfJsonOutput(node, node.Output, func(newNode, parent Node) {
		parent.(*JsonParseExpr).Output = newNode.(*JsonOutput)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJsonReturning(parent Node, node *JsonReturning, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfJsonFormat(node, node.Format, func(newNode, parent Node) {
		parent.(*JsonReturning).Format = newNode.(*JsonFormat)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJsonScalarExpr(parent Node, node *JsonScalarExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteExpr(node, node.Expr, func(newNode, parent Node) {
		parent.(*JsonScalarExpr).Expr = newNode.(Expr)
	}) {
		return false
	}
	if !a.rewriteRefOfJsonOutput(node, node.Output, func(newNode, parent Node) {
		parent.(*JsonScalarExpr).Output = newNode.(*JsonOutput)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJsonSerializeExpr(parent Node, node *JsonSerializeExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfJsonValueExpr(node, node.Expr, func(newNode, parent Node) {
		parent.(*JsonSerializeExpr).Expr = newNode.(*JsonValueExpr)
	}) {
		return false
	}
	if !a.rewriteRefOfJsonOutput(node, node.Output, func(newNode, parent Node) {
		parent.(*JsonSerializeExpr).Output = newNode.(*JsonOutput)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJsonTable(parent Node, node *JsonTable, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfJsonValueExpr(node, node.ContextItem, func(newNode, parent Node) {
		parent.(*JsonTable).ContextItem = newNode.(*JsonValueExpr)
	}) {
		return false
	}
	if !a.rewriteRefOfJsonTablePathSpec(node, node.Pathspec, func(newNode, parent Node) {
		parent.(*JsonTable).Pathspec = newNode.(*JsonTablePathSpec)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Passing, func(newNode, parent Node) {
		parent.(*JsonTable).Passing = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Columns, func(newNode, parent Node) {
		parent.(*JsonTable).Columns = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfJsonBehavior(node, node.OnError, func(newNode, parent Node) {
		parent.(*JsonTable).OnError = newNode.(*JsonBehavior)
	}) {
		return false
	}
	if !a.rewriteRefOfAlias(node, node.Alias, func(newNode, parent Node) {
		parent.(*JsonTable).Alias = newNode.(*Alias)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJsonTableColumn(parent Node, node *JsonTableColumn, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfTypeName(node, node.TypeName, func(newNode, parent Node) {
		parent.(*JsonTableColumn).TypeName = newNode.(*TypeName)
	}) {
		return false
	}
	if !a.rewriteRefOfJsonTablePathSpec(node, node.Pathspec, func(newNode, parent Node) {
		parent.(*JsonTableColumn).Pathspec = newNode.(*JsonTablePathSpec)
	}) {
		return false
	}
	if !a.rewriteRefOfJsonFormat(node, node.Format, func(newNode, parent Node) {
		parent.(*JsonTableColumn).Format = newNode.(*JsonFormat)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Columns, func(newNode, parent Node) {
		parent.(*JsonTableColumn).Columns = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfJsonBehavior(node, node.OnEmpty, func(newNode, parent Node) {
		parent.(*JsonTableColumn).OnEmpty = newNode.(*JsonBehavior)
	}) {
		return false
	}
	if !a.rewriteRefOfJsonBehavior(node, node.OnError, func(newNode, parent Node) {
		parent.(*JsonTableColumn).OnError = newNode.(*JsonBehavior)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJsonTablePath(parent Node, node *JsonTablePath, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfConst(node, node.Value, func(newNode, parent Node) {
		parent.(*JsonTablePath).Value = newNode.(*Const)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJsonTablePathScan(parent Node, node *JsonTablePathScan, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfJsonTablePath(node, node.Path, func(newNode, parent Node) {
		parent.(*JsonTablePathScan).Path = newNode.(*JsonTablePath)
	}) {
		return false
	}
	if !a.rewriteRefOfJsonTablePlan(node, node.Child, func(newNode, parent Node) {
		parent.(*JsonTablePathScan).Child = newNode.(*JsonTablePlan)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJsonTablePathSpec(parent Node, node *JsonTablePathSpec, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteNode(node, node.StringExpr, func(newNode, parent Node) {
		parent.(*JsonTablePathSpec).StringExpr = newNode.(Node)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJsonTablePlan(parent Node, node *JsonTablePlan, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJsonTableSiblingJoin(parent Node, node *JsonTableSiblingJoin, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfJsonTablePlan(node, node.Lplan, func(newNode, parent Node) {
		parent.(*JsonTableSiblingJoin).Lplan = newNode.(*JsonTablePlan)
	}) {
		return false
	}
	if !a.rewriteRefOfJsonTablePlan(node, node.Rplan, func(newNode, parent Node) {
		parent.(*JsonTableSiblingJoin).Rplan = newNode.(*JsonTablePlan)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfJsonValueExpr(parent Node, node *JsonValueExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteNode(node, node.RawExpr, func(newNode, parent Node) {
		parent.(*JsonValueExpr).RawExpr = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteExpr(node, node.FormattedExpr, func(newNode, parent Node) {
		parent.(*JsonValueExpr).FormattedExpr = newNode.(Expr)
	}) {
		return false
	}
	if !a.rewriteRefOfJsonFormat(node, node.Format, func(newNode, parent Node) {
		parent.(*JsonValueExpr).Format = newNode.(*JsonFormat)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfKeyAction(parent Node, node *KeyAction, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Cols, func(newNode, parent Node) {
		parent.(*KeyAction).Cols = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfKeyActions(parent Node, node *KeyActions, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfKeyAction(node, node.UpdateAction, func(newNode, parent Node) {
		parent.(*KeyActions).UpdateAction = newNode.(*KeyAction)
	}) {
		return false
	}
	if !a.rewriteRefOfKeyAction(node, node.DeleteAction, func(newNode, parent Node) {
		parent.(*KeyActions).DeleteAction = newNode.(*KeyAction)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfListenStmt(parent Node, node *ListenStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfLoadStmt(parent Node, node *LoadStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfLockStmt(parent Node, node *LockStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Relations, func(newNode, parent Node) {
		parent.(*LockStmt).Relations = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfLockingClause(parent Node, node *LockingClause, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.LockedRels, func(newNode, parent Node) {
		parent.(*LockingClause).LockedRels = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfMergeAction(parent Node, node *MergeAction, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteNode(node, node.Qual, func(newNode, parent Node) {
		parent.(*MergeAction).Qual = newNode.(Node)
	}) {
		return false
	}
	for x, el := range node.TargetList {
		if !a.rewriteRefOfTargetEntry(node, el, func(idx int) replacerFunc {
			return func(newNode, parent Node) {
				parent.(*MergeAction).TargetList[x] = newNode.(*TargetEntry)
			}
		}(x)) {
			return false
		}
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfMergeStmt(parent Node, node *MergeStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfRangeVar(node, node.Relation, func(newNode, parent Node) {
		parent.(*MergeStmt).Relation = newNode.(*RangeVar)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.SourceRelation, func(newNode, parent Node) {
		parent.(*MergeStmt).SourceRelation = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.JoinCondition, func(newNode, parent Node) {
		parent.(*MergeStmt).JoinCondition = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.MergeWhenClauses, func(newNode, parent Node) {
		parent.(*MergeStmt).MergeWhenClauses = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.ReturningList, func(newNode, parent Node) {
		parent.(*MergeStmt).ReturningList = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfWithClause(node, node.WithClause, func(newNode, parent Node) {
		parent.(*MergeStmt).WithClause = newNode.(*WithClause)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfMergeSupportFunc(parent Node, node *MergeSupportFunc, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfMergeWhenClause(parent Node, node *MergeWhenClause, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteNode(node, node.Condition, func(newNode, parent Node) {
		parent.(*MergeWhenClause).Condition = newNode.(Node)
	}) {
		return false
	}
	for x, el := range node.TargetList {
		if !a.rewriteRefOfResTarget(node, el, func(idx int) replacerFunc {
			return func(newNode, parent Node) {
				parent.(*MergeWhenClause).TargetList[x] = newNode.(*ResTarget)
			}
		}(x)) {
			return false
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Values, func(newNode, parent Node) {
		parent.(*MergeWhenClause).Values = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfMinMaxExpr(parent Node, node *MinMaxExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Args, func(newNode, parent Node) {
		parent.(*MinMaxExpr).Args = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfMultiAssignRef(parent Node, node *MultiAssignRef, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteNode(node, node.Source, func(newNode, parent Node) {
		parent.(*MultiAssignRef).Source = newNode.(Node)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfNamedArgExpr(parent Node, node *NamedArgExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteExpression(node, node.Arg, func(newNode, parent Node) {
		parent.(*NamedArgExpr).Arg = newNode.(Expression)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfNextValueExpr(parent Node, node *NextValueExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfNodeList(parent Node, node *NodeList, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	for x, el := range node.Items {
		if !a.rewriteNode(node, el, func(idx int) replacerFunc {
			return func(newNode, parent Node) {
				parent.(*NodeList).Items[x] = newNode.(Node)
			}
		}(x)) {
			return false
		}
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfNotifyStmt(parent Node, node *NotifyStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfNull(parent Node, node *Null, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfNullTest(parent Node, node *NullTest, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteExpression(node, node.Arg, func(newNode, parent Node) {
		parent.(*NullTest).Arg = newNode.(Expression)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfObjectWithArgs(parent Node, node *ObjectWithArgs, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Objname, func(newNode, parent Node) {
		parent.(*ObjectWithArgs).Objname = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Objargs, func(newNode, parent Node) {
		parent.(*ObjectWithArgs).Objargs = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.ObjfuncArgs, func(newNode, parent Node) {
		parent.(*ObjectWithArgs).ObjfuncArgs = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfOnConflictClause(parent Node, node *OnConflictClause, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfInferClause(node, node.Infer, func(newNode, parent Node) {
		parent.(*OnConflictClause).Infer = newNode.(*InferClause)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.TargetList, func(newNode, parent Node) {
		parent.(*OnConflictClause).TargetList = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.WhereClause, func(newNode, parent Node) {
		parent.(*OnConflictClause).WhereClause = newNode.(Node)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfOnConflictExpr(parent Node, node *OnConflictExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.ArbiterElems, func(newNode, parent Node) {
		parent.(*OnConflictExpr).ArbiterElems = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteExpression(node, node.ArbiterWhere, func(newNode, parent Node) {
		parent.(*OnConflictExpr).ArbiterWhere = newNode.(Expression)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.OnConflictSet, func(newNode, parent Node) {
		parent.(*OnConflictExpr).OnConflictSet = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteExpression(node, node.OnConflictWhere, func(newNode, parent Node) {
		parent.(*OnConflictExpr).OnConflictWhere = newNode.(Expression)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.ExclRelTlist, func(newNode, parent Node) {
		parent.(*OnConflictExpr).ExclRelTlist = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfOpExpr(parent Node, node *OpExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Args, func(newNode, parent Node) {
		parent.(*OpExpr).Args = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfPLAssignStmt(parent Node, node *PLAssignStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Indirection, func(newNode, parent Node) {
		parent.(*PLAssignStmt).Indirection = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfSelectStmt(node, node.Val, func(newNode, parent Node) {
		parent.(*PLAssignStmt).Val = newNode.(*SelectStmt)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfParam(parent Node, node *Param, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfParamRef(parent Node, node *ParamRef, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfParenExpr(parent Node, node *ParenExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteNode(node, node.Expr, func(newNode, parent Node) {
		parent.(*ParenExpr).Expr = newNode.(Node)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfPartitionBoundSpec(parent Node, node *PartitionBoundSpec, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.ListDatums, func(newNode, parent Node) {
		parent.(*PartitionBoundSpec).ListDatums = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.LowDatums, func(newNode, parent Node) {
		parent.(*PartitionBoundSpec).LowDatums = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.HighDatums, func(newNode, parent Node) {
		parent.(*PartitionBoundSpec).HighDatums = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfPartitionCmd(parent Node, node *PartitionCmd, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfRangeVar(node, node.Name, func(newNode, parent Node) {
		parent.(*PartitionCmd).Name = newNode.(*RangeVar)
	}) {
		return false
	}
	if !a.rewriteRefOfPartitionBoundSpec(node, node.Bound, func(newNode, parent Node) {
		parent.(*PartitionCmd).Bound = newNode.(*PartitionBoundSpec)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfPartitionElem(parent Node, node *PartitionElem, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteNode(node, node.Expr, func(newNode, parent Node) {
		parent.(*PartitionElem).Expr = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Collation, func(newNode, parent Node) {
		parent.(*PartitionElem).Collation = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Opclass, func(newNode, parent Node) {
		parent.(*PartitionElem).Opclass = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfPartitionRangeDatum(parent Node, node *PartitionRangeDatum, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteNode(node, node.Value, func(newNode, parent Node) {
		parent.(*PartitionRangeDatum).Value = newNode.(Node)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfPartitionSpec(parent Node, node *PartitionSpec, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.PartParams, func(newNode, parent Node) {
		parent.(*PartitionSpec).PartParams = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfPrepareStmt(parent Node, node *PrepareStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Argtypes, func(newNode, parent Node) {
		parent.(*PrepareStmt).Argtypes = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.Query, func(newNode, parent Node) {
		parent.(*PrepareStmt).Query = newNode.(Node)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfPublicationObjSpec(parent Node, node *PublicationObjSpec, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfPublicationTable(node, node.PubTable, func(newNode, parent Node) {
		parent.(*PublicationObjSpec).PubTable = newNode.(*PublicationTable)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfPublicationTable(parent Node, node *PublicationTable, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfRangeVar(node, node.Relation, func(newNode, parent Node) {
		parent.(*PublicationTable).Relation = newNode.(*RangeVar)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.WhereClause, func(newNode, parent Node) {
		parent.(*PublicationTable).WhereClause = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Columns, func(newNode, parent Node) {
		parent.(*PublicationTable).Columns = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfQuery(parent Node, node *Query, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteNode(node, node.UtilityStmt, func(newNode, parent Node) {
		parent.(*Query).UtilityStmt = newNode.(Node)
	}) {
		return false
	}
	for x, el := range node.CteList {
		if !a.rewriteRefOfCommonTableExpr(node, el, func(idx int) replacerFunc {
			return func(newNode, parent Node) {
				parent.(*Query).CteList[x] = newNode.(*CommonTableExpr)
			}
		}(x)) {
			return false
		}
	}
	for x, el := range node.Rtable {
		if !a.rewriteRefOfRangeTblEntry(node, el, func(idx int) replacerFunc {
			return func(newNode, parent Node) {
				parent.(*Query).Rtable[x] = newNode.(*RangeTblEntry)
			}
		}(x)) {
			return false
		}
	}
	if !a.rewriteRefOfNodeList(node, node.RtePermInfos, func(newNode, parent Node) {
		parent.(*Query).RtePermInfos = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfFromExpr(node, node.Jointree, func(newNode, parent Node) {
		parent.(*Query).Jointree = newNode.(*FromExpr)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.MergeActionList, func(newNode, parent Node) {
		parent.(*Query).MergeActionList = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.MergeJoinCondition, func(newNode, parent Node) {
		parent.(*Query).MergeJoinCondition = newNode.(Node)
	}) {
		return false
	}
	for x, el := range node.TargetList {
		if !a.rewriteRefOfTargetEntry(node, el, func(idx int) replacerFunc {
			return func(newNode, parent Node) {
				parent.(*Query).TargetList[x] = newNode.(*TargetEntry)
			}
		}(x)) {
			return false
		}
	}
	if !a.rewriteRefOfOnConflictExpr(node, node.OnConflict, func(newNode, parent Node) {
		parent.(*Query).OnConflict = newNode.(*OnConflictExpr)
	}) {
		return false
	}
	for x, el := range node.ReturningList {
		if !a.rewriteRefOfTargetEntry(node, el, func(idx int) replacerFunc {
			return func(newNode, parent Node) {
				parent.(*Query).ReturningList[x] = newNode.(*TargetEntry)
			}
		}(x)) {
			return false
		}
	}
	for x, el := range node.GroupClause {
		if !a.rewriteRefOfSortGroupClause(node, el, func(idx int) replacerFunc {
			return func(newNode, parent Node) {
				parent.(*Query).GroupClause[x] = newNode.(*SortGroupClause)
			}
		}(x)) {
			return false
		}
	}
	if !a.rewriteRefOfNodeList(node, node.GroupingSets, func(newNode, parent Node) {
		parent.(*Query).GroupingSets = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.HavingQual, func(newNode, parent Node) {
		parent.(*Query).HavingQual = newNode.(Node)
	}) {
		return false
	}
	for x, el := range node.WindowClause {
		if !a.rewriteRefOfWindowClause(node, el, func(idx int) replacerFunc {
			return func(newNode, parent Node) {
				parent.(*Query).WindowClause[x] = newNode.(*WindowClause)
			}
		}(x)) {
			return false
		}
	}
	for x, el := range node.DistinctClause {
		if !a.rewriteRefOfSortGroupClause(node, el, func(idx int) replacerFunc {
			return func(newNode, parent Node) {
				parent.(*Query).DistinctClause[x] = newNode.(*SortGroupClause)
			}
		}(x)) {
			return false
		}
	}
	for x, el := range node.SortClause {
		if !a.rewriteRefOfSortGroupClause(node, el, func(idx int) replacerFunc {
			return func(newNode, parent Node) {
				parent.(*Query).SortClause[x] = newNode.(*SortGroupClause)
			}
		}(x)) {
			return false
		}
	}
	if !a.rewriteNode(node, node.LimitOffset, func(newNode, parent Node) {
		parent.(*Query).LimitOffset = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.LimitCount, func(newNode, parent Node) {
		parent.(*Query).LimitCount = newNode.(Node)
	}) {
		return false
	}
	for x, el := range node.RowMarks {
		if !a.rewriteRefOfRowMarkClause(node, el, func(idx int) replacerFunc {
			return func(newNode, parent Node) {
				parent.(*Query).RowMarks[x] = newNode.(*RowMarkClause)
			}
		}(x)) {
			return false
		}
	}
	if !a.rewriteNode(node, node.SetOperations, func(newNode, parent Node) {
		parent.(*Query).SetOperations = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.WithCheckOptions, func(newNode, parent Node) {
		parent.(*Query).WithCheckOptions = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfRTEPermissionInfo(parent Node, node *RTEPermissionInfo, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfRangeFunction(parent Node, node *RangeFunction, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Functions, func(newNode, parent Node) {
		parent.(*RangeFunction).Functions = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfAlias(node, node.Alias, func(newNode, parent Node) {
		parent.(*RangeFunction).Alias = newNode.(*Alias)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.ColDefList, func(newNode, parent Node) {
		parent.(*RangeFunction).ColDefList = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfRangeSubselect(parent Node, node *RangeSubselect, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteNode(node, node.Subquery, func(newNode, parent Node) {
		parent.(*RangeSubselect).Subquery = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteRefOfAlias(node, node.Alias, func(newNode, parent Node) {
		parent.(*RangeSubselect).Alias = newNode.(*Alias)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfRangeTableFunc(parent Node, node *RangeTableFunc, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteNode(node, node.DocExpr, func(newNode, parent Node) {
		parent.(*RangeTableFunc).DocExpr = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.RowExpr, func(newNode, parent Node) {
		parent.(*RangeTableFunc).RowExpr = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Namespaces, func(newNode, parent Node) {
		parent.(*RangeTableFunc).Namespaces = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Columns, func(newNode, parent Node) {
		parent.(*RangeTableFunc).Columns = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfAlias(node, node.Alias, func(newNode, parent Node) {
		parent.(*RangeTableFunc).Alias = newNode.(*Alias)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfRangeTableFuncCol(parent Node, node *RangeTableFuncCol, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfTypeName(node, node.TypeName, func(newNode, parent Node) {
		parent.(*RangeTableFuncCol).TypeName = newNode.(*TypeName)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.ColExpr, func(newNode, parent Node) {
		parent.(*RangeTableFuncCol).ColExpr = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.ColDefExpr, func(newNode, parent Node) {
		parent.(*RangeTableFuncCol).ColDefExpr = newNode.(Node)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfRangeTableSample(parent Node, node *RangeTableSample, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteNode(node, node.Relation, func(newNode, parent Node) {
		parent.(*RangeTableSample).Relation = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Method, func(newNode, parent Node) {
		parent.(*RangeTableSample).Method = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Args, func(newNode, parent Node) {
		parent.(*RangeTableSample).Args = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.Repeatable, func(newNode, parent Node) {
		parent.(*RangeTableSample).Repeatable = newNode.(Node)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfRangeTblEntry(parent Node, node *RangeTblEntry, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfAlias(node, node.Alias, func(newNode, parent Node) {
		parent.(*RangeTblEntry).Alias = newNode.(*Alias)
	}) {
		return false
	}
	if !a.rewriteRefOfAlias(node, node.Eref, func(newNode, parent Node) {
		parent.(*RangeTblEntry).Eref = newNode.(*Alias)
	}) {
		return false
	}
	if !a.rewriteRefOfTableSampleClause(node, node.TableSample, func(newNode, parent Node) {
		parent.(*RangeTblEntry).TableSample = newNode.(*TableSampleClause)
	}) {
		return false
	}
	if !a.rewriteRefOfQuery(node, node.Subquery, func(newNode, parent Node) {
		parent.(*RangeTblEntry).Subquery = newNode.(*Query)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.JoinAliasVars, func(newNode, parent Node) {
		parent.(*RangeTblEntry).JoinAliasVars = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfAlias(node, node.JoinUsingAlias, func(newNode, parent Node) {
		parent.(*RangeTblEntry).JoinUsingAlias = newNode.(*Alias)
	}) {
		return false
	}
	for x, el := range node.Functions {
		if !a.rewriteRefOfRangeTblFunction(node, el, func(idx int) replacerFunc {
			return func(newNode, parent Node) {
				parent.(*RangeTblEntry).Functions[x] = newNode.(*RangeTblFunction)
			}
		}(x)) {
			return false
		}
	}
	if !a.rewriteRefOfTableFunc(node, node.TableFunc, func(newNode, parent Node) {
		parent.(*RangeTblEntry).TableFunc = newNode.(*TableFunc)
	}) {
		return false
	}
	for x, el := range node.ValuesLists {
		if !a.rewriteRefOfNodeList(node, el, func(idx int) replacerFunc {
			return func(newNode, parent Node) {
				parent.(*RangeTblEntry).ValuesLists[x] = newNode.(*NodeList)
			}
		}(x)) {
			return false
		}
	}
	if !a.rewriteRefOfNodeList(node, node.SecurityQuals, func(newNode, parent Node) {
		parent.(*RangeTblEntry).SecurityQuals = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfRangeTblFunction(parent Node, node *RangeTblFunction, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteNode(node, node.FuncExpr, func(newNode, parent Node) {
		parent.(*RangeTblFunction).FuncExpr = newNode.(Node)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfRangeTblRef(parent Node, node *RangeTblRef, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfRangeVar(parent Node, node *RangeVar, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfAlias(node, node.Alias, func(newNode, parent Node) {
		parent.(*RangeVar).Alias = newNode.(*Alias)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfRawStmt(parent Node, node *RawStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteStmt(node, node.Stmt, func(newNode, parent Node) {
		parent.(*RawStmt).Stmt = newNode.(Stmt)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfReassignOwnedStmt(parent Node, node *ReassignOwnedStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Roles, func(newNode, parent Node) {
		parent.(*ReassignOwnedStmt).Roles = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfRoleSpec(node, node.Newrole, func(newNode, parent Node) {
		parent.(*ReassignOwnedStmt).Newrole = newNode.(*RoleSpec)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfRefreshMatViewStmt(parent Node, node *RefreshMatViewStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfRangeVar(node, node.Relation, func(newNode, parent Node) {
		parent.(*RefreshMatViewStmt).Relation = newNode.(*RangeVar)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfReindexStmt(parent Node, node *ReindexStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfRangeVar(node, node.Relation, func(newNode, parent Node) {
		parent.(*ReindexStmt).Relation = newNode.(*RangeVar)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Params, func(newNode, parent Node) {
		parent.(*ReindexStmt).Params = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfRelabelType(parent Node, node *RelabelType, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteExpression(node, node.Arg, func(newNode, parent Node) {
		parent.(*RelabelType).Arg = newNode.(Expression)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfRenameStmt(parent Node, node *RenameStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfRangeVar(node, node.Relation, func(newNode, parent Node) {
		parent.(*RenameStmt).Relation = newNode.(*RangeVar)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.Object, func(newNode, parent Node) {
		parent.(*RenameStmt).Object = newNode.(Node)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfReplicaIdentityStmt(parent Node, node *ReplicaIdentityStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfResTarget(parent Node, node *ResTarget, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Indirection, func(newNode, parent Node) {
		parent.(*ResTarget).Indirection = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.Val, func(newNode, parent Node) {
		parent.(*ResTarget).Val = newNode.(Node)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfReturnStmt(parent Node, node *ReturnStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteNode(node, node.ReturnVal, func(newNode, parent Node) {
		parent.(*ReturnStmt).ReturnVal = newNode.(Node)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfRoleSpec(parent Node, node *RoleSpec, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: StructMethod
func (a *application) rewriteRootNode(parent Node, node RootNode, replacer replacerFunc) bool {
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteNode(node, node.Node, func(newNode, parent Node) {
		panic("[BUG] tried to replace 'Node' on 'RootNode'")
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfRowCompareExpr(parent Node, node *RowCompareExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	for x, el := range node.Largs {
		if !a.rewriteExpression(node, el, func(idx int) replacerFunc {
			return func(newNode, parent Node) {
				parent.(*RowCompareExpr).Largs[x] = newNode.(Expression)
			}
		}(x)) {
			return false
		}
	}
	for x, el := range node.Rargs {
		if !a.rewriteExpression(node, el, func(idx int) replacerFunc {
			return func(newNode, parent Node) {
				parent.(*RowCompareExpr).Rargs[x] = newNode.(Expression)
			}
		}(x)) {
			return false
		}
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfRowExpr(parent Node, node *RowExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Args, func(newNode, parent Node) {
		parent.(*RowExpr).Args = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfRowMarkClause(parent Node, node *RowMarkClause, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfRuleStmt(parent Node, node *RuleStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfRangeVar(node, node.Relation, func(newNode, parent Node) {
		parent.(*RuleStmt).Relation = newNode.(*RangeVar)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.WhereClause, func(newNode, parent Node) {
		parent.(*RuleStmt).WhereClause = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Actions, func(newNode, parent Node) {
		parent.(*RuleStmt).Actions = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfSQLValueFunction(parent Node, node *SQLValueFunction, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfScalarArrayOpExpr(parent Node, node *ScalarArrayOpExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Args, func(newNode, parent Node) {
		parent.(*ScalarArrayOpExpr).Args = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfSecLabelStmt(parent Node, node *SecLabelStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteNode(node, node.Object, func(newNode, parent Node) {
		parent.(*SecLabelStmt).Object = newNode.(Node)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfSelectStmt(parent Node, node *SelectStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.DistinctClause, func(newNode, parent Node) {
		parent.(*SelectStmt).DistinctClause = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfIntoClause(node, node.IntoClause, func(newNode, parent Node) {
		parent.(*SelectStmt).IntoClause = newNode.(*IntoClause)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.TargetList, func(newNode, parent Node) {
		parent.(*SelectStmt).TargetList = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.FromClause, func(newNode, parent Node) {
		parent.(*SelectStmt).FromClause = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.WhereClause, func(newNode, parent Node) {
		parent.(*SelectStmt).WhereClause = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.GroupClause, func(newNode, parent Node) {
		parent.(*SelectStmt).GroupClause = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.HavingClause, func(newNode, parent Node) {
		parent.(*SelectStmt).HavingClause = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.WindowClause, func(newNode, parent Node) {
		parent.(*SelectStmt).WindowClause = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.ValuesLists, func(newNode, parent Node) {
		parent.(*SelectStmt).ValuesLists = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.SortClause, func(newNode, parent Node) {
		parent.(*SelectStmt).SortClause = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.LimitOffset, func(newNode, parent Node) {
		parent.(*SelectStmt).LimitOffset = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.LimitCount, func(newNode, parent Node) {
		parent.(*SelectStmt).LimitCount = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.LockingClause, func(newNode, parent Node) {
		parent.(*SelectStmt).LockingClause = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfWithClause(node, node.WithClause, func(newNode, parent Node) {
		parent.(*SelectStmt).WithClause = newNode.(*WithClause)
	}) {
		return false
	}
	if !a.rewriteRefOfSelectStmt(node, node.Larg, func(newNode, parent Node) {
		parent.(*SelectStmt).Larg = newNode.(*SelectStmt)
	}) {
		return false
	}
	if !a.rewriteRefOfSelectStmt(node, node.Rarg, func(newNode, parent Node) {
		parent.(*SelectStmt).Rarg = newNode.(*SelectStmt)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfSetOperationStmt(parent Node, node *SetOperationStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteNode(node, node.Larg, func(newNode, parent Node) {
		parent.(*SetOperationStmt).Larg = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.Rarg, func(newNode, parent Node) {
		parent.(*SetOperationStmt).Rarg = newNode.(Node)
	}) {
		return false
	}
	for x, el := range node.GroupClauses {
		if !a.rewriteRefOfSortGroupClause(node, el, func(idx int) replacerFunc {
			return func(newNode, parent Node) {
				parent.(*SetOperationStmt).GroupClauses[x] = newNode.(*SortGroupClause)
			}
		}(x)) {
			return false
		}
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfSetToDefault(parent Node, node *SetToDefault, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfSinglePartitionSpec(parent Node, node *SinglePartitionSpec, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfSortBy(parent Node, node *SortBy, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteNode(node, node.Node, func(newNode, parent Node) {
		parent.(*SortBy).Node = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.UseOp, func(newNode, parent Node) {
		parent.(*SortBy).UseOp = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfSortGroupClause(parent Node, node *SortGroupClause, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfStatsElem(parent Node, node *StatsElem, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteNode(node, node.Expr, func(newNode, parent Node) {
		parent.(*StatsElem).Expr = newNode.(Node)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfString(parent Node, node *String, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfSubLink(parent Node, node *SubLink, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteNode(node, node.Testexpr, func(newNode, parent Node) {
		parent.(*SubLink).Testexpr = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.OperName, func(newNode, parent Node) {
		parent.(*SubLink).OperName = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.Subselect, func(newNode, parent Node) {
		parent.(*SubLink).Subselect = newNode.(Node)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfSubPlan(parent Node, node *SubPlan, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteExpression(node, node.Testexpr, func(newNode, parent Node) {
		parent.(*SubPlan).Testexpr = newNode.(Expression)
	}) {
		return false
	}
	for x, el := range node.Args {
		if !a.rewriteExpression(node, el, func(idx int) replacerFunc {
			return func(newNode, parent Node) {
				parent.(*SubPlan).Args[x] = newNode.(Expression)
			}
		}(x)) {
			return false
		}
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfSubscriptingRef(parent Node, node *SubscriptingRef, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	for x, el := range node.Refupperindexpr {
		if !a.rewriteExpression(node, el, func(idx int) replacerFunc {
			return func(newNode, parent Node) {
				parent.(*SubscriptingRef).Refupperindexpr[x] = newNode.(Expression)
			}
		}(x)) {
			return false
		}
	}
	for x, el := range node.Reflowerindexpr {
		if !a.rewriteExpression(node, el, func(idx int) replacerFunc {
			return func(newNode, parent Node) {
				parent.(*SubscriptingRef).Reflowerindexpr[x] = newNode.(Expression)
			}
		}(x)) {
			return false
		}
	}
	if !a.rewriteExpression(node, node.Refexpr, func(newNode, parent Node) {
		parent.(*SubscriptingRef).Refexpr = newNode.(Expression)
	}) {
		return false
	}
	if !a.rewriteExpression(node, node.Refassgnexpr, func(newNode, parent Node) {
		parent.(*SubscriptingRef).Refassgnexpr = newNode.(Expression)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfTableFunc(parent Node, node *TableFunc, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	for x, el := range node.NsUris {
		if !a.rewriteExpression(node, el, func(idx int) replacerFunc {
			return func(newNode, parent Node) {
				parent.(*TableFunc).NsUris[x] = newNode.(Expression)
			}
		}(x)) {
			return false
		}
	}
	if !a.rewriteExpression(node, node.Docexpr, func(newNode, parent Node) {
		parent.(*TableFunc).Docexpr = newNode.(Expression)
	}) {
		return false
	}
	if !a.rewriteExpression(node, node.Rowexpr, func(newNode, parent Node) {
		parent.(*TableFunc).Rowexpr = newNode.(Expression)
	}) {
		return false
	}
	for x, el := range node.Colexprs {
		if !a.rewriteExpression(node, el, func(idx int) replacerFunc {
			return func(newNode, parent Node) {
				parent.(*TableFunc).Colexprs[x] = newNode.(Expression)
			}
		}(x)) {
			return false
		}
	}
	for x, el := range node.Coldefexprs {
		if !a.rewriteExpression(node, el, func(idx int) replacerFunc {
			return func(newNode, parent Node) {
				parent.(*TableFunc).Coldefexprs[x] = newNode.(Expression)
			}
		}(x)) {
			return false
		}
	}
	for x, el := range node.Colvalexprs {
		if !a.rewriteExpression(node, el, func(idx int) replacerFunc {
			return func(newNode, parent Node) {
				parent.(*TableFunc).Colvalexprs[x] = newNode.(Expression)
			}
		}(x)) {
			return false
		}
	}
	for x, el := range node.Passingvalexprs {
		if !a.rewriteExpression(node, el, func(idx int) replacerFunc {
			return func(newNode, parent Node) {
				parent.(*TableFunc).Passingvalexprs[x] = newNode.(Expression)
			}
		}(x)) {
			return false
		}
	}
	if !a.rewriteNode(node, node.Plan, func(newNode, parent Node) {
		parent.(*TableFunc).Plan = newNode.(Node)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfTableLikeClause(parent Node, node *TableLikeClause, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfRangeVar(node, node.Relation, func(newNode, parent Node) {
		parent.(*TableLikeClause).Relation = newNode.(*RangeVar)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfTableSampleClause(parent Node, node *TableSampleClause, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Args, func(newNode, parent Node) {
		parent.(*TableSampleClause).Args = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteExpr(node, node.Repeatable, func(newNode, parent Node) {
		parent.(*TableSampleClause).Repeatable = newNode.(Expr)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfTargetEntry(parent Node, node *TargetEntry, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteExpression(node, node.Expr, func(newNode, parent Node) {
		parent.(*TargetEntry).Expr = newNode.(Expression)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfTransactionStmt(parent Node, node *TransactionStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Options, func(newNode, parent Node) {
		parent.(*TransactionStmt).Options = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfTriggerTransition(parent Node, node *TriggerTransition, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfTruncateStmt(parent Node, node *TruncateStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Relations, func(newNode, parent Node) {
		parent.(*TruncateStmt).Relations = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfTypeCast(parent Node, node *TypeCast, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteNode(node, node.Arg, func(newNode, parent Node) {
		parent.(*TypeCast).Arg = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteRefOfTypeName(node, node.TypeName, func(newNode, parent Node) {
		parent.(*TypeCast).TypeName = newNode.(*TypeName)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfTypeName(parent Node, node *TypeName, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Names, func(newNode, parent Node) {
		parent.(*TypeName).Names = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Typmods, func(newNode, parent Node) {
		parent.(*TypeName).Typmods = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.ArrayBounds, func(newNode, parent Node) {
		parent.(*TypeName).ArrayBounds = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfUnlistenStmt(parent Node, node *UnlistenStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfUpdateStmt(parent Node, node *UpdateStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfRangeVar(node, node.Relation, func(newNode, parent Node) {
		parent.(*UpdateStmt).Relation = newNode.(*RangeVar)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.TargetList, func(newNode, parent Node) {
		parent.(*UpdateStmt).TargetList = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.WhereClause, func(newNode, parent Node) {
		parent.(*UpdateStmt).WhereClause = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.FromClause, func(newNode, parent Node) {
		parent.(*UpdateStmt).FromClause = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.ReturningList, func(newNode, parent Node) {
		parent.(*UpdateStmt).ReturningList = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfWithClause(node, node.WithClause, func(newNode, parent Node) {
		parent.(*UpdateStmt).WithClause = newNode.(*WithClause)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfVacuumRelation(parent Node, node *VacuumRelation, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfRangeVar(node, node.Relation, func(newNode, parent Node) {
		parent.(*VacuumRelation).Relation = newNode.(*RangeVar)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.VaCols, func(newNode, parent Node) {
		parent.(*VacuumRelation).VaCols = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfVacuumStmt(parent Node, node *VacuumStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Options, func(newNode, parent Node) {
		parent.(*VacuumStmt).Options = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Rels, func(newNode, parent Node) {
		parent.(*VacuumStmt).Rels = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfVar(parent Node, node *Var, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfVariableSetStmt(parent Node, node *VariableSetStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Args, func(newNode, parent Node) {
		parent.(*VariableSetStmt).Args = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfVariableShowStmt(parent Node, node *VariableShowStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if a.post != nil {
		if a.pre == nil {
			a.cur.replacer = replacer
			a.cur.parent = parent
			a.cur.node = node
		}
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfViewStmt(parent Node, node *ViewStmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfRangeVar(node, node.View, func(newNode, parent Node) {
		parent.(*ViewStmt).View = newNode.(*RangeVar)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Aliases, func(newNode, parent Node) {
		parent.(*ViewStmt).Aliases = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.Query, func(newNode, parent Node) {
		parent.(*ViewStmt).Query = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Options, func(newNode, parent Node) {
		parent.(*ViewStmt).Options = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfWindowClause(parent Node, node *WindowClause, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.PartitionClause, func(newNode, parent Node) {
		parent.(*WindowClause).PartitionClause = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.OrderClause, func(newNode, parent Node) {
		parent.(*WindowClause).OrderClause = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.StartOffset, func(newNode, parent Node) {
		parent.(*WindowClause).StartOffset = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.EndOffset, func(newNode, parent Node) {
		parent.(*WindowClause).EndOffset = newNode.(Node)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfWindowDef(parent Node, node *WindowDef, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.PartitionClause, func(newNode, parent Node) {
		parent.(*WindowDef).PartitionClause = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.OrderClause, func(newNode, parent Node) {
		parent.(*WindowDef).OrderClause = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.StartOffset, func(newNode, parent Node) {
		parent.(*WindowDef).StartOffset = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.EndOffset, func(newNode, parent Node) {
		parent.(*WindowDef).EndOffset = newNode.(Node)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfWindowFunc(parent Node, node *WindowFunc, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Args, func(newNode, parent Node) {
		parent.(*WindowFunc).Args = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteNode(node, node.Aggfilter, func(newNode, parent Node) {
		parent.(*WindowFunc).Aggfilter = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.RunCondition, func(newNode, parent Node) {
		parent.(*WindowFunc).RunCondition = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfWindowFuncRunCondition(parent Node, node *WindowFuncRunCondition, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteExpression(node, node.Arg, func(newNode, parent Node) {
		parent.(*WindowFuncRunCondition).Arg = newNode.(Expression)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfWithCheckOption(parent Node, node *WithCheckOption, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteNode(node, node.Qual, func(newNode, parent Node) {
		parent.(*WithCheckOption).Qual = newNode.(Node)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfWithClause(parent Node, node *WithClause, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.Ctes, func(newNode, parent Node) {
		parent.(*WithClause).Ctes = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfXmlExpr(parent Node, node *XmlExpr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteRefOfNodeList(node, node.NamedArgs, func(newNode, parent Node) {
		parent.(*XmlExpr).NamedArgs = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.ArgNames, func(newNode, parent Node) {
		parent.(*XmlExpr).ArgNames = newNode.(*NodeList)
	}) {
		return false
	}
	if !a.rewriteRefOfNodeList(node, node.Args, func(newNode, parent Node) {
		parent.(*XmlExpr).Args = newNode.(*NodeList)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: PtrToStructMethod
func (a *application) rewriteRefOfXmlSerialize(parent Node, node *XmlSerialize, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	if a.pre != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		kontinue := !a.pre(&a.cur)
		if a.cur.revisit {
			a.cur.revisit = false
			return a.rewriteNode(parent, a.cur.node, replacer)
		}
		if kontinue {
			return true
		}
	}
	if !a.rewriteNode(node, node.Expr, func(newNode, parent Node) {
		parent.(*XmlSerialize).Expr = newNode.(Node)
	}) {
		return false
	}
	if !a.rewriteRefOfTypeName(node, node.TypeName, func(newNode, parent Node) {
		parent.(*XmlSerialize).TypeName = newNode.(*TypeName)
	}) {
		return false
	}
	if a.post != nil {
		a.cur.replacer = replacer
		a.cur.parent = parent
		a.cur.node = node
		if !a.post(&a.cur) {
			return false
		}
	}
	return true
}

// Function Generation Source: InterfaceMethod
func (a *application) rewriteValue(parent Node, node Value, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	switch node := node.(type) {
	case *BitString:
		return a.rewriteRefOfBitString(parent, node, replacer)
	case *Boolean:
		return a.rewriteRefOfBoolean(parent, node, replacer)
	case *Float:
		return a.rewriteRefOfFloat(parent, node, replacer)
	case *Integer:
		return a.rewriteRefOfInteger(parent, node, replacer)
	case *Null:
		return a.rewriteRefOfNull(parent, node, replacer)
	case *String:
		return a.rewriteRefOfString(parent, node, replacer)
	default:
		// this should never happen
		return true
	}
}

// Function Generation Source: InterfaceMethod
func (a *application) rewriteExpression(parent Node, node Expression, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	switch node := node.(type) {
	case *A_ArrayExpr:
		return a.rewriteRefOfA_ArrayExpr(parent, node, replacer)
	case *A_Const:
		return a.rewriteRefOfA_Const(parent, node, replacer)
	case *A_Expr:
		return a.rewriteRefOfA_Expr(parent, node, replacer)
	case *A_Indices:
		return a.rewriteRefOfA_Indices(parent, node, replacer)
	case *A_Indirection:
		return a.rewriteRefOfA_Indirection(parent, node, replacer)
	case *A_Star:
		return a.rewriteRefOfA_Star(parent, node, replacer)
	case *Aggref:
		return a.rewriteRefOfAggref(parent, node, replacer)
	case *AlternativeSubPlan:
		return a.rewriteRefOfAlternativeSubPlan(parent, node, replacer)
	case *ArrayCoerceExpr:
		return a.rewriteRefOfArrayCoerceExpr(parent, node, replacer)
	case *ArrayExpr:
		return a.rewriteRefOfArrayExpr(parent, node, replacer)
	case *BitString:
		return a.rewriteRefOfBitString(parent, node, replacer)
	case *BoolExpr:
		return a.rewriteRefOfBoolExpr(parent, node, replacer)
	case *Boolean:
		return a.rewriteRefOfBoolean(parent, node, replacer)
	case *BooleanTest:
		return a.rewriteRefOfBooleanTest(parent, node, replacer)
	case *CaseExpr:
		return a.rewriteRefOfCaseExpr(parent, node, replacer)
	case *CaseTestExpr:
		return a.rewriteRefOfCaseTestExpr(parent, node, replacer)
	case *CaseWhen:
		return a.rewriteRefOfCaseWhen(parent, node, replacer)
	case *CoalesceExpr:
		return a.rewriteRefOfCoalesceExpr(parent, node, replacer)
	case *CoerceToDomain:
		return a.rewriteRefOfCoerceToDomain(parent, node, replacer)
	case *CoerceToDomainValue:
		return a.rewriteRefOfCoerceToDomainValue(parent, node, replacer)
	case *CoerceViaIO:
		return a.rewriteRefOfCoerceViaIO(parent, node, replacer)
	case *CollateExpr:
		return a.rewriteRefOfCollateExpr(parent, node, replacer)
	case *ColumnRef:
		return a.rewriteRefOfColumnRef(parent, node, replacer)
	case *Const:
		return a.rewriteRefOfConst(parent, node, replacer)
	case *ConvertRowtypeExpr:
		return a.rewriteRefOfConvertRowtypeExpr(parent, node, replacer)
	case *CurrentOfExpr:
		return a.rewriteRefOfCurrentOfExpr(parent, node, replacer)
	case *FieldSelect:
		return a.rewriteRefOfFieldSelect(parent, node, replacer)
	case *FieldStore:
		return a.rewriteRefOfFieldStore(parent, node, replacer)
	case *Float:
		return a.rewriteRefOfFloat(parent, node, replacer)
	case *FromExpr:
		return a.rewriteRefOfFromExpr(parent, node, replacer)
	case *FuncCall:
		return a.rewriteRefOfFuncCall(parent, node, replacer)
	case *FuncExpr:
		return a.rewriteRefOfFuncExpr(parent, node, replacer)
	case *GroupingFunc:
		return a.rewriteRefOfGroupingFunc(parent, node, replacer)
	case *Identifier:
		return a.rewriteRefOfIdentifier(parent, node, replacer)
	case *InferenceElem:
		return a.rewriteRefOfInferenceElem(parent, node, replacer)
	case *Integer:
		return a.rewriteRefOfInteger(parent, node, replacer)
	case *JoinExpr:
		return a.rewriteRefOfJoinExpr(parent, node, replacer)
	case *JsonArrayAgg:
		return a.rewriteRefOfJsonArrayAgg(parent, node, replacer)
	case *JsonArrayConstructor:
		return a.rewriteRefOfJsonArrayConstructor(parent, node, replacer)
	case *JsonArrayQueryConstructor:
		return a.rewriteRefOfJsonArrayQueryConstructor(parent, node, replacer)
	case *JsonConstructorExpr:
		return a.rewriteRefOfJsonConstructorExpr(parent, node, replacer)
	case *JsonExpr:
		return a.rewriteRefOfJsonExpr(parent, node, replacer)
	case *JsonFuncExpr:
		return a.rewriteRefOfJsonFuncExpr(parent, node, replacer)
	case *JsonObjectAgg:
		return a.rewriteRefOfJsonObjectAgg(parent, node, replacer)
	case *JsonObjectConstructor:
		return a.rewriteRefOfJsonObjectConstructor(parent, node, replacer)
	case *JsonParseExpr:
		return a.rewriteRefOfJsonParseExpr(parent, node, replacer)
	case *JsonScalarExpr:
		return a.rewriteRefOfJsonScalarExpr(parent, node, replacer)
	case *JsonSerializeExpr:
		return a.rewriteRefOfJsonSerializeExpr(parent, node, replacer)
	case *JsonValueExpr:
		return a.rewriteRefOfJsonValueExpr(parent, node, replacer)
	case *MergeSupportFunc:
		return a.rewriteRefOfMergeSupportFunc(parent, node, replacer)
	case *MinMaxExpr:
		return a.rewriteRefOfMinMaxExpr(parent, node, replacer)
	case *MultiAssignRef:
		return a.rewriteRefOfMultiAssignRef(parent, node, replacer)
	case *NamedArgExpr:
		return a.rewriteRefOfNamedArgExpr(parent, node, replacer)
	case *NextValueExpr:
		return a.rewriteRefOfNextValueExpr(parent, node, replacer)
	case *Null:
		return a.rewriteRefOfNull(parent, node, replacer)
	case *NullTest:
		return a.rewriteRefOfNullTest(parent, node, replacer)
	case *OnConflictExpr:
		return a.rewriteRefOfOnConflictExpr(parent, node, replacer)
	case *OpExpr:
		return a.rewriteRefOfOpExpr(parent, node, replacer)
	case *Param:
		return a.rewriteRefOfParam(parent, node, replacer)
	case *ParamRef:
		return a.rewriteRefOfParamRef(parent, node, replacer)
	case *ParenExpr:
		return a.rewriteRefOfParenExpr(parent, node, replacer)
	case *RangeTblRef:
		return a.rewriteRefOfRangeTblRef(parent, node, replacer)
	case *RelabelType:
		return a.rewriteRefOfRelabelType(parent, node, replacer)
	case *ResTarget:
		return a.rewriteRefOfResTarget(parent, node, replacer)
	case *RowCompareExpr:
		return a.rewriteRefOfRowCompareExpr(parent, node, replacer)
	case *RowExpr:
		return a.rewriteRefOfRowExpr(parent, node, replacer)
	case *SQLValueFunction:
		return a.rewriteRefOfSQLValueFunction(parent, node, replacer)
	case *ScalarArrayOpExpr:
		return a.rewriteRefOfScalarArrayOpExpr(parent, node, replacer)
	case *SetToDefault:
		return a.rewriteRefOfSetToDefault(parent, node, replacer)
	case *String:
		return a.rewriteRefOfString(parent, node, replacer)
	case *SubLink:
		return a.rewriteRefOfSubLink(parent, node, replacer)
	case *SubPlan:
		return a.rewriteRefOfSubPlan(parent, node, replacer)
	case *SubscriptingRef:
		return a.rewriteRefOfSubscriptingRef(parent, node, replacer)
	case *TargetEntry:
		return a.rewriteRefOfTargetEntry(parent, node, replacer)
	case *TypeCast:
		return a.rewriteRefOfTypeCast(parent, node, replacer)
	case *Var:
		return a.rewriteRefOfVar(parent, node, replacer)
	case *WindowFunc:
		return a.rewriteRefOfWindowFunc(parent, node, replacer)
	case *WindowFuncRunCondition:
		return a.rewriteRefOfWindowFuncRunCondition(parent, node, replacer)
	case *WithClause:
		return a.rewriteRefOfWithClause(parent, node, replacer)
	case *XmlExpr:
		return a.rewriteRefOfXmlExpr(parent, node, replacer)
	case *XmlSerialize:
		return a.rewriteRefOfXmlSerialize(parent, node, replacer)
	default:
		// this should never happen
		return true
	}
}

// Function Generation Source: InterfaceMethod
func (a *application) rewriteExpr(parent Node, node Expr, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	switch node := node.(type) {
	case *A_ArrayExpr:
		return a.rewriteRefOfA_ArrayExpr(parent, node, replacer)
	case *A_Const:
		return a.rewriteRefOfA_Const(parent, node, replacer)
	case *A_Expr:
		return a.rewriteRefOfA_Expr(parent, node, replacer)
	case *A_Indices:
		return a.rewriteRefOfA_Indices(parent, node, replacer)
	case *A_Indirection:
		return a.rewriteRefOfA_Indirection(parent, node, replacer)
	case *A_Star:
		return a.rewriteRefOfA_Star(parent, node, replacer)
	case *Aggref:
		return a.rewriteRefOfAggref(parent, node, replacer)
	case *AlternativeSubPlan:
		return a.rewriteRefOfAlternativeSubPlan(parent, node, replacer)
	case *ArrayCoerceExpr:
		return a.rewriteRefOfArrayCoerceExpr(parent, node, replacer)
	case *ArrayExpr:
		return a.rewriteRefOfArrayExpr(parent, node, replacer)
	case *BoolExpr:
		return a.rewriteRefOfBoolExpr(parent, node, replacer)
	case *BooleanTest:
		return a.rewriteRefOfBooleanTest(parent, node, replacer)
	case *CaseExpr:
		return a.rewriteRefOfCaseExpr(parent, node, replacer)
	case *CaseTestExpr:
		return a.rewriteRefOfCaseTestExpr(parent, node, replacer)
	case *CaseWhen:
		return a.rewriteRefOfCaseWhen(parent, node, replacer)
	case *CoalesceExpr:
		return a.rewriteRefOfCoalesceExpr(parent, node, replacer)
	case *CoerceToDomain:
		return a.rewriteRefOfCoerceToDomain(parent, node, replacer)
	case *CoerceToDomainValue:
		return a.rewriteRefOfCoerceToDomainValue(parent, node, replacer)
	case *CoerceViaIO:
		return a.rewriteRefOfCoerceViaIO(parent, node, replacer)
	case *CollateExpr:
		return a.rewriteRefOfCollateExpr(parent, node, replacer)
	case *ColumnRef:
		return a.rewriteRefOfColumnRef(parent, node, replacer)
	case *Const:
		return a.rewriteRefOfConst(parent, node, replacer)
	case *ConvertRowtypeExpr:
		return a.rewriteRefOfConvertRowtypeExpr(parent, node, replacer)
	case *CurrentOfExpr:
		return a.rewriteRefOfCurrentOfExpr(parent, node, replacer)
	case *FieldSelect:
		return a.rewriteRefOfFieldSelect(parent, node, replacer)
	case *FieldStore:
		return a.rewriteRefOfFieldStore(parent, node, replacer)
	case *FromExpr:
		return a.rewriteRefOfFromExpr(parent, node, replacer)
	case *FuncCall:
		return a.rewriteRefOfFuncCall(parent, node, replacer)
	case *FuncExpr:
		return a.rewriteRefOfFuncExpr(parent, node, replacer)
	case *GroupingFunc:
		return a.rewriteRefOfGroupingFunc(parent, node, replacer)
	case *InferenceElem:
		return a.rewriteRefOfInferenceElem(parent, node, replacer)
	case *JoinExpr:
		return a.rewriteRefOfJoinExpr(parent, node, replacer)
	case *JsonArrayAgg:
		return a.rewriteRefOfJsonArrayAgg(parent, node, replacer)
	case *JsonArrayConstructor:
		return a.rewriteRefOfJsonArrayConstructor(parent, node, replacer)
	case *JsonArrayQueryConstructor:
		return a.rewriteRefOfJsonArrayQueryConstructor(parent, node, replacer)
	case *JsonConstructorExpr:
		return a.rewriteRefOfJsonConstructorExpr(parent, node, replacer)
	case *JsonExpr:
		return a.rewriteRefOfJsonExpr(parent, node, replacer)
	case *JsonFuncExpr:
		return a.rewriteRefOfJsonFuncExpr(parent, node, replacer)
	case *JsonObjectAgg:
		return a.rewriteRefOfJsonObjectAgg(parent, node, replacer)
	case *JsonObjectConstructor:
		return a.rewriteRefOfJsonObjectConstructor(parent, node, replacer)
	case *JsonParseExpr:
		return a.rewriteRefOfJsonParseExpr(parent, node, replacer)
	case *JsonScalarExpr:
		return a.rewriteRefOfJsonScalarExpr(parent, node, replacer)
	case *JsonSerializeExpr:
		return a.rewriteRefOfJsonSerializeExpr(parent, node, replacer)
	case *JsonValueExpr:
		return a.rewriteRefOfJsonValueExpr(parent, node, replacer)
	case *MergeSupportFunc:
		return a.rewriteRefOfMergeSupportFunc(parent, node, replacer)
	case *MinMaxExpr:
		return a.rewriteRefOfMinMaxExpr(parent, node, replacer)
	case *MultiAssignRef:
		return a.rewriteRefOfMultiAssignRef(parent, node, replacer)
	case *NamedArgExpr:
		return a.rewriteRefOfNamedArgExpr(parent, node, replacer)
	case *NextValueExpr:
		return a.rewriteRefOfNextValueExpr(parent, node, replacer)
	case *NullTest:
		return a.rewriteRefOfNullTest(parent, node, replacer)
	case *OnConflictExpr:
		return a.rewriteRefOfOnConflictExpr(parent, node, replacer)
	case *OpExpr:
		return a.rewriteRefOfOpExpr(parent, node, replacer)
	case *Param:
		return a.rewriteRefOfParam(parent, node, replacer)
	case *ParamRef:
		return a.rewriteRefOfParamRef(parent, node, replacer)
	case *ParenExpr:
		return a.rewriteRefOfParenExpr(parent, node, replacer)
	case *RelabelType:
		return a.rewriteRefOfRelabelType(parent, node, replacer)
	case *RowCompareExpr:
		return a.rewriteRefOfRowCompareExpr(parent, node, replacer)
	case *RowExpr:
		return a.rewriteRefOfRowExpr(parent, node, replacer)
	case *SQLValueFunction:
		return a.rewriteRefOfSQLValueFunction(parent, node, replacer)
	case *ScalarArrayOpExpr:
		return a.rewriteRefOfScalarArrayOpExpr(parent, node, replacer)
	case *SetToDefault:
		return a.rewriteRefOfSetToDefault(parent, node, replacer)
	case *SubLink:
		return a.rewriteRefOfSubLink(parent, node, replacer)
	case *SubPlan:
		return a.rewriteRefOfSubPlan(parent, node, replacer)
	case *SubscriptingRef:
		return a.rewriteRefOfSubscriptingRef(parent, node, replacer)
	case *TargetEntry:
		return a.rewriteRefOfTargetEntry(parent, node, replacer)
	case *TypeCast:
		return a.rewriteRefOfTypeCast(parent, node, replacer)
	case *Var:
		return a.rewriteRefOfVar(parent, node, replacer)
	case *WindowFunc:
		return a.rewriteRefOfWindowFunc(parent, node, replacer)
	case *WindowFuncRunCondition:
		return a.rewriteRefOfWindowFuncRunCondition(parent, node, replacer)
	case *WithClause:
		return a.rewriteRefOfWithClause(parent, node, replacer)
	case *XmlExpr:
		return a.rewriteRefOfXmlExpr(parent, node, replacer)
	case *XmlSerialize:
		return a.rewriteRefOfXmlSerialize(parent, node, replacer)
	default:
		// this should never happen
		return true
	}
}

// Function Generation Source: InterfaceMethod
func (a *application) rewriteStmt(parent Node, node Stmt, replacer replacerFunc) bool {
	if node == nil {
		return true
	}
	switch node := node.(type) {
	case *AlterCollationStmt:
		return a.rewriteRefOfAlterCollationStmt(parent, node, replacer)
	case *AlterCompositeTypeStmt:
		return a.rewriteRefOfAlterCompositeTypeStmt(parent, node, replacer)
	case *AlterDatabaseRefreshCollStmt:
		return a.rewriteRefOfAlterDatabaseRefreshCollStmt(parent, node, replacer)
	case *AlterDatabaseSetStmt:
		return a.rewriteRefOfAlterDatabaseSetStmt(parent, node, replacer)
	case *AlterDatabaseStmt:
		return a.rewriteRefOfAlterDatabaseStmt(parent, node, replacer)
	case *AlterDefaultPrivilegesStmt:
		return a.rewriteRefOfAlterDefaultPrivilegesStmt(parent, node, replacer)
	case *AlterDomainStmt:
		return a.rewriteRefOfAlterDomainStmt(parent, node, replacer)
	case *AlterEnumStmt:
		return a.rewriteRefOfAlterEnumStmt(parent, node, replacer)
	case *AlterEventTrigStmt:
		return a.rewriteRefOfAlterEventTrigStmt(parent, node, replacer)
	case *AlterExtensionContentsStmt:
		return a.rewriteRefOfAlterExtensionContentsStmt(parent, node, replacer)
	case *AlterExtensionStmt:
		return a.rewriteRefOfAlterExtensionStmt(parent, node, replacer)
	case *AlterFdwStmt:
		return a.rewriteRefOfAlterFdwStmt(parent, node, replacer)
	case *AlterForeignServerStmt:
		return a.rewriteRefOfAlterForeignServerStmt(parent, node, replacer)
	case *AlterFunctionStmt:
		return a.rewriteRefOfAlterFunctionStmt(parent, node, replacer)
	case *AlterObjectDependsStmt:
		return a.rewriteRefOfAlterObjectDependsStmt(parent, node, replacer)
	case *AlterObjectSchemaStmt:
		return a.rewriteRefOfAlterObjectSchemaStmt(parent, node, replacer)
	case *AlterOpFamilyStmt:
		return a.rewriteRefOfAlterOpFamilyStmt(parent, node, replacer)
	case *AlterOperatorStmt:
		return a.rewriteRefOfAlterOperatorStmt(parent, node, replacer)
	case *AlterOwnerStmt:
		return a.rewriteRefOfAlterOwnerStmt(parent, node, replacer)
	case *AlterPolicyStmt:
		return a.rewriteRefOfAlterPolicyStmt(parent, node, replacer)
	case *AlterPublicationStmt:
		return a.rewriteRefOfAlterPublicationStmt(parent, node, replacer)
	case *AlterRoleSetStmt:
		return a.rewriteRefOfAlterRoleSetStmt(parent, node, replacer)
	case *AlterRoleStmt:
		return a.rewriteRefOfAlterRoleStmt(parent, node, replacer)
	case *AlterSeqStmt:
		return a.rewriteRefOfAlterSeqStmt(parent, node, replacer)
	case *AlterStatsStmt:
		return a.rewriteRefOfAlterStatsStmt(parent, node, replacer)
	case *AlterSubscriptionStmt:
		return a.rewriteRefOfAlterSubscriptionStmt(parent, node, replacer)
	case *AlterSystemStmt:
		return a.rewriteRefOfAlterSystemStmt(parent, node, replacer)
	case *AlterTSConfigurationStmt:
		return a.rewriteRefOfAlterTSConfigurationStmt(parent, node, replacer)
	case *AlterTSDictionaryStmt:
		return a.rewriteRefOfAlterTSDictionaryStmt(parent, node, replacer)
	case *AlterTableMoveAllStmt:
		return a.rewriteRefOfAlterTableMoveAllStmt(parent, node, replacer)
	case *AlterTableSpaceStmt:
		return a.rewriteRefOfAlterTableSpaceStmt(parent, node, replacer)
	case *AlterTableStmt:
		return a.rewriteRefOfAlterTableStmt(parent, node, replacer)
	case *AlterTypeStmt:
		return a.rewriteRefOfAlterTypeStmt(parent, node, replacer)
	case *AlterUserMappingStmt:
		return a.rewriteRefOfAlterUserMappingStmt(parent, node, replacer)
	case *CallStmt:
		return a.rewriteRefOfCallStmt(parent, node, replacer)
	case *CheckPointStmt:
		return a.rewriteRefOfCheckPointStmt(parent, node, replacer)
	case *ClosePortalStmt:
		return a.rewriteRefOfClosePortalStmt(parent, node, replacer)
	case *ClusterStmt:
		return a.rewriteRefOfClusterStmt(parent, node, replacer)
	case *ColumnDef:
		return a.rewriteRefOfColumnDef(parent, node, replacer)
	case *CommentStmt:
		return a.rewriteRefOfCommentStmt(parent, node, replacer)
	case *CompositeTypeStmt:
		return a.rewriteRefOfCompositeTypeStmt(parent, node, replacer)
	case *ConstraintsSetStmt:
		return a.rewriteRefOfConstraintsSetStmt(parent, node, replacer)
	case *CopyStmt:
		return a.rewriteRefOfCopyStmt(parent, node, replacer)
	case *CreateAmStmt:
		return a.rewriteRefOfCreateAmStmt(parent, node, replacer)
	case *CreateAssertionStmt:
		return a.rewriteRefOfCreateAssertionStmt(parent, node, replacer)
	case *CreateCastStmt:
		return a.rewriteRefOfCreateCastStmt(parent, node, replacer)
	case *CreateConversionStmt:
		return a.rewriteRefOfCreateConversionStmt(parent, node, replacer)
	case *CreateDomainStmt:
		return a.rewriteRefOfCreateDomainStmt(parent, node, replacer)
	case *CreateEnumStmt:
		return a.rewriteRefOfCreateEnumStmt(parent, node, replacer)
	case *CreateEventTrigStmt:
		return a.rewriteRefOfCreateEventTrigStmt(parent, node, replacer)
	case *CreateExtensionStmt:
		return a.rewriteRefOfCreateExtensionStmt(parent, node, replacer)
	case *CreateFdwStmt:
		return a.rewriteRefOfCreateFdwStmt(parent, node, replacer)
	case *CreateForeignServerStmt:
		return a.rewriteRefOfCreateForeignServerStmt(parent, node, replacer)
	case *CreateForeignTableStmt:
		return a.rewriteRefOfCreateForeignTableStmt(parent, node, replacer)
	case *CreateFunctionStmt:
		return a.rewriteRefOfCreateFunctionStmt(parent, node, replacer)
	case *CreateOpClassItem:
		return a.rewriteRefOfCreateOpClassItem(parent, node, replacer)
	case *CreateOpClassStmt:
		return a.rewriteRefOfCreateOpClassStmt(parent, node, replacer)
	case *CreateOpFamilyStmt:
		return a.rewriteRefOfCreateOpFamilyStmt(parent, node, replacer)
	case *CreatePLangStmt:
		return a.rewriteRefOfCreatePLangStmt(parent, node, replacer)
	case *CreatePolicyStmt:
		return a.rewriteRefOfCreatePolicyStmt(parent, node, replacer)
	case *CreatePublicationStmt:
		return a.rewriteRefOfCreatePublicationStmt(parent, node, replacer)
	case *CreateRangeStmt:
		return a.rewriteRefOfCreateRangeStmt(parent, node, replacer)
	case *CreateRoleStmt:
		return a.rewriteRefOfCreateRoleStmt(parent, node, replacer)
	case *CreateSchemaStmt:
		return a.rewriteRefOfCreateSchemaStmt(parent, node, replacer)
	case *CreateSeqStmt:
		return a.rewriteRefOfCreateSeqStmt(parent, node, replacer)
	case *CreateStatsStmt:
		return a.rewriteRefOfCreateStatsStmt(parent, node, replacer)
	case *CreateStmt:
		return a.rewriteRefOfCreateStmt(parent, node, replacer)
	case *CreateSubscriptionStmt:
		return a.rewriteRefOfCreateSubscriptionStmt(parent, node, replacer)
	case *CreateTableAsStmt:
		return a.rewriteRefOfCreateTableAsStmt(parent, node, replacer)
	case *CreateTableSpaceStmt:
		return a.rewriteRefOfCreateTableSpaceStmt(parent, node, replacer)
	case *CreateTransformStmt:
		return a.rewriteRefOfCreateTransformStmt(parent, node, replacer)
	case *CreateTriggerStmt:
		return a.rewriteRefOfCreateTriggerStmt(parent, node, replacer)
	case *CreateUserMappingStmt:
		return a.rewriteRefOfCreateUserMappingStmt(parent, node, replacer)
	case *CreatedbStmt:
		return a.rewriteRefOfCreatedbStmt(parent, node, replacer)
	case *DeallocateStmt:
		return a.rewriteRefOfDeallocateStmt(parent, node, replacer)
	case *DeclareCursorStmt:
		return a.rewriteRefOfDeclareCursorStmt(parent, node, replacer)
	case *DefineStmt:
		return a.rewriteRefOfDefineStmt(parent, node, replacer)
	case *DeleteStmt:
		return a.rewriteRefOfDeleteStmt(parent, node, replacer)
	case *DiscardStmt:
		return a.rewriteRefOfDiscardStmt(parent, node, replacer)
	case *DoStmt:
		return a.rewriteRefOfDoStmt(parent, node, replacer)
	case *DropOwnedStmt:
		return a.rewriteRefOfDropOwnedStmt(parent, node, replacer)
	case *DropRoleStmt:
		return a.rewriteRefOfDropRoleStmt(parent, node, replacer)
	case *DropStmt:
		return a.rewriteRefOfDropStmt(parent, node, replacer)
	case *DropTableSpaceStmt:
		return a.rewriteRefOfDropTableSpaceStmt(parent, node, replacer)
	case *DropUserMappingStmt:
		return a.rewriteRefOfDropUserMappingStmt(parent, node, replacer)
	case *DropdbStmt:
		return a.rewriteRefOfDropdbStmt(parent, node, replacer)
	case *ExecuteStmt:
		return a.rewriteRefOfExecuteStmt(parent, node, replacer)
	case *ExplainStmt:
		return a.rewriteRefOfExplainStmt(parent, node, replacer)
	case *FetchStmt:
		return a.rewriteRefOfFetchStmt(parent, node, replacer)
	case *GrantRoleStmt:
		return a.rewriteRefOfGrantRoleStmt(parent, node, replacer)
	case *GrantStmt:
		return a.rewriteRefOfGrantStmt(parent, node, replacer)
	case *GroupingSet:
		return a.rewriteRefOfGroupingSet(parent, node, replacer)
	case *ImportForeignSchemaStmt:
		return a.rewriteRefOfImportForeignSchemaStmt(parent, node, replacer)
	case *IndexStmt:
		return a.rewriteRefOfIndexStmt(parent, node, replacer)
	case *InsertStmt:
		return a.rewriteRefOfInsertStmt(parent, node, replacer)
	case *IntoClause:
		return a.rewriteRefOfIntoClause(parent, node, replacer)
	case *ListenStmt:
		return a.rewriteRefOfListenStmt(parent, node, replacer)
	case *LoadStmt:
		return a.rewriteRefOfLoadStmt(parent, node, replacer)
	case *LockStmt:
		return a.rewriteRefOfLockStmt(parent, node, replacer)
	case *LockingClause:
		return a.rewriteRefOfLockingClause(parent, node, replacer)
	case *MergeAction:
		return a.rewriteRefOfMergeAction(parent, node, replacer)
	case *MergeStmt:
		return a.rewriteRefOfMergeStmt(parent, node, replacer)
	case *NotifyStmt:
		return a.rewriteRefOfNotifyStmt(parent, node, replacer)
	case *ObjectWithArgs:
		return a.rewriteRefOfObjectWithArgs(parent, node, replacer)
	case *PLAssignStmt:
		return a.rewriteRefOfPLAssignStmt(parent, node, replacer)
	case *PartitionCmd:
		return a.rewriteRefOfPartitionCmd(parent, node, replacer)
	case *PartitionElem:
		return a.rewriteRefOfPartitionElem(parent, node, replacer)
	case *PrepareStmt:
		return a.rewriteRefOfPrepareStmt(parent, node, replacer)
	case *Query:
		return a.rewriteRefOfQuery(parent, node, replacer)
	case *RTEPermissionInfo:
		return a.rewriteRefOfRTEPermissionInfo(parent, node, replacer)
	case *RangeFunction:
		return a.rewriteRefOfRangeFunction(parent, node, replacer)
	case *RangeSubselect:
		return a.rewriteRefOfRangeSubselect(parent, node, replacer)
	case *RangeTableFunc:
		return a.rewriteRefOfRangeTableFunc(parent, node, replacer)
	case *RangeTableFuncCol:
		return a.rewriteRefOfRangeTableFuncCol(parent, node, replacer)
	case *RangeTableSample:
		return a.rewriteRefOfRangeTableSample(parent, node, replacer)
	case *RangeTblEntry:
		return a.rewriteRefOfRangeTblEntry(parent, node, replacer)
	case *RangeTblFunction:
		return a.rewriteRefOfRangeTblFunction(parent, node, replacer)
	case *RangeVar:
		return a.rewriteRefOfRangeVar(parent, node, replacer)
	case *RawStmt:
		return a.rewriteRefOfRawStmt(parent, node, replacer)
	case *ReassignOwnedStmt:
		return a.rewriteRefOfReassignOwnedStmt(parent, node, replacer)
	case *RefreshMatViewStmt:
		return a.rewriteRefOfRefreshMatViewStmt(parent, node, replacer)
	case *ReindexStmt:
		return a.rewriteRefOfReindexStmt(parent, node, replacer)
	case *RenameStmt:
		return a.rewriteRefOfRenameStmt(parent, node, replacer)
	case *ReplicaIdentityStmt:
		return a.rewriteRefOfReplicaIdentityStmt(parent, node, replacer)
	case *ReturnStmt:
		return a.rewriteRefOfReturnStmt(parent, node, replacer)
	case *RuleStmt:
		return a.rewriteRefOfRuleStmt(parent, node, replacer)
	case *SecLabelStmt:
		return a.rewriteRefOfSecLabelStmt(parent, node, replacer)
	case *SelectStmt:
		return a.rewriteRefOfSelectStmt(parent, node, replacer)
	case *SinglePartitionSpec:
		return a.rewriteRefOfSinglePartitionSpec(parent, node, replacer)
	case *SortBy:
		return a.rewriteRefOfSortBy(parent, node, replacer)
	case *TableFunc:
		return a.rewriteRefOfTableFunc(parent, node, replacer)
	case *TableSampleClause:
		return a.rewriteRefOfTableSampleClause(parent, node, replacer)
	case *TransactionStmt:
		return a.rewriteRefOfTransactionStmt(parent, node, replacer)
	case *TruncateStmt:
		return a.rewriteRefOfTruncateStmt(parent, node, replacer)
	case *UnlistenStmt:
		return a.rewriteRefOfUnlistenStmt(parent, node, replacer)
	case *UpdateStmt:
		return a.rewriteRefOfUpdateStmt(parent, node, replacer)
	case *VacuumStmt:
		return a.rewriteRefOfVacuumStmt(parent, node, replacer)
	case *VariableSetStmt:
		return a.rewriteRefOfVariableSetStmt(parent, node, replacer)
	case *VariableShowStmt:
		return a.rewriteRefOfVariableShowStmt(parent, node, replacer)
	case *ViewStmt:
		return a.rewriteRefOfViewStmt(parent, node, replacer)
	case *WindowDef:
		return a.rewriteRefOfWindowDef(parent, node, replacer)
	default:
		// this should never happen
		return true
	}
}
