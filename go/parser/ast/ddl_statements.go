// Package ast provides PostgreSQL DDL statement node definitions.
// Ported from postgres/src/include/nodes/parsenodes.h
package ast

import (
	"fmt"
	"strings"
)

// ==============================================================================
// DDL FRAMEWORK - PostgreSQL parsenodes.h DDL implementation
// Ported from postgres/src/include/nodes/parsenodes.h
// ==============================================================================

// Supporting enums and types for DDL statements

// ObjectType represents the type of database object - ported from postgres/src/include/nodes/parsenodes.h:2256-2310
type ObjectType int

const (
	OBJECT_ACCESS_METHOD ObjectType = iota
	OBJECT_AGGREGATE
	OBJECT_AMOP
	OBJECT_AMPROC
	OBJECT_ATTRIBUTE // type's attribute, when distinct from column
	OBJECT_CAST
	OBJECT_COLUMN
	OBJECT_COLLATION
	OBJECT_CONVERSION
	OBJECT_DATABASE
	OBJECT_DEFAULT
	OBJECT_DEFACL
	OBJECT_DOMAIN
	OBJECT_DOMCONSTRAINT
	OBJECT_EVENT_TRIGGER
	OBJECT_EXTENSION
	OBJECT_FDW
	OBJECT_FOREIGN_SERVER
	OBJECT_FOREIGN_TABLE
	OBJECT_FUNCTION
	OBJECT_INDEX
	OBJECT_LANGUAGE
	OBJECT_LARGEOBJECT
	OBJECT_MATVIEW
	OBJECT_OPCLASS
	OBJECT_OPERATOR
	OBJECT_OPFAMILY
	OBJECT_PARAMETER_ACL
	OBJECT_POLICY
	OBJECT_PROCEDURE
	OBJECT_PUBLICATION
	OBJECT_PUBLICATION_NAMESPACE
	OBJECT_PUBLICATION_REL
	OBJECT_ROLE
	OBJECT_ROUTINE
	OBJECT_RULE
	OBJECT_SCHEMA
	OBJECT_SEQUENCE
	OBJECT_SUBSCRIPTION
	OBJECT_STATISTIC_EXT
	OBJECT_TABCONSTRAINT
	OBJECT_TABLE
	OBJECT_TABLESPACE
	OBJECT_TRANSFORM
	OBJECT_TRIGGER
	OBJECT_TSCONFIGURATION
	OBJECT_TSDICTIONARY
	OBJECT_TSPARSER
	OBJECT_TSTEMPLATE
	OBJECT_TYPE
	OBJECT_USER_MAPPING
	OBJECT_VIEW
)

func (o ObjectType) String() string {
	switch o {
	case OBJECT_ACCESS_METHOD:
		return "ACCESS_METHOD"
	case OBJECT_AGGREGATE:
		return "AGGREGATE"
	case OBJECT_COLUMN:
		return "COLUMN"
	case OBJECT_DATABASE:
		return "DATABASE"
	case OBJECT_DOMAIN:
		return "DOMAIN"
	case OBJECT_EXTENSION:
		return "EXTENSION"
	case OBJECT_FUNCTION:
		return "FUNCTION"
	case OBJECT_INDEX:
		return "INDEX"
	case OBJECT_SCHEMA:
		return "SCHEMA"
	case OBJECT_SEQUENCE:
		return "SEQUENCE"
	case OBJECT_TABLE:
		return "TABLE"
	case OBJECT_VIEW:
		return "VIEW"
	default:
		return fmt.Sprintf("ObjectType(%d)", int(o))
	}
}

// DropBehavior represents CASCADE/RESTRICT behavior - ported from postgres/src/include/nodes/parsenodes.h:2329-2333
type DropBehavior int

const (
	DropRestrict DropBehavior = iota // drop fails if any dependent objects
	DropCascade                      // remove dependent objects too
)

func (d DropBehavior) String() string {
	switch d {
	case DropRestrict:
		return "RESTRICT"
	case DropCascade:
		return "CASCADE"
	default:
		return fmt.Sprintf("DropBehavior(%d)", int(d))
	}
}

// ConstrType represents types of constraints - ported from postgres/src/include/nodes/parsenodes.h:2697-2714
type ConstrType int

const (
	CONSTR_NULL ConstrType = iota // not standard SQL, but expected
	CONSTR_NOTNULL
	CONSTR_DEFAULT
	CONSTR_IDENTITY
	CONSTR_GENERATED
	CONSTR_CHECK
	CONSTR_PRIMARY
	CONSTR_UNIQUE
	CONSTR_EXCLUSION
	CONSTR_FOREIGN
	CONSTR_ATTR_DEFERRABLE // attributes for previous constraint node
	CONSTR_ATTR_NOT_DEFERRABLE
	CONSTR_ATTR_DEFERRED
	CONSTR_ATTR_IMMEDIATE
)

// Identity generation constants - ported from postgres/src/include/catalog/pg_attribute.h:233-234
const (
	ATTRIBUTE_IDENTITY_ALWAYS     byte = 'a' // GENERATED ALWAYS AS IDENTITY
	ATTRIBUTE_IDENTITY_BY_DEFAULT byte = 'd' // GENERATED BY DEFAULT AS IDENTITY
)

// Constraint Attribute Specification (CAS) bitmask constants
// Ported from postgres/src/include/parser/parse_node.h:46-52
const (
	CAS_NOT_DEFERRABLE      int = 0x01
	CAS_DEFERRABLE          int = 0x02
	CAS_INITIALLY_IMMEDIATE int = 0x04
	CAS_INITIALLY_DEFERRED  int = 0x08
	CAS_NOT_VALID           int = 0x10
	CAS_NO_INHERIT          int = 0x20
)

// Foreign Key Constraint Match Types
// Ported from postgres/src/include/nodes/parsenodes.h:2665-2667
const (
	FKCONSTR_MATCH_FULL    byte = 'f' // MATCH FULL
	FKCONSTR_MATCH_PARTIAL byte = 'p' // MATCH PARTIAL
	FKCONSTR_MATCH_SIMPLE  byte = 's' // MATCH SIMPLE (default)
)

// Replica Identity Types
// Ported from postgres/src/include/catalog/pg_class.h
const (
	REPLICA_IDENTITY_DEFAULT rune = 'd' // Use primary key
	REPLICA_IDENTITY_NOTHING rune = 'n' // No replica identity
	REPLICA_IDENTITY_FULL    rune = 'f' // Full row is replica identity
	REPLICA_IDENTITY_INDEX   rune = 'i' // Use specific index
)

// Foreign Key Constraint Action Types
// Ported from postgres/src/include/nodes/parsenodes.h:2670-2674
const (
	FKCONSTR_ACTION_NOACTION   byte = 'a' // NO ACTION
	FKCONSTR_ACTION_RESTRICT   byte = 'r' // RESTRICT
	FKCONSTR_ACTION_CASCADE    byte = 'c' // CASCADE
	FKCONSTR_ACTION_SETNULL    byte = 'n' // SET NULL
	FKCONSTR_ACTION_SETDEFAULT byte = 'd' // SET DEFAULT
)

// KeyAction represents a foreign key action with optional column list
// Ported from postgres/src/backend/parser/gram.y:142-146
type KeyAction struct {
	BaseNode
	Action byte      // FKCONSTR_ACTION_* constant
	Cols   *NodeList // optional column list for SET NULL/SET DEFAULT
}

// KeyActions represents both update and delete actions for foreign keys
// Ported from postgres/src/backend/parser/gram.y:148-152
type KeyActions struct {
	BaseNode
	UpdateAction *KeyAction
	DeleteAction *KeyAction
}

// SqlString returns the SQL representation of KeyAction
func (ka *KeyAction) SqlString() string {
	if ka == nil {
		return ""
	}

	var result string
	switch ka.Action {
	case FKCONSTR_ACTION_NOACTION:
		result = "NO ACTION"
	case FKCONSTR_ACTION_RESTRICT:
		result = "RESTRICT"
	case FKCONSTR_ACTION_CASCADE:
		result = "CASCADE"
	case FKCONSTR_ACTION_SETNULL:
		result = "SET NULL"
	case FKCONSTR_ACTION_SETDEFAULT:
		result = "SET DEFAULT"
	default:
		result = "NO ACTION"
	}

	// Add column list if present (only valid for SET NULL and SET DEFAULT)
	if ka.Cols != nil && len(ka.Cols.Items) > 0 {
		if ka.Action == FKCONSTR_ACTION_SETNULL || ka.Action == FKCONSTR_ACTION_SETDEFAULT {
			result += " ("
			for i, col := range ka.Cols.Items {
				if i > 0 {
					result += ", "
				}
				result += col.SqlString()
			}
			result += ")"
		}
	}

	return result
}

func (c ConstrType) String() string {
	switch c {
	case CONSTR_NULL:
		return "NULL"
	case CONSTR_NOTNULL:
		return "NOT_NULL"
	case CONSTR_DEFAULT:
		return "DEFAULT"
	case CONSTR_CHECK:
		return "CHECK"
	case CONSTR_PRIMARY:
		return "PRIMARY_KEY"
	case CONSTR_UNIQUE:
		return "UNIQUE"
	case CONSTR_FOREIGN:
		return "FOREIGN_KEY"
	default:
		return fmt.Sprintf("ConstrType(%d)", int(c))
	}
}

// ViewCheckOption represents WITH CHECK OPTION - ported from postgres/src/include/nodes/parsenodes.h:3773-3777
type ViewCheckOption int

const (
	NO_CHECK_OPTION ViewCheckOption = iota
	LOCAL_CHECK_OPTION
	CASCADED_CHECK_OPTION
)

func (v ViewCheckOption) String() string {
	switch v {
	case NO_CHECK_OPTION:
		return "NO_CHECK"
	case LOCAL_CHECK_OPTION:
		return "LOCAL"
	case CASCADED_CHECK_OPTION:
		return "CASCADED"
	default:
		return fmt.Sprintf("ViewCheckOption(%d)", int(v))
	}
}

// AlterTableType represents types of ALTER TABLE operations - ported from postgres/src/include/nodes/parsenodes.h:2348-2417
type AlterTableType int

const (
	AT_AddColumn                 AlterTableType = iota // add column
	AT_AddColumnToView                                 // implicitly via CREATE OR REPLACE VIEW
	AT_ColumnDefault                                   // alter column default
	AT_CookedColumnDefault                             // add a pre-cooked column default
	AT_DropNotNull                                     // alter column drop not null
	AT_SetNotNull                                      // alter column set not null
	AT_SetExpression                                   // alter column set expression
	AT_DropExpression                                  // alter column drop expression
	AT_CheckNotNull                                    // check column is already not null
	AT_SetStatistics                                   // alter column set statistics
	AT_SetOptions                                      // alter column set (options)
	AT_ResetOptions                                    // alter column reset (options)
	AT_SetStorage                                      // alter column set storage
	AT_SetCompression                                  // alter column set compression
	AT_DropColumn                                      // drop column
	AT_AddIndex                                        // add index
	AT_ReAddIndex                                      // internal to commands/tablecmds.c
	AT_AddConstraint                                   // add constraint
	AT_AddConstraintRecurse                            // internal to commands/tablecmds.c
	AT_ReAddConstraint                                 // internal to commands/tablecmds.c
	AT_ReAddDomainConstraint                           // internal to commands/tablecmds.c
	AT_AlterConstraint                                 // alter constraint
	AT_ValidateConstraint                              // validate constraint
	AT_AddIndexConstraint                              // add constraint using existing index
	AT_DropConstraint                                  // drop constraint
	AT_ReAddComment                                    // internal to commands/tablecmds.c
	AT_AlterColumnType                                 // alter column type
	AT_AlterColumnGenericOptions                       // alter column OPTIONS (...)
	AT_ChangeOwner                                     // change owner
	AT_ClusterOn                                       // CLUSTER ON
	AT_DropCluster                                     // SET WITHOUT CLUSTER
	AT_SetLogged                                       // SET LOGGED
	AT_SetUnLogged                                     // SET UNLOGGED
	AT_DropOids                                        // SET WITHOUT OIDS
	AT_SetAccessMethod                                 // SET ACCESS METHOD
	AT_SetTableSpace                                   // SET TABLESPACE
	AT_SetRelOptions                                   // SET (...)
	AT_ResetRelOptions                                 // RESET (...)
	AT_ReplaceRelOptions                               // replace reloption list in its entirety
	AT_EnableTrig                                      // ENABLE TRIGGER name
	AT_EnableAlwaysTrig                                // ENABLE ALWAYS TRIGGER name
	AT_EnableReplicaTrig                               // ENABLE REPLICA TRIGGER name
	AT_DisableTrig                                     // DISABLE TRIGGER name
	AT_EnableTrigAll                                   // ENABLE TRIGGER ALL
	AT_DisableTrigAll                                  // DISABLE TRIGGER ALL
	AT_EnableTrigUser                                  // ENABLE TRIGGER USER
	AT_DisableTrigUser                                 // DISABLE TRIGGER USER
	AT_EnableRule                                      // ENABLE RULE name
	AT_EnableAlwaysRule                                // ENABLE ALWAYS RULE name
	AT_EnableReplicaRule                               // ENABLE REPLICA RULE name
	AT_DisableRule                                     // DISABLE RULE name
	AT_AddInherit                                      // INHERIT parent
	AT_DropInherit                                     // NO INHERIT parent
	AT_AddOf                                           // OF <type_name>
	AT_DropOf                                          // NOT OF
	AT_ReplicaIdentity                                 // REPLICA IDENTITY
	AT_EnableRowSecurity                               // ENABLE ROW SECURITY
	AT_DisableRowSecurity                              // DISABLE ROW SECURITY
	AT_ForceRowSecurity                                // FORCE ROW SECURITY
	AT_NoForceRowSecurity                              // NO FORCE ROW SECURITY
	AT_GenericOptions                                  // OPTIONS (...)
	AT_AttachPartition                                 // ATTACH PARTITION
	AT_DetachPartition                                 // DETACH PARTITION
	AT_DetachPartitionFinalize                         // DETACH PARTITION ... FINALIZE
	AT_AddIdentity                                     // ADD IDENTITY
	AT_SetIdentity                                     // SET identity column options
	AT_DropIdentity                                    // DROP IDENTITY
	AT_ReAddStatistics                                 // internal to commands/tablecmds.c
)

func (a AlterTableType) String() string {
	switch a {
	case AT_AddColumn:
		return "ADD_COLUMN"
	case AT_DropColumn:
		return "DROP_COLUMN"
	case AT_ColumnDefault:
		return "COLUMN_DEFAULT"
	case AT_DropNotNull:
		return "DROP_NOT_NULL"
	case AT_SetNotNull:
		return "SET_NOT_NULL"
	case AT_AddConstraint:
		return "ADD_CONSTRAINT"
	case AT_DropConstraint:
		return "DROP_CONSTRAINT"
	case AT_AlterColumnType:
		return "ALTER_COLUMN_TYPE"
	case AT_ChangeOwner:
		return "CHANGE_OWNER"
	case AT_SetTableSpace:
		return "SET_TABLESPACE"
	default:
		return fmt.Sprintf("AlterTableType(%d)", int(a))
	}
}

// DefElemAction represents actions for DefElem - ported from postgres/src/include/nodes/parsenodes.h:803-809
type DefElemAction int

const (
	DEFELEM_UNSPEC DefElemAction = iota // no action given
	DEFELEM_SET                         // SET
	DEFELEM_ADD                         // ADD
	DEFELEM_DROP                        // DROP
)

func (d DefElemAction) String() string {
	switch d {
	case DEFELEM_UNSPEC:
		return "UNSPEC"
	case DEFELEM_SET:
		return "SET"
	case DEFELEM_ADD:
		return "ADD"
	case DEFELEM_DROP:
		return "DROP"
	default:
		return fmt.Sprintf("DefElemAction(%d)", int(d))
	}
}

// SortByDir represents sort direction - ported from postgres/src/include/nodes/parsenodes.h:57-62
type SortByDir int

const (
	SORTBY_DEFAULT SortByDir = iota
	SORTBY_ASC
	SORTBY_DESC
	SORTBY_USING // not used in indexes
)

func (s SortByDir) String() string {
	switch s {
	case SORTBY_DEFAULT:
		return "DEFAULT"
	case SORTBY_ASC:
		return "ASC"
	case SORTBY_DESC:
		return "DESC"
	case SORTBY_USING:
		return "USING"
	default:
		return fmt.Sprintf("SortByDir(%d)", int(s))
	}
}

// SortByNulls represents null ordering - ported from postgres/src/include/nodes/parsenodes.h:64-69
type SortByNulls int

const (
	SORTBY_NULLS_DEFAULT SortByNulls = iota
	SORTBY_NULLS_FIRST
	SORTBY_NULLS_LAST
)

func (s SortByNulls) String() string {
	switch s {
	case SORTBY_NULLS_DEFAULT:
		return "DEFAULT"
	case SORTBY_NULLS_FIRST:
		return "NULLS_FIRST"
	case SORTBY_NULLS_LAST:
		return "NULLS_LAST"
	default:
		return fmt.Sprintf("SortByNulls(%d)", int(s))
	}
}

// RoleSpecType represents types of role specifications - ported from postgres/src/include/nodes/parsenodes.h:383-389
type RoleSpecType int

const (
	ROLESPEC_CSTRING      RoleSpecType = iota // role name is stored as a C string
	ROLESPEC_CURRENT_ROLE                     // role spec is CURRENT_ROLE
	ROLESPEC_CURRENT_USER                     // role spec is CURRENT_USER
	ROLESPEC_SESSION_USER                     // role spec is SESSION_USER
	ROLESPEC_PUBLIC                           // role name is "public"
)

func (r RoleSpecType) String() string {
	switch r {
	case ROLESPEC_CSTRING:
		return "CSTRING"
	case ROLESPEC_CURRENT_ROLE:
		return "CURRENT_ROLE"
	case ROLESPEC_CURRENT_USER:
		return "CURRENT_USER"
	case ROLESPEC_SESSION_USER:
		return "SESSION_USER"
	case ROLESPEC_PUBLIC:
		return "PUBLIC"
	default:
		return fmt.Sprintf("RoleSpecType(%d)", int(r))
	}
}

// RoleSpec represents a role specification.
// Ported from postgres/src/include/nodes/parsenodes.h:401
type RoleSpec struct {
	BaseNode
	Roletype RoleSpecType // Type of this rolespec - postgres/src/include/nodes/parsenodes.h:403
	Rolename string       // filled only for ROLESPEC_CSTRING - postgres/src/include/nodes/parsenodes.h:404
}

// NewRoleSpec creates a new RoleSpec node.
func NewRoleSpec(roletype RoleSpecType, rolename string) *RoleSpec {
	return &RoleSpec{
		BaseNode: BaseNode{Tag: T_RoleSpec},
		Roletype: roletype,
		Rolename: rolename,
	}
}

func (r *RoleSpec) String() string {
	if r.Roletype == ROLESPEC_CSTRING {
		return fmt.Sprintf("RoleSpec(%s)@%d", r.Rolename, r.Location())
	}
	return fmt.Sprintf("RoleSpec(%s)@%d", r.Roletype, r.Location())
}

// ==============================================================================
// CORE DDL SUPPORTING STRUCTURES
// ==============================================================================

// TypeName represents a type name specification.
// This is a placeholder implementation - full TypeName from parsenodes.h will be implemented later
type TypeName struct {
	BaseNode
	Names       *NodeList // qualified name (list of String)
	TypeOid     Oid       // type's OID (filled in by transformTypeName)
	Setof       bool      // is a set?
	PctType     bool      // %TYPE specified?
	Typmods     *NodeList // type modifier expression(s)
	Typemod     int32     // prespecified type modifier
	ArrayBounds *NodeList // array bounds
}

// stringsToNodeList converts a slice of strings to a NodeList of String nodes
func stringsToNodeList(names []string) *NodeList {
	if len(names) == 0 {
		return nil
	}
	nodeList := NewNodeList()
	for _, name := range names {
		nodeList.Append(NewString(name))
	}
	return nodeList
}

// nodeListToStrings converts a NodeList of String nodes back to a slice of strings
func nodeListToStrings(nodeList *NodeList) []string {
	if nodeList == nil {
		return nil
	}
	var names []string
	for _, item := range nodeList.Items {
		if str, ok := item.(*String); ok {
			names = append(names, str.SVal)
		}
	}
	return names
}

// GetNames returns the Names as a slice of strings for testing purposes
func (t *TypeName) GetNames() []string {
	return nodeListToStrings(t.Names)
}

// GetKeys returns the Keys as a slice of strings for testing purposes
func (c *Constraint) GetKeys() []string {
	return nodeListToStrings(c.Keys)
}

// GetIncluding returns the Including as a slice of strings for testing purposes
func (c *Constraint) GetIncluding() []string {
	return nodeListToStrings(c.Including)
}

// GetFkAttrs returns the FkAttrs as a slice of strings for testing purposes
func (c *Constraint) GetFkAttrs() []string {
	return nodeListToStrings(c.FkAttrs)
}

// GetPkAttrs returns the PkAttrs as a slice of strings for testing purposes
func (c *Constraint) GetPkAttrs() []string {
	return nodeListToStrings(c.PkAttrs)
}

// GetFkDelSetCols returns the FkDelSetCols as a slice of strings for testing purposes
func (c *Constraint) GetFkDelSetCols() []string {
	return nodeListToStrings(c.FkDelSetCols)
}

// NewTypeName creates a new TypeName node.
func NewTypeName(names []string) *TypeName {
	return &TypeName{
		BaseNode: BaseNode{Tag: T_TypeName},
		Names:    stringsToNodeList(names),
	}
}

func (t *TypeName) String() string {
	typeName := ""
	if t.Names != nil && t.Names.Len() > 0 {
		lastItem := t.Names.Items[t.Names.Len()-1]
		if str, ok := lastItem.(*String); ok {
			typeName = str.SVal
		}
	}
	return fmt.Sprintf("TypeName(%s)@%d", typeName, t.Location())
}

// SqlString returns the SQL representation of the TypeName
func (t *TypeName) SqlString() string {
	if t.Names == nil || t.Names.Len() == 0 {
		return ""
	}

	// Join qualified names with dots (e.g., "schema.type")
	var nameParts []string
	for _, item := range t.Names.Items {
		if str, ok := item.(*String); ok {
			nameParts = append(nameParts, str.SVal)
		}
	}
	typeName := strings.Join(nameParts, ".")

	// Add type modifiers if present
	if t.Typmods != nil && t.Typmods.Len() > 0 {
		var modStrs []string
		for _, mod := range t.Typmods.Items {
			if mod != nil {
				modStrs = append(modStrs, mod.SqlString())
			}
		}
		if len(modStrs) > 0 {
			typeName += "(" + strings.Join(modStrs, ", ") + ")"
		}
	}

	return typeName
}

// CollateClause represents a COLLATE clause.
// This is a placeholder implementation - full CollateClause from parsenodes.h will be implemented later
type CollateClause struct {
	BaseNode
	Arg      Node      // input expression
	Collname *NodeList // possibly-qualified collation name
}

// NewCollateClause creates a new CollateClause node.
func NewCollateClause(collname *NodeList) *CollateClause {
	return &CollateClause{
		BaseNode: BaseNode{Tag: T_CollateClause, Loc: -1},
		Collname: collname,
	}
}

func (c *CollateClause) String() string {
	collName := ""
	if c.Collname != nil && c.Collname.Len() > 0 {
		// Get the last element (unqualified name)
		if lastNode := c.Collname.Items[c.Collname.Len()-1]; lastNode != nil {
			if strNode, ok := lastNode.(*String); ok {
				collName = strNode.SVal
			}
		}
	}
	return fmt.Sprintf("CollateClause(%s)@%d", collName, c.Location())
}

// SqlString generates SQL representation of a COLLATE clause
func (c *CollateClause) SqlString() string {
	if c.Collname != nil && c.Collname.Len() > 0 {
		collNames := make([]string, 0, c.Collname.Len())
		for _, item := range c.Collname.Items {
			if strNode, ok := item.(*String); ok {
				collNames = append(collNames, strNode.SVal)
			}
		}
		return strings.Join(collNames, ".")
	}
	return ""
}

// ==============================================================================

// DefElem represents a generic name/value pair for options.
// Ported from postgres/src/include/nodes/parsenodes.h:811
type DefElem struct {
	BaseNode
	Defnamespace string        // NULL if unqualified name - postgres/src/include/nodes/parsenodes.h:813
	Defname      string        // postgres/src/include/nodes/parsenodes.h:814
	Arg          Node          // typically Integer, Float, String, or TypeName - postgres/src/include/nodes/parsenodes.h:815
	Defaction    DefElemAction // unspecified action, or SET/ADD/DROP - postgres/src/include/nodes/parsenodes.h:816
}

// NewDefElem creates a new DefElem node.
func NewDefElem(defname string, arg Node) *DefElem {
	return &DefElem{
		BaseNode:  BaseNode{Tag: T_DefElem},
		Defname:   defname,
		Arg:       arg,
		Defaction: DEFELEM_UNSPEC,
	}
}

// NewDefElemExtended creates a new DefElem node with a qualified name.
func NewDefElemExtended(defnamespace, defname string, arg Node, action DefElemAction) *DefElem {
	return &DefElem{
		BaseNode:     BaseNode{Tag: T_DefElem},
		Defnamespace: defnamespace,
		Defname:      defname,
		Arg:          arg,
		Defaction:    action,
	}
}

func (d *DefElem) String() string {
	action := ""
	if d.Defaction != DEFELEM_UNSPEC {
		action = fmt.Sprintf(" %s", d.Defaction)
	}
	return fmt.Sprintf("DefElem(%s%s)@%d", d.Defname, action, d.Location())
}

// SqlString returns the SQL representation of DefElem
func (d *DefElem) SqlString() string {
	if d.Arg != nil {
		return fmt.Sprintf("%s = %s", d.Defname, d.Arg.SqlString())
	}
	return d.Defname
}

// Constraint represents a constraint definition.
// Ported from postgres/src/include/nodes/parsenodes.h:2728
type Constraint struct {
	BaseNode
	Contype            ConstrType // see above - postgres/src/include/nodes/parsenodes.h:2731
	Conname            string     // Constraint name, or NULL if unnamed - postgres/src/include/nodes/parsenodes.h:2732
	Deferrable         bool       // DEFERRABLE? - postgres/src/include/nodes/parsenodes.h:2733
	Initdeferred       bool       // INITIALLY DEFERRED? - postgres/src/include/nodes/parsenodes.h:2734
	SkipValidation     bool       // skip validation of existing rows? - postgres/src/include/nodes/parsenodes.h:2735
	InitiallyValid     bool       // mark the new constraint as valid? - postgres/src/include/nodes/parsenodes.h:2736
	IsNoInherit        bool       // is constraint non-inheritable? - postgres/src/include/nodes/parsenodes.h:2737
	RawExpr            Node       // CHECK or DEFAULT expression, as untransformed parse tree - postgres/src/include/nodes/parsenodes.h:2738
	CookedExpr         string     // CHECK or DEFAULT expression, as nodeToString representation - postgres/src/include/nodes/parsenodes.h:2740
	GeneratedWhen      byte       // ALWAYS or BY DEFAULT - postgres/src/include/nodes/parsenodes.h:2742
	Inhcount           int        // initial inheritance count to apply - postgres/src/include/nodes/parsenodes.h:2743
	NullsNotDistinct   bool       // null treatment for UNIQUE constraints - postgres/src/include/nodes/parsenodes.h:2744
	Keys               *NodeList  // String nodes naming referenced key column(s) - postgres/src/include/nodes/parsenodes.h:2746
	Including          *NodeList  // String nodes naming referenced nonkey column(s) - postgres/src/include/nodes/parsenodes.h:2747
	Exclusions         *NodeList  // list of (IndexElem, operator name) pairs - postgres/src/include/nodes/parsenodes.h:2748
	Options            *NodeList  // options from WITH clause - postgres/src/include/nodes/parsenodes.h:2749
	Indexname          string     // existing index to use; otherwise NULL - postgres/src/include/nodes/parsenodes.h:2750
	Indexspace         string     // index tablespace; NULL for default - postgres/src/include/nodes/parsenodes.h:2751
	ResetDefaultTblspc bool       // reset default_tablespace prior to creating the index - postgres/src/include/nodes/parsenodes.h:2752
	AccessMethod       string     // access method to use for the index - postgres/src/include/nodes/parsenodes.h:2753
	WhereClause        Node       // partial index predicate - postgres/src/include/nodes/parsenodes.h:2754
	Pktable            *RangeVar  // Primary key table for FOREIGN KEY - postgres/src/include/nodes/parsenodes.h:2755
	FkAttrs            *NodeList  // Attributes of foreign key - postgres/src/include/nodes/parsenodes.h:2756
	PkAttrs            *NodeList  // Corresponding attrs in PK table - postgres/src/include/nodes/parsenodes.h:2757
	FkMatchtype        byte       // FULL, PARTIAL, SIMPLE - postgres/src/include/nodes/parsenodes.h:2758
	FkUpdAction        byte       // ON UPDATE action - postgres/src/include/nodes/parsenodes.h:2759
	FkDelAction        byte       // ON DELETE action - postgres/src/include/nodes/parsenodes.h:2760
	FkDelSetCols       *NodeList  // ON DELETE SET NULL/DEFAULT (column_list) - postgres/src/include/nodes/parsenodes.h:2761
	OldConpfeqop       []Oid      // pg_constraint.conpfeqop of my former self - postgres/src/include/nodes/parsenodes.h:2762
	OldPktableOid      Oid        // pg_class.oid of my former self - postgres/src/include/nodes/parsenodes.h:2763
}

// NewConstraint creates a new Constraint node.
func NewConstraint(contype ConstrType) *Constraint {
	return &Constraint{
		BaseNode: BaseNode{Tag: T_Constraint},
		Contype:  contype,
	}
}

func (c *Constraint) String() string {
	name := c.Conname
	if name == "" {
		name = "unnamed"
	}
	return fmt.Sprintf("Constraint(%s %s)@%d", c.Contype, name, c.Location())
}

// SqlString generates SQL representation of a constraint
func (c *Constraint) SqlString() string {
	switch c.Contype {
	case CONSTR_NOTNULL:
		return "NOT NULL"
	case CONSTR_NULL:
		return "NULL"
	case CONSTR_DEFAULT:
		if c.RawExpr != nil {
			return "DEFAULT " + c.RawExpr.SqlString()
		}
		return "DEFAULT"
	case CONSTR_IDENTITY:
		result := "GENERATED "
		if c.GeneratedWhen == ATTRIBUTE_IDENTITY_ALWAYS {
			result += "ALWAYS"
		} else if c.GeneratedWhen == ATTRIBUTE_IDENTITY_BY_DEFAULT {
			result += "BY DEFAULT"
		}
		result += " AS IDENTITY"
		// TODO: Add sequence options if c.Options is not nil
		return result
	case CONSTR_PRIMARY:
		result := "PRIMARY KEY"
		if c.Keys != nil && c.Keys.Len() > 0 {
			result += " (" + strings.Join(nodeListToStrings(c.Keys), ", ") + ")"
		}
		return result
	case CONSTR_UNIQUE:
		result := "UNIQUE"
		if c.Keys != nil && c.Keys.Len() > 0 {
			result += " (" + strings.Join(nodeListToStrings(c.Keys), ", ") + ")"
		}
		return result
	case CONSTR_CHECK:
		result := "CHECK"
		if c.RawExpr != nil {
			result += " (" + c.RawExpr.SqlString() + ")"
		}
		return result
	case CONSTR_FOREIGN:
		result := ""
		// For column-level constraints, don't include "FOREIGN KEY"
		// For table-level constraints, include it
		if c.FkAttrs != nil && c.FkAttrs.Len() > 0 {
			result = "FOREIGN KEY (" + strings.Join(nodeListToStrings(c.FkAttrs), ", ") + ")"
		} else {
			result = "REFERENCES"
		}
		if c.Pktable != nil {
			if c.FkAttrs != nil && c.FkAttrs.Len() > 0 {
				result += " REFERENCES " + c.Pktable.SqlString()
			} else {
				result += " " + c.Pktable.SqlString()
			}
			if c.PkAttrs != nil && c.PkAttrs.Len() > 0 {
				result += "(" + strings.Join(nodeListToStrings(c.PkAttrs), ", ") + ")"
			}
		}

		// Add foreign key actions (only if explicitly set and not default NO ACTION)
		if c.FkUpdAction != 0 && c.FkUpdAction != FKCONSTR_ACTION_NOACTION {
			switch c.FkUpdAction {
			case FKCONSTR_ACTION_RESTRICT:
				result += " ON UPDATE RESTRICT"
			case FKCONSTR_ACTION_CASCADE:
				result += " ON UPDATE CASCADE"
			case FKCONSTR_ACTION_SETNULL:
				result += " ON UPDATE SET NULL"
			case FKCONSTR_ACTION_SETDEFAULT:
				result += " ON UPDATE SET DEFAULT"
			}
		}

		if c.FkDelAction != 0 && c.FkDelAction != FKCONSTR_ACTION_NOACTION {
			switch c.FkDelAction {
			case FKCONSTR_ACTION_RESTRICT:
				result += " ON DELETE RESTRICT"
			case FKCONSTR_ACTION_CASCADE:
				result += " ON DELETE CASCADE"
			case FKCONSTR_ACTION_SETNULL:
				result += " ON DELETE SET NULL"
				if c.FkDelSetCols != nil && len(c.FkDelSetCols.Items) > 0 {
					result += " (" + strings.Join(nodeListToStrings(c.FkDelSetCols), ", ") + ")"
				}
			case FKCONSTR_ACTION_SETDEFAULT:
				result += " ON DELETE SET DEFAULT"
				if c.FkDelSetCols != nil && len(c.FkDelSetCols.Items) > 0 {
					result += " (" + strings.Join(nodeListToStrings(c.FkDelSetCols), ", ") + ")"
				}
			}
		}

		return result
	}
	return ""
}

// ==============================================================================
// ALTER TABLE STATEMENTS
// ==============================================================================

// AlterTableStmt represents an ALTER TABLE statement.
// Ported from postgres/src/include/nodes/parsenodes.h:2339
type AlterTableStmt struct {
	BaseNode
	Relation  *RangeVar  // table to work on - postgres/src/include/nodes/parsenodes.h:2341
	Cmds      *NodeList  // list of subcommands - postgres/src/include/nodes/parsenodes.h:2342
	Objtype   ObjectType // type of object - postgres/src/include/nodes/parsenodes.h:2344
	MissingOk bool       // skip error if table missing - postgres/src/include/nodes/parsenodes.h:2345
}

// NewAlterTableStmt creates a new AlterTableStmt node.
func NewAlterTableStmt(relation *RangeVar, cmds *NodeList) *AlterTableStmt {
	return &AlterTableStmt{
		BaseNode: BaseNode{Tag: T_AlterTableStmt},
		Relation: relation,
		Cmds:     cmds,
		Objtype:  OBJECT_TABLE,
	}
}

func (a *AlterTableStmt) StatementType() string {
	return "AlterTableStmt"
}

func (a *AlterTableStmt) String() string {
	cmdCount := 0
	if a.Cmds != nil {
		cmdCount = a.Cmds.Len()
	}
	return fmt.Sprintf("AlterTableStmt(%s, %d cmds)@%d", a.Relation.RelName, cmdCount, a.Location())
}

// ReplicaIdentityStmt represents a REPLICA IDENTITY statement.
// Ported from postgres/src/include/nodes/parsenodes.h
type ReplicaIdentityStmt struct {
	BaseNode
	IdentityType rune   // replica identity type ('d', 'n', 'f', 'i')
	Name         string // index name for REPLICA_IDENTITY_INDEX, or empty
}

// NewReplicaIdentityStmt creates a new ReplicaIdentityStmt node.
func NewReplicaIdentityStmt(identityType rune, name string) *ReplicaIdentityStmt {
	return &ReplicaIdentityStmt{
		BaseNode:     BaseNode{Tag: T_ReplicaIdentityStmt},
		IdentityType: identityType,
		Name:         name,
	}
}

func (r *ReplicaIdentityStmt) StatementType() string {
	return "ReplicaIdentityStmt"
}

func (r *ReplicaIdentityStmt) String() string {
	if r.Name != "" {
		return fmt.Sprintf("ReplicaIdentityStmt(%c, %s)@%d", r.IdentityType, r.Name, r.Location())
	}
	return fmt.Sprintf("ReplicaIdentityStmt(%c)@%d", r.IdentityType, r.Location())
}

func (r *ReplicaIdentityStmt) SqlString() string {
	switch r.IdentityType {
	case REPLICA_IDENTITY_NOTHING:
		return "REPLICA IDENTITY NOTHING"
	case REPLICA_IDENTITY_FULL:
		return "REPLICA IDENTITY FULL"
	case REPLICA_IDENTITY_DEFAULT:
		return "REPLICA IDENTITY DEFAULT"
	case REPLICA_IDENTITY_INDEX:
		return fmt.Sprintf("REPLICA IDENTITY USING INDEX %s", r.Name)
	default:
		return "REPLICA IDENTITY"
	}
}

// AlterTableMoveAllStmt represents moving all tables/indexes/views from one tablespace to another.
// Ported from postgres/src/include/nodes/parsenodes.h:2348-2356
type AlterTableMoveAllStmt struct {
	BaseNode
	OrigTablespacename string     // original tablespace name
	Objtype            ObjectType // Object type to move
	Roles              *NodeList  // List of roles to move objects of
	NewTablespacename  string     // new tablespace name
	Nowait             bool       // do not wait for locks
}

// NewAlterTableMoveAllStmt creates a new AlterTableMoveAllStmt node.
func NewAlterTableMoveAllStmt(origTablespace string, objtype ObjectType, newTablespace string) *AlterTableMoveAllStmt {
	return &AlterTableMoveAllStmt{
		BaseNode:           BaseNode{Tag: T_AlterTableMoveAllStmt},
		OrigTablespacename: origTablespace,
		Objtype:            objtype,
		NewTablespacename:  newTablespace,
	}
}

func (a *AlterTableMoveAllStmt) node() {}
func (a *AlterTableMoveAllStmt) stmt() {}

func (a *AlterTableMoveAllStmt) StatementType() string {
	return "AlterTableMoveAllStmt"
}

func (a *AlterTableMoveAllStmt) String() string {
	return fmt.Sprintf("AlterTableMoveAllStmt(%s->%s)@%d", a.OrigTablespacename, a.NewTablespacename, a.Location())
}

func (a *AlterTableMoveAllStmt) SqlString() string {
	var parts []string

	// Start with ALTER
	parts = append(parts, "ALTER")

	// Add object type
	switch a.Objtype {
	case OBJECT_TABLE:
		parts = append(parts, "TABLE")
	case OBJECT_INDEX:
		parts = append(parts, "INDEX")
	case OBJECT_MATVIEW:
		parts = append(parts, "MATERIALIZED VIEW")
	default:
		parts = append(parts, "TABLE")
	}

	// Add ALL IN TABLESPACE
	parts = append(parts, "ALL IN TABLESPACE", a.OrigTablespacename)

	// Add OWNED BY if roles specified
	if a.Roles != nil && a.Roles.Len() > 0 {
		parts = append(parts, "OWNED BY")
		// Extract role names from the NodeList
		roleNames := make([]string, 0, a.Roles.Len())
		for _, item := range a.Roles.Items {
			if roleSpec, ok := item.(*RoleSpec); ok {
				// Handle different role types
				if roleSpec.Rolename != "" {
					roleNames = append(roleNames, roleSpec.Rolename)
				} else {
					// Handle special roles like CURRENT_USER, etc.
					switch roleSpec.Roletype {
					case ROLESPEC_CURRENT_USER:
						roleNames = append(roleNames, "CURRENT_USER")
					case ROLESPEC_CURRENT_ROLE:
						roleNames = append(roleNames, "CURRENT_ROLE")
					case ROLESPEC_SESSION_USER:
						roleNames = append(roleNames, "SESSION_USER")
					}
				}
			}
		}
		parts = append(parts, strings.Join(roleNames, ", "))
	}

	// Add SET TABLESPACE
	parts = append(parts, "SET TABLESPACE", a.NewTablespacename)

	// Add NOWAIT if specified
	if a.Nowait {
		parts = append(parts, "NOWAIT")
	}

	return strings.Join(parts, " ")
}

func (a *AlterTableStmt) SqlString() string {
	var parts []string

	// Start with ALTER
	parts = append(parts, "ALTER")

	// Add object type
	switch a.Objtype {
	case OBJECT_TABLE:
		parts = append(parts, "TABLE")
	case OBJECT_INDEX:
		parts = append(parts, "INDEX")
	case OBJECT_SEQUENCE:
		parts = append(parts, "SEQUENCE")
	case OBJECT_VIEW:
		parts = append(parts, "VIEW")
	case OBJECT_MATVIEW:
		parts = append(parts, "MATERIALIZED VIEW")
	case OBJECT_FOREIGN_TABLE:
		parts = append(parts, "FOREIGN TABLE")
	default:
		parts = append(parts, "TABLE")
	}

	// Add IF EXISTS if specified
	if a.MissingOk {
		parts = append(parts, "IF EXISTS")
	}

	// Add relation name
	if a.Relation != nil {
		parts = append(parts, a.Relation.SqlString())
	}

	// Add commands
	if a.Cmds != nil && a.Cmds.Len() > 0 {
		var cmdStrs []string
		for _, item := range a.Cmds.Items {
			if cmd, ok := item.(*AlterTableCmd); ok && cmd != nil {
				cmdStrs = append(cmdStrs, cmd.SqlString())
			}
		}
		if len(cmdStrs) > 0 {
			parts = append(parts, strings.Join(cmdStrs, ", "))
		}
	}

	return strings.Join(parts, " ")
}

// AlterTableCmd represents one subcommand of an ALTER TABLE.
// Ported from postgres/src/include/nodes/parsenodes.h:2426
type AlterTableCmd struct {
	BaseNode
	Subtype   AlterTableType // Type of table alteration to apply - postgres/src/include/nodes/parsenodes.h:2429
	Name      string         // column, constraint, or trigger to act on - postgres/src/include/nodes/parsenodes.h:2430
	Num       int16          // attribute number for columns referenced by number - postgres/src/include/nodes/parsenodes.h:2432
	Newowner  *RoleSpec      // postgres/src/include/nodes/parsenodes.h:2434
	Def       Node           // definition of new column, index, constraint, or parent table - postgres/src/include/nodes/parsenodes.h:2435
	Behavior  DropBehavior   // RESTRICT or CASCADE for DROP cases - postgres/src/include/nodes/parsenodes.h:2437
	MissingOk bool           // skip error if missing? - postgres/src/include/nodes/parsenodes.h:2438
	Recurse   bool           // exec-time recursion - postgres/src/include/nodes/parsenodes.h:2439
}

// NewAlterTableCmd creates a new AlterTableCmd node.
func NewAlterTableCmd(subtype AlterTableType, name string, def Node) *AlterTableCmd {
	return &AlterTableCmd{
		BaseNode: BaseNode{Tag: T_AlterTableCmd},
		Subtype:  subtype,
		Name:     name,
		Def:      def,
		Behavior: DropRestrict,
	}
}

func (a *AlterTableCmd) String() string {
	return fmt.Sprintf("AlterTableCmd(%s %s)@%d", a.Subtype, a.Name, a.Location())
}

func (a *AlterTableCmd) SqlString() string {
	var parts []string

	switch a.Subtype {
	case AT_AddColumn:
		parts = append(parts, "ADD COLUMN")
		if a.MissingOk {
			parts = append(parts, "IF NOT EXISTS")
		}
		if a.Def != nil {
			parts = append(parts, a.Def.SqlString())
		}

	case AT_DropColumn:
		parts = append(parts, "DROP COLUMN")
		if a.MissingOk {
			parts = append(parts, "IF EXISTS")
		}
		parts = append(parts, a.Name)
		if a.Behavior == DropCascade {
			parts = append(parts, "CASCADE")
		}

	case AT_AlterColumnType:
		parts = append(parts, "ALTER COLUMN", a.Name, "TYPE")
		if a.Def != nil {
			parts = append(parts, a.Def.SqlString())
		}

	case AT_ColumnDefault:
		parts = append(parts, "ALTER COLUMN", a.Name)
		if a.Def != nil {
			parts = append(parts, "SET DEFAULT", a.Def.SqlString())
		} else {
			parts = append(parts, "DROP DEFAULT")
		}

	case AT_SetNotNull:
		parts = append(parts, "ALTER COLUMN", a.Name, "SET NOT NULL")

	case AT_DropNotNull:
		parts = append(parts, "ALTER COLUMN", a.Name, "DROP NOT NULL")

	case AT_SetStatistics:
		parts = append(parts, "ALTER COLUMN", a.Name, "SET STATISTICS")
		if a.Def != nil {
			parts = append(parts, a.Def.SqlString())
		}

	case AT_SetExpression:
		parts = append(parts, "ALTER COLUMN", a.Name, "SET EXPRESSION AS")
		if a.Def != nil {
			parts = append(parts, "(", a.Def.SqlString(), ")")
		}

	case AT_DropExpression:
		parts = append(parts, "ALTER COLUMN", a.Name, "DROP EXPRESSION")
		if a.MissingOk {
			parts = append(parts, "IF EXISTS")
		}

	case AT_AddConstraint:
		parts = append(parts, "ADD")
		if a.Def != nil {
			// Add CONSTRAINT keyword and name if it's a named constraint
			if constraint, ok := a.Def.(*Constraint); ok && constraint.Conname != "" {
				parts = append(parts, "CONSTRAINT", constraint.Conname, constraint.SqlString())
			} else {
				parts = append(parts, a.Def.SqlString())
			}
		}

	case AT_DropConstraint:
		parts = append(parts, "DROP CONSTRAINT")
		if a.MissingOk {
			parts = append(parts, "IF EXISTS")
		}
		parts = append(parts, a.Name)
		if a.Behavior == DropCascade {
			parts = append(parts, "CASCADE")
		}

	case AT_ValidateConstraint:
		parts = append(parts, "VALIDATE CONSTRAINT", a.Name)

	case AT_SetStorage:
		parts = append(parts, "ALTER COLUMN", a.Name, "SET STORAGE")
		if a.Def != nil {
			parts = append(parts, a.Def.SqlString())
		}

	case AT_SetCompression:
		parts = append(parts, "ALTER COLUMN", a.Name, "SET COMPRESSION")
		if a.Def != nil {
			parts = append(parts, a.Def.SqlString())
		}

	case AT_SetOptions:
		parts = append(parts, "ALTER COLUMN", a.Name, "SET")
		if a.Def != nil {
			parts = append(parts, a.Def.SqlString())
		}

	case AT_ResetOptions:
		parts = append(parts, "ALTER COLUMN", a.Name, "RESET")
		if a.Def != nil {
			parts = append(parts, a.Def.SqlString())
		}

	case AT_ClusterOn:
		parts = append(parts, "CLUSTER ON", a.Name)

	case AT_DropCluster:
		parts = append(parts, "SET WITHOUT CLUSTER")

	case AT_SetLogged:
		parts = append(parts, "SET LOGGED")

	case AT_SetUnLogged:
		parts = append(parts, "SET UNLOGGED")

	case AT_SetTableSpace:
		parts = append(parts, "SET TABLESPACE", a.Name)

	case AT_ChangeOwner:
		parts = append(parts, "OWNER TO")
		if a.Newowner != nil {
			parts = append(parts, a.Newowner.SqlString())
		}

	case AT_AttachPartition:
		parts = append(parts, "ATTACH PARTITION")
		if a.Def != nil {
			// a.Def should be a PartitionCmd containing the partition name and bound spec
			parts = append(parts, a.Def.SqlString())
		}

	case AT_DetachPartition:
		parts = append(parts, "DETACH PARTITION")
		if a.Def != nil {
			// a.Def should be a PartitionCmd containing the partition name
			if partCmd, ok := a.Def.(*PartitionCmd); ok {
				if partCmd.Name != nil {
					parts = append(parts, partCmd.Name.SqlString())
				}
				if partCmd.Concurrent {
					parts = append(parts, "CONCURRENTLY")
				}
			}
		}

	case AT_DetachPartitionFinalize:
		parts = append(parts, "DETACH PARTITION")
		if a.Def != nil {
			// a.Def should be a PartitionCmd containing the partition name
			if partCmd, ok := a.Def.(*PartitionCmd); ok {
				if partCmd.Name != nil {
					parts = append(parts, partCmd.Name.SqlString(), "FINALIZE")
				}
			}
		}

	case AT_AddIdentity:
		parts = append(parts, "ALTER COLUMN", a.Name, "ADD")
		if a.Def != nil {
			parts = append(parts, a.Def.SqlString())
		}

	default:
		// Fallback for unhandled subtypes
		parts = append(parts, fmt.Sprintf("/* %s */", a.Subtype.String()))
		if a.Name != "" {
			parts = append(parts, a.Name)
		}
	}

	return strings.Join(parts, " ")
}

// ==============================================================================
// INDEX STATEMENTS
// ==============================================================================

// IndexStmt represents a CREATE INDEX statement.
// Ported from postgres/src/include/nodes/parsenodes.h:3348
type IndexStmt struct {
	BaseNode
	Idxname                  string    // name of new index, or NULL for default - postgres/src/include/nodes/parsenodes.h:3350
	Relation                 *RangeVar // relation to build index on - postgres/src/include/nodes/parsenodes.h:3351
	AccessMethod             string    // name of access method (eg. btree) - postgres/src/include/nodes/parsenodes.h:3352
	TableSpace               string    // tablespace, or NULL for default - postgres/src/include/nodes/parsenodes.h:3353
	IndexParams              *NodeList // columns to index: a list of IndexElem - postgres/src/include/nodes/parsenodes.h:3354
	IndexIncludingParams     *NodeList // additional columns to index - postgres/src/include/nodes/parsenodes.h:3355
	Options                  *NodeList // WITH clause options: a list of DefElem - postgres/src/include/nodes/parsenodes.h:3357
	WhereClause              Node      // qualification (partial-index predicate) - postgres/src/include/nodes/parsenodes.h:3358
	ExcludeOpNames           *NodeList // exclusion operator names, or NIL if none - postgres/src/include/nodes/parsenodes.h:3359
	Idxcomment               string    // comment to apply to index, or NULL - postgres/src/include/nodes/parsenodes.h:3360
	IndexOid                 Oid       // OID of an existing index, if any - postgres/src/include/nodes/parsenodes.h:3361
	OldNumber                uint32    // relfilenumber of existing storage, if any - postgres/src/include/nodes/parsenodes.h:3362
	OldCreateSubid           uint32    // rd_createSubid of existing storage, if any - postgres/src/include/nodes/parsenodes.h:3363
	OldFirstRelfilenodeSubid uint32    // rd_firstRelfilenodeSubid of existing storage - postgres/src/include/nodes/parsenodes.h:3364
	Unique                   bool      // is index unique? - postgres/src/include/nodes/parsenodes.h:3365
	NullsNotDistinct         bool      // null treatment in unique index - postgres/src/include/nodes/parsenodes.h:3366
	Primary                  bool      // is index a primary key? - postgres/src/include/nodes/parsenodes.h:3367
	Isconstraint             bool      // is it for a pkey/unique constraint? - postgres/src/include/nodes/parsenodes.h:3368
	Deferrable               bool      // is the constraint DEFERRABLE? - postgres/src/include/nodes/parsenodes.h:3369
	Initdeferred             bool      // is the constraint INITIALLY DEFERRED? - postgres/src/include/nodes/parsenodes.h:3370
	Transformed              bool      // true when transformIndexStmt is finished - postgres/src/include/nodes/parsenodes.h:3371
	Concurrent               bool      // should this be a concurrent index build? - postgres/src/include/nodes/parsenodes.h:3372
	IfNotExists              bool      // just do nothing if index already exists? - postgres/src/include/nodes/parsenodes.h:3373
	ResetDefaultTblspc       bool      // reset default_tablespace prior to creating the index - postgres/src/include/nodes/parsenodes.h:3374
}

// NewIndexStmt creates a new IndexStmt node.
func NewIndexStmt(idxname string, relation *RangeVar, indexParams *NodeList) *IndexStmt {
	return &IndexStmt{
		BaseNode:     BaseNode{Tag: T_IndexStmt},
		Idxname:      idxname,
		Relation:     relation,
		IndexParams:  indexParams,
		AccessMethod: "btree", // default access method
	}
}

func (i *IndexStmt) StatementType() string {
	return "IndexStmt"
}

func (i *IndexStmt) String() string {
	unique := ""
	if i.Unique {
		unique = " UNIQUE"
	}
	return fmt.Sprintf("IndexStmt(%s%s on %s)@%d", i.Idxname, unique, i.Relation.RelName, i.Location())
}

// IndexElem represents one index element (column or expression).
// Ported from postgres/src/include/nodes/parsenodes.h:780
type IndexElem struct {
	BaseNode
	Name          string      // name of attribute to index, or NULL - postgres/src/include/nodes/parsenodes.h:782
	Expr          Node        // expression to index, or NULL - postgres/src/include/nodes/parsenodes.h:783
	Indexcolname  string      // name for index column; NULL = default - postgres/src/include/nodes/parsenodes.h:784
	Collation     *NodeList   // name of collation; NIL = default - postgres/src/include/nodes/parsenodes.h:785
	Opclass       *NodeList   // name of desired opclass; NIL = default - postgres/src/include/nodes/parsenodes.h:786
	Opclassopts   *NodeList   // opclass-specific options, or NIL - postgres/src/include/nodes/parsenodes.h:787
	Ordering      SortByDir   // ASC/DESC/default - postgres/src/include/nodes/parsenodes.h:788
	NullsOrdering SortByNulls // FIRST/LAST/default - postgres/src/include/nodes/parsenodes.h:789
}

// NewIndexElem creates a new IndexElem node.
func NewIndexElem(name string) *IndexElem {
	return &IndexElem{
		BaseNode:      BaseNode{Tag: T_IndexElem},
		Name:          name,
		Ordering:      SORTBY_DEFAULT,
		NullsOrdering: SORTBY_NULLS_DEFAULT,
	}
}

func (i *IndexElem) String() string {
	target := i.Name
	if target == "" && i.Expr != nil {
		target = "expr"
	}
	order := ""
	if i.Ordering != SORTBY_DEFAULT {
		order = fmt.Sprintf(" %s", i.Ordering)
	}
	return fmt.Sprintf("IndexElem(%s%s)@%d", target, order, i.Location())
}

func (i *IndexElem) SqlString() string {
	if i.Name != "" {
		return i.Name
	}
	if i.Expr != nil {
		return i.Expr.SqlString()
	}
	return ""
}

// ==============================================================================
// VIEW STATEMENTS
// ==============================================================================

// ViewStmt represents a CREATE VIEW statement.
// Ported from postgres/src/include/nodes/parsenodes.h:3740
type ViewStmt struct {
	BaseNode
	View            *RangeVar       // the view to be created - postgres/src/include/nodes/parsenodes.h:3742
	Aliases         []string        // target column names - postgres/src/include/nodes/parsenodes.h:3743
	Query           Node            // the SELECT query (as a raw parse tree) - postgres/src/include/nodes/parsenodes.h:3744
	Replace         bool            // replace an existing view? - postgres/src/include/nodes/parsenodes.h:3745
	Options         []*DefElem      // options from WITH clause - postgres/src/include/nodes/parsenodes.h:3746
	WithCheckOption ViewCheckOption // WITH CHECK OPTION - postgres/src/include/nodes/parsenodes.h:3747
}

// NewViewStmt creates a new ViewStmt node.
func NewViewStmt(view *RangeVar, query Node, replace bool) *ViewStmt {
	return &ViewStmt{
		BaseNode:        BaseNode{Tag: T_ViewStmt},
		View:            view,
		Query:           query,
		Replace:         replace,
		WithCheckOption: NO_CHECK_OPTION,
	}
}

func (v *ViewStmt) StatementType() string {
	return "ViewStmt"
}

func (v *ViewStmt) String() string {
	replace := ""
	if v.Replace {
		replace = " OR REPLACE"
	}
	return fmt.Sprintf("ViewStmt(%s%s)@%d", v.View.RelName, replace, v.Location())
}

// ==============================================================================
// DOMAIN STATEMENTS
// ==============================================================================

// AlterDomainStmt represents an ALTER DOMAIN statement.
// Ported from postgres/src/include/nodes/parsenodes.h:2461
type AlterDomainStmt struct {
	BaseNode
	Subtype   byte         // T/N/O/C/X for alter type - postgres/src/include/nodes/parsenodes.h:2463
	TypeName  []string     // domain to work on - postgres/src/include/nodes/parsenodes.h:2464
	Name      string       // column or constraint name to act on - postgres/src/include/nodes/parsenodes.h:2465
	Def       Node         // definition of default or constraint - postgres/src/include/nodes/parsenodes.h:2466
	Behavior  DropBehavior // RESTRICT or CASCADE for DROP cases - postgres/src/include/nodes/parsenodes.h:2467
	MissingOk bool         // skip error if missing? - postgres/src/include/nodes/parsenodes.h:2468
}

// NewAlterDomainStmt creates a new AlterDomainStmt node.
func NewAlterDomainStmt(subtype byte, typeName []string) *AlterDomainStmt {
	return &AlterDomainStmt{
		BaseNode: BaseNode{Tag: T_AlterDomainStmt},
		Subtype:  subtype,
		TypeName: typeName,
		Behavior: DropRestrict,
	}
}

func (a *AlterDomainStmt) StatementType() string {
	return "AlterDomainStmt"
}

func (a *AlterDomainStmt) String() string {
	domainName := ""
	if len(a.TypeName) > 0 {
		domainName = a.TypeName[len(a.TypeName)-1] // last part is the domain name
	}
	return fmt.Sprintf("AlterDomainStmt(%s)@%d", domainName, a.Location())
}

// CreateDomainStmt represents a CREATE DOMAIN statement.
// Ported from postgres/src/include/nodes/parsenodes.h:3156
type CreateDomainStmt struct {
	BaseNode
	Domainname  []string       // qualified name (list of String) - postgres/src/include/nodes/parsenodes.h:3158
	TypeName    *TypeName      // the base type - postgres/src/include/nodes/parsenodes.h:3159
	CollClause  *CollateClause // untransformed COLLATE spec, if any - postgres/src/include/nodes/parsenodes.h:3160
	Constraints []*Constraint  // constraints (list of Constraint nodes) - postgres/src/include/nodes/parsenodes.h:3161
}

// NewCreateDomainStmt creates a new CreateDomainStmt node.
func NewCreateDomainStmt(domainname []string, typeName *TypeName) *CreateDomainStmt {
	return &CreateDomainStmt{
		BaseNode:   BaseNode{Tag: T_CreateDomainStmt},
		Domainname: domainname,
		TypeName:   typeName,
	}
}

func (c *CreateDomainStmt) StatementType() string {
	return "CreateDomainStmt"
}

func (c *CreateDomainStmt) String() string {
	domainName := ""
	if len(c.Domainname) > 0 {
		domainName = c.Domainname[len(c.Domainname)-1]
	}
	return fmt.Sprintf("CreateDomainStmt(%s)@%d", domainName, c.Location())
}

// ==============================================================================
// SCHEMA STATEMENTS
// ==============================================================================

// CreateSchemaStmt represents a CREATE SCHEMA statement.
// Ported from postgres/src/include/nodes/parsenodes.h:2320
type CreateSchemaStmt struct {
	BaseNode
	Schemaname  string    // the name of the schema to create - postgres/src/include/nodes/parsenodes.h:2322
	Authrole    *RoleSpec // the owner of the created schema - postgres/src/include/nodes/parsenodes.h:2323
	SchemaElts  *NodeList // schema components (list of parsenodes) - postgres/src/include/nodes/parsenodes.h:2324
	IfNotExists bool      // just do nothing if schema already exists? - postgres/src/include/nodes/parsenodes.h:2325
}

// NewCreateSchemaStmt creates a new CreateSchemaStmt node.
func NewCreateSchemaStmt(schemaname string, ifNotExists bool) *CreateSchemaStmt {
	return &CreateSchemaStmt{
		BaseNode:    BaseNode{Tag: T_CreateSchemaStmt},
		Schemaname:  schemaname,
		IfNotExists: ifNotExists,
	}
}

func (c *CreateSchemaStmt) StatementType() string {
	return "CreateSchemaStmt"
}

func (c *CreateSchemaStmt) String() string {
	ifNotExists := ""
	if c.IfNotExists {
		ifNotExists = " IF NOT EXISTS"
	}
	return fmt.Sprintf("CreateSchemaStmt(%s%s)@%d", c.Schemaname, ifNotExists, c.Location())
}

// ==============================================================================
// EXTENSION STATEMENTS
// ==============================================================================

// CreateExtensionStmt represents a CREATE EXTENSION statement.
// Ported from postgres/src/include/nodes/parsenodes.h:2819
type CreateExtensionStmt struct {
	BaseNode
	Extname     string     // extension name - postgres/src/include/nodes/parsenodes.h:2821
	IfNotExists bool       // just do nothing if it already exists? - postgres/src/include/nodes/parsenodes.h:2822
	Options     []*DefElem // List of DefElem nodes - postgres/src/include/nodes/parsenodes.h:2823
}

// NewCreateExtensionStmt creates a new CreateExtensionStmt node.
func NewCreateExtensionStmt(extname string, ifNotExists bool) *CreateExtensionStmt {
	return &CreateExtensionStmt{
		BaseNode:    BaseNode{Tag: T_CreateExtensionStmt},
		Extname:     extname,
		IfNotExists: ifNotExists,
	}
}

func (c *CreateExtensionStmt) StatementType() string {
	return "CreateExtensionStmt"
}

func (c *CreateExtensionStmt) String() string {
	ifNotExists := ""
	if c.IfNotExists {
		ifNotExists = " IF NOT EXISTS"
	}
	return fmt.Sprintf("CreateExtensionStmt(%s%s)@%d", c.Extname, ifNotExists, c.Location())
}

// ==============================================================================
// DDL CONVENIENCE CONSTRUCTORS
// ==============================================================================

// NewPrimaryKeyConstraint creates a PRIMARY KEY constraint.
func NewPrimaryKeyConstraint(conname string, keys []string) *Constraint {
	constraint := NewConstraint(CONSTR_PRIMARY)
	constraint.Conname = conname
	constraint.Keys = stringsToNodeList(keys)
	return constraint
}

// NewForeignKeyConstraint creates a FOREIGN KEY constraint.
func NewForeignKeyConstraint(conname string, fkAttrs []string, pktable *RangeVar, pkAttrs []string) *Constraint {
	constraint := NewConstraint(CONSTR_FOREIGN)
	constraint.Conname = conname
	constraint.FkAttrs = stringsToNodeList(fkAttrs)
	constraint.Pktable = pktable
	constraint.PkAttrs = stringsToNodeList(pkAttrs)
	return constraint
}

// NewUniqueConstraint creates a UNIQUE constraint.
func NewUniqueConstraint(conname string, keys []string) *Constraint {
	constraint := NewConstraint(CONSTR_UNIQUE)
	constraint.Conname = conname
	constraint.Keys = stringsToNodeList(keys)
	return constraint
}

// NewUniqueConstraintNullsNotDistinct creates a UNIQUE constraint with NULLS NOT DISTINCT.
func NewUniqueConstraintNullsNotDistinct(conname string, keys []string) *Constraint {
	constraint := NewConstraint(CONSTR_UNIQUE)
	constraint.Conname = conname
	constraint.Keys = stringsToNodeList(keys)
	constraint.NullsNotDistinct = true
	return constraint
}

// NewCheckConstraint creates a CHECK constraint.
func NewCheckConstraint(conname string, rawExpr Node) *Constraint {
	constraint := NewConstraint(CONSTR_CHECK)
	constraint.Conname = conname
	constraint.RawExpr = rawExpr
	return constraint
}

// NewNotNullConstraint creates a NOT NULL constraint.
func NewNotNullConstraint(conname string) *Constraint {
	constraint := NewConstraint(CONSTR_NOTNULL)
	constraint.Conname = conname
	return constraint
}

// NewAddColumnCmd creates an ALTER TABLE ADD COLUMN command.
func NewAddColumnCmd(columnName string, columnDef Node) *AlterTableCmd {
	return NewAlterTableCmd(AT_AddColumn, columnName, columnDef)
}

// NewDropColumnCmd creates an ALTER TABLE DROP COLUMN command.
func NewDropColumnCmd(columnName string, behavior DropBehavior) *AlterTableCmd {
	cmd := NewAlterTableCmd(AT_DropColumn, columnName, nil)
	cmd.Behavior = behavior
	return cmd
}

// NewAddConstraintCmd creates an ALTER TABLE ADD CONSTRAINT command.
func NewAddConstraintCmd(constraint *Constraint) *AlterTableCmd {
	return NewAlterTableCmd(AT_AddConstraint, constraint.Conname, constraint)
}

// NewDropConstraintCmd creates an ALTER TABLE DROP CONSTRAINT command.
func NewDropConstraintCmd(constraintName string, behavior DropBehavior) *AlterTableCmd {
	cmd := NewAlterTableCmd(AT_DropConstraint, constraintName, nil)
	cmd.Behavior = behavior
	return cmd
}

// NewUniqueIndex creates a unique index statement.
func NewUniqueIndex(idxname string, relation *RangeVar, indexParams *NodeList) *IndexStmt {
	idx := NewIndexStmt(idxname, relation, indexParams)
	idx.Unique = true
	return idx
}

// NewBtreeIndexElem creates a B-tree index element with default ordering.
func NewBtreeIndexElem(columnName string) *IndexElem {
	return NewIndexElem(columnName)
}

// NewDescIndexElem creates a descending index element.
func NewDescIndexElem(columnName string) *IndexElem {
	elem := NewIndexElem(columnName)
	elem.Ordering = SORTBY_DESC
	return elem
}

// NewExpressionIndexElem creates an index element on an expression.
func NewExpressionIndexElem(expr Node) *IndexElem {
	elem := &IndexElem{
		BaseNode:      BaseNode{Tag: T_IndexElem},
		Expr:          expr,
		Ordering:      SORTBY_DEFAULT,
		NullsOrdering: SORTBY_NULLS_DEFAULT,
	}
	return elem
}

// SqlString returns the SQL representation of CREATE INDEX statement
func (i *IndexStmt) SqlString() string {
	var parts []string

	parts = append(parts, "CREATE")

	// Add UNIQUE if specified
	if i.Unique {
		parts = append(parts, "UNIQUE")
	}

	parts = append(parts, "INDEX")

	// Add CONCURRENTLY if specified
	if i.Concurrent {
		parts = append(parts, "CONCURRENTLY")
	}

	// Add IF NOT EXISTS if specified
	if i.IfNotExists {
		parts = append(parts, "IF NOT EXISTS")
	}

	// Add index name
	if i.Idxname != "" {
		parts = append(parts, i.Idxname)
	}

	// Add ON table
	parts = append(parts, "ON")
	if i.Relation != nil {
		parts = append(parts, i.Relation.SqlString())
	}

	// Add access method if specified and not default
	if i.AccessMethod != "" && i.AccessMethod != "btree" {
		parts = append(parts, "USING", i.AccessMethod)
	}

	// Add index columns
	if i.IndexParams != nil && i.IndexParams.Len() > 0 {
		var columnParts []string
		for _, item := range i.IndexParams.Items {
			if param, ok := item.(*IndexElem); ok && param != nil {
				columnParts = append(columnParts, param.SqlString())
			}
		}
		parts = append(parts, "("+strings.Join(columnParts, ", ")+")")
	}

	// Add INCLUDE columns if specified
	if i.IndexIncludingParams != nil && i.IndexIncludingParams.Len() > 0 {
		var includeParts []string
		for _, item := range i.IndexIncludingParams.Items {
			if param, ok := item.(*IndexElem); ok && param != nil {
				includeParts = append(includeParts, param.SqlString())
			}
		}
		parts = append(parts, "INCLUDE", "("+strings.Join(includeParts, ", ")+")")
	}

	// Add NULLS NOT DISTINCT if specified
	if i.NullsNotDistinct {
		parts = append(parts, "NULLS NOT DISTINCT")
	}

	// Add WITH options if specified
	if i.Options != nil && i.Options.Len() > 0 {
		var optParts []string
		for _, item := range i.Options.Items {
			if opt, ok := item.(*DefElem); ok && opt != nil {
				optParts = append(optParts, opt.SqlString())
			}
		}
		if len(optParts) > 0 {
			parts = append(parts, "WITH", "("+strings.Join(optParts, ", ")+")")
		}
	}

	// Add tablespace if specified
	if i.TableSpace != "" {
		parts = append(parts, "TABLESPACE", i.TableSpace)
	}

	// Add WHERE clause if specified
	if i.WhereClause != nil {
		parts = append(parts, "WHERE", i.WhereClause.SqlString())
	}

	return strings.Join(parts, " ")
}
