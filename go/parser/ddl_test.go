package parser

import (
	"strings"
	"testing"

	"github.com/multigres/parser/go/parser/ast"
	"github.com/stretchr/testify/require"
)

// TestDDLParsing tests both parsing and deparsing of DDL statements
func TestDDLParsing(t *testing.T) {
	tests := []struct {
		name     string
		sql      string
		expected string // If empty, expects exact match with input
	}{
		// CREATE TABLE tests
		{
			name: "Simple CREATE TABLE",
			sql:  "CREATE TABLE users (id int, name varchar(100))",
		},
		{
			name: "CREATE TABLE with PRIMARY KEY",
			sql:  "CREATE TABLE users (id int PRIMARY KEY, name varchar(100))",
		},
		{
			name: "CREATE TABLE with NOT NULL",
			sql:  "CREATE TABLE users (id int NOT NULL, name varchar(100) NOT NULL)",
		},
		{
			name: "CREATE TABLE with DEFAULT",
			sql:  "CREATE TABLE users (id int DEFAULT 0, created_at timestamp DEFAULT NOW())",
		},
		{
			name: "CREATE TABLE with UNIQUE constraint",
			sql:  "CREATE TABLE users (id int, email varchar(100) UNIQUE)",
		},
		{
			name: "CREATE TABLE with CHECK constraint",
			sql:  "CREATE TABLE users (id int, age int CHECK (age > 0))",
		},
		{
			name: "CREATE TABLE with table-level PRIMARY KEY",
			sql:  "CREATE TABLE users (id int, name varchar(100), PRIMARY KEY (id))",
		},
		{
			name: "CREATE TABLE with FOREIGN KEY",
			sql:  "CREATE TABLE orders (id int, user_id int REFERENCES users(id))",
		},
		{
			name: "CREATE TABLE IF NOT EXISTS",
			sql:  "CREATE TABLE IF NOT EXISTS users (id int, name varchar(100))",
		},
		{
			name: "CREATE TABLE with multiple constraints",
			sql:  "CREATE TABLE users (id int PRIMARY KEY, email varchar(100) UNIQUE NOT NULL, age int CHECK (age > 0))",
		},

		// Temporary table creation tests (OptTempTableName)
		{
			name: "CREATE TEMPORARY TABLE",
			sql:  "CREATE TEMPORARY TABLE temp_users (id int, name varchar(100))",
		},
		{
			name:     "CREATE TEMP TABLE",
			sql:      "CREATE TEMP TABLE temp_users (id int, name varchar(100))",
			expected: "CREATE TEMPORARY TABLE temp_users (id int, name varchar(100))",
		},
		{
			name:     "CREATE LOCAL TEMPORARY TABLE",
			sql:      "CREATE LOCAL TEMPORARY TABLE temp_users (id int, name varchar(100))",
			expected: "CREATE TEMPORARY TABLE temp_users (id int, name varchar(100))",
		},
		{
			name:     "CREATE LOCAL TEMP TABLE",
			sql:      "CREATE LOCAL TEMP TABLE temp_users (id int, name varchar(100))",
			expected: "CREATE TEMPORARY TABLE temp_users (id int, name varchar(100))",
		},
		{
			name:     "CREATE GLOBAL TEMPORARY TABLE",
			sql:      "CREATE GLOBAL TEMPORARY TABLE temp_users (id int, name varchar(100))",
			expected: "CREATE TEMPORARY TABLE temp_users (id int, name varchar(100))",
		},
		{
			name:     "CREATE GLOBAL TEMP TABLE",
			sql:      "CREATE GLOBAL TEMP TABLE temp_users (id int, name varchar(100))",
			expected: "CREATE TEMPORARY TABLE temp_users (id int, name varchar(100))",
		},
		{
			name: "CREATE UNLOGGED TABLE",
			sql:  "CREATE UNLOGGED TABLE unlogged_users (id int, name varchar(100))",
		},

		// CREATE INDEX tests
		{
			name: "Simple CREATE INDEX",
			sql:  "CREATE INDEX idx_users_name ON users (name)",
		},
		{
			name: "CREATE UNIQUE INDEX",
			sql:  "CREATE UNIQUE INDEX idx_users_email ON users (email)",
		},
		{
			name: "CREATE INDEX with multiple columns",
			sql:  "CREATE INDEX idx_users_name_email ON users (name, email)",
		},
		{
			name: "CREATE INDEX CONCURRENTLY",
			sql:  "CREATE INDEX CONCURRENTLY idx_users_name ON users (name)",
		},
		{
			name: "CREATE INDEX IF NOT EXISTS",
			sql:  "CREATE INDEX IF NOT EXISTS idx_users_name ON users (name)",
		},
		{
			name: "CREATE INDEX with INCLUDE",
			sql:  "CREATE INDEX idx_users_name ON users (name) INCLUDE (email, created_at)",
		},

		// Note: CREATE SEQUENCE not implemented in Phase 3F

		// ALTER TABLE tests
		{
			name: "ALTER TABLE ADD COLUMN",
			sql:  "ALTER TABLE users ADD COLUMN age int",
		},
		{
			name: "ALTER TABLE DROP COLUMN",
			sql:  "ALTER TABLE users DROP COLUMN age",
		},
		{
			name: "ALTER TABLE ADD CONSTRAINT",
			sql:  "ALTER TABLE users ADD CONSTRAINT users_email_unique UNIQUE (email)",
		},
		{
			name: "ALTER TABLE DROP CONSTRAINT",
			sql:  "ALTER TABLE users DROP CONSTRAINT users_email_unique",
		},
		{
			name: "ALTER TABLE ALTER COLUMN SET DEFAULT",
			sql:  "ALTER TABLE users ALTER COLUMN age SET DEFAULT 0",
		},
		{
			name: "ALTER TABLE ALTER COLUMN DROP DEFAULT",
			sql:  "ALTER TABLE users ALTER COLUMN age DROP DEFAULT",
		},
		{
			name: "ALTER TABLE ALTER COLUMN SET NOT NULL",
			sql:  "ALTER TABLE users ALTER COLUMN email SET NOT NULL",
		},
		{
			name: "ALTER TABLE ALTER COLUMN DROP NOT NULL",
			sql:  "ALTER TABLE users ALTER COLUMN email DROP NOT NULL",
		},

		// Identity column option tests (alter_identity_column_option_list)
		{
			name: "ALTER TABLE ALTER COLUMN ADD GENERATED BY DEFAULT AS IDENTITY",
			sql:  "ALTER TABLE users ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY",
		},
		{
			name: "ALTER TABLE ALTER COLUMN ADD GENERATED ALWAYS AS IDENTITY",
			sql:  "ALTER TABLE users ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY",
		},

		// ALTER TABLE partition commands
		{
			name: "ALTER TABLE ATTACH PARTITION with default bound",
			sql:  "ALTER TABLE parent_table ATTACH PARTITION child_table DEFAULT",
		},
		{
			name: "ALTER TABLE ATTACH PARTITION with range bound",
			sql:  "ALTER TABLE parent_table ATTACH PARTITION child_table FOR VALUES FROM (1) TO (100)",
		},
		{
			name: "ALTER TABLE ATTACH PARTITION with list bound",
			sql:  "ALTER TABLE parent_table ATTACH PARTITION child_table FOR VALUES IN (1, 2, 3)",
		},
		{
			name: "ALTER TABLE DETACH PARTITION",
			sql:  "ALTER TABLE parent_table DETACH PARTITION child_table",
		},
		{
			name: "ALTER TABLE DETACH PARTITION CONCURRENTLY",
			sql:  "ALTER TABLE parent_table DETACH PARTITION child_table CONCURRENTLY",
		},
		{
			name: "ALTER TABLE DETACH PARTITION FINALIZE",
			sql:  "ALTER TABLE parent_table DETACH PARTITION child_table FINALIZE",
		},

		// ALTER INDEX partition commands
		{
			name: "ALTER INDEX ATTACH PARTITION",
			sql:  "ALTER INDEX parent_index ATTACH PARTITION child_index",
		},

		// DROP statements
		{
			name: "DROP TABLE",
			sql:  "DROP TABLE users",
		},
		{
			name: "DROP TABLE IF EXISTS",
			sql:  "DROP TABLE IF EXISTS users",
		},
		{
			name: "DROP TABLE CASCADE",
			sql:  "DROP TABLE users CASCADE",
		},
		{
			name: "DROP TABLE multiple",
			sql:  "DROP TABLE users, orders, products",
		},
		{
			name: "DROP INDEX",
			sql:  "DROP INDEX idx_users_name",
		},
		{
			name: "DROP INDEX IF EXISTS",
			sql:  "DROP INDEX IF EXISTS idx_users_name",
		},
		{
			name: "DROP INDEX CONCURRENTLY",
			sql:  "DROP INDEX CONCURRENTLY idx_users_name",
		},
		{
			name: "CREATE TABLE with FOREIGN KEY ON DELETE SET NULL",
			sql:  "CREATE TABLE test (id int REFERENCES parent(id) ON DELETE SET NULL)",
		},
		{
			name: "CREATE TABLE with FOREIGN KEY ON DELETE SET NULL with column list",
			sql:  "CREATE TABLE test (id int REFERENCES parent(id) ON DELETE SET NULL (id))",
		},
		{
			name: "CREATE TABLE with FOREIGN KEY ON DELETE SET DEFAULT with column list",
			sql:  "CREATE TABLE test (id int REFERENCES parent(id) ON DELETE SET DEFAULT (id))",
		},
		{
			name: "CREATE TABLE with FOREIGN KEY ON DELETE CASCADE",
			sql:  "CREATE TABLE test (id int REFERENCES parent(id) ON DELETE CASCADE)",
		},
		{
			name: "CREATE TABLE with FOREIGN KEY ON UPDATE RESTRICT",
			sql:  "CREATE TABLE test (id int REFERENCES parent(id) ON UPDATE RESTRICT)",
		},
		{
			name: "CREATE TABLE basic round-trip",
			sql:  "CREATE TABLE users (id int, name varchar(100))",
		},
		{
			name: "CREATE TABLE IF NOT EXISTS round-trip",
			sql:  "CREATE TABLE IF NOT EXISTS users (id int, name varchar(100))",
		},
		{
			name: "CREATE TABLE with PRIMARY KEY round-trip",
			sql:  "CREATE TABLE users (id int PRIMARY KEY, name varchar(100))",
		},
		{
			name: "CREATE TABLE with NOT NULL round-trip",
			sql:  "CREATE TABLE users (id int NOT NULL, name varchar(100) NOT NULL)",
		},
		{
			name: "CREATE TABLE with DEFAULT values round-trip",
			sql:  "CREATE TABLE users (id int DEFAULT 0, created_at timestamp DEFAULT NOW())",
		},
		{
			name: "CREATE TABLE with UNIQUE constraint round-trip",
			sql:  "CREATE TABLE users (id int, email varchar(100) UNIQUE)",
		},
		{
			name: "CREATE TABLE with CHECK constraint round-trip",
			sql:  "CREATE TABLE users (id int, age int CHECK ((age > 0)))",
		},
		{
			name: "CREATE TABLE with table-level PRIMARY KEY round-trip",
			sql:  "CREATE TABLE users (id int, name varchar(100), PRIMARY KEY (id))",
		},
		{
			name: "CREATE TABLE with FOREIGN KEY round-trip",
			sql:  "CREATE TABLE orders (id int, user_id int REFERENCES users(id))",
		},
		{
			name: "CREATE TABLE with multiple constraints round-trip",
			sql:  "CREATE TABLE users (id int PRIMARY KEY, email varchar(100) UNIQUE NOT NULL, age int CHECK ((age > 0)))",
		},

		// Phase 3F CREATE INDEX Tests
		{
			name: "CREATE INDEX basic round-trip",
			sql:  "CREATE INDEX idx_users_name ON users (name)",
		},
		{
			name: "CREATE UNIQUE INDEX round-trip",
			sql:  "CREATE UNIQUE INDEX idx_users_email ON users (email)",
		},
		{
			name: "CREATE INDEX with multiple columns round-trip",
			sql:  "CREATE INDEX idx_users_name_email ON users (name, email)",
		},
		{
			name: "CREATE INDEX CONCURRENTLY round-trip",
			sql:  "CREATE INDEX CONCURRENTLY idx_users_name ON users (name)",
		},
		{
			name: "CREATE INDEX IF NOT EXISTS round-trip",
			sql:  "CREATE INDEX IF NOT EXISTS idx_users_name ON users (name)",
		},
		{
			name: "CREATE INDEX with WHERE clause round-trip",
			sql:  "CREATE INDEX idx_active_users ON users (name) WHERE (active = TRUE)",
		},

		// Phase 3F ALTER TABLE Tests
		{
			name: "ALTER TABLE ADD COLUMN round-trip",
			sql:  "ALTER TABLE users ADD COLUMN age int",
		},
		{
			name: "ALTER TABLE DROP COLUMN round-trip",
			sql:  "ALTER TABLE users DROP COLUMN age",
		},
		{
			name: "ALTER TABLE ADD CONSTRAINT round-trip",
			sql:  "ALTER TABLE users ADD CONSTRAINT users_email_unique UNIQUE (email)",
		},
		{
			name: "ALTER TABLE DROP CONSTRAINT round-trip",
			sql:  "ALTER TABLE users DROP CONSTRAINT users_email_unique",
		},
		{
			name: "ALTER TABLE IF EXISTS round-trip",
			sql:  "ALTER TABLE IF EXISTS users ADD COLUMN age int",
		},

		// Phase 3F DROP Statement Tests
		{
			name: "DROP TABLE basic round-trip",
			sql:  "DROP TABLE users",
		},
		{
			name: "DROP TABLE IF EXISTS round-trip",
			sql:  "DROP TABLE IF EXISTS users",
		},
		{
			name: "DROP TABLE CASCADE round-trip",
			sql:  "DROP TABLE users CASCADE",
		},
		{
			name:     "DROP TABLE RESTRICT round-trip",
			sql:      "DROP TABLE users RESTRICT",
			expected: "DROP TABLE users",
		},
		{
			name: "DROP INDEX basic round-trip",
			sql:  "DROP INDEX idx_users_name",
		},
		{
			name: "DROP INDEX IF EXISTS round-trip",
			sql:  "DROP INDEX IF EXISTS idx_users_name",
		},
		{
			name: "DROP INDEX CONCURRENTLY round-trip",
			sql:  "DROP INDEX CONCURRENTLY idx_users_name",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Test parsing
			stmts, err := ParseSQL(tt.sql)
			require.NoError(t, err, "Failed to parse %s", tt.name)
			require.Len(t, stmts, 1, "Expected exactly one statement")
			require.NotNil(t, stmts[0], "Statement should not be nil")

			// Test deparsing
			deparsed := stmts[0].SqlString()

			// Determine expected output
			expected := tt.expected
			if expected == "" {
				expected = tt.sql
			}

			// Normalize whitespace for comparison
			deparsedNorm := strings.Join(strings.Fields(deparsed), " ")
			expectedNorm := strings.Join(strings.Fields(expected), " ")

			// Assert that deparsed SQL matches expected
			require.Equal(t, expectedNorm, deparsedNorm,
				"Deparsed SQL should match expected.\nOriginal: %s\nExpected: %s\nDeparsed: %s",
				tt.sql, expected, deparsed)

			// Test round-trip parsing - must succeed
			reparsedStmts, err := ParseSQL(deparsed)
			require.NoError(t, err, "Round-trip parsing should succeed for %s: %s", tt.name, deparsed)
			require.Len(t, reparsedStmts, 1, "Should have exactly one statement after reparse for %s", tt.name)

			// Verify stability - deparsing again should produce the same result
			redeparsed := reparsedStmts[0].SqlString()
			redeparsedNorm := strings.Join(strings.Fields(redeparsed), " ")

			require.Equal(t, deparsedNorm, redeparsedNorm,
				"Deparsing should be stable for %s.\nFirst: %s\nSecond: %s", tt.name, deparsed, redeparsed)
		})
	}
}

// TestDDLSqlStringMethods tests SqlString methods directly on DDL AST nodes
// These tests verify that SqlString methods work correctly on manually constructed AST nodes
func TestDDLSqlStringMethods(t *testing.T) {
	t.Run("CreateStmt SqlString", func(t *testing.T) {
		// Create a simple CREATE TABLE statement node
		relation := ast.NewRangeVar("users", "", "")
		createStmt := ast.NewCreateStmt(relation)

		// Add a column
		colDef := ast.NewColumnDef("id", ast.NewTypeName([]string{"int"}), 0)
		createStmt.TableElts = &ast.NodeList{
			Items: []ast.Node{
				colDef,
			},
		}

		sqlString := createStmt.SqlString()
		require.Contains(t, sqlString, "CREATE TABLE users")
		require.Contains(t, sqlString, "(id int)")

		t.Logf("CreateStmt SqlString: %s", sqlString)
	})

	t.Run("IndexStmt SqlString", func(t *testing.T) {
		// Create a simple CREATE INDEX statement node
		relation := ast.NewRangeVar("users", "", "")
		indexParams := ast.NewNodeList()
		indexParams.Append(ast.NewIndexElem("name"))
		indexStmt := ast.NewIndexStmt("idx_users_name", relation, indexParams)

		sqlString := indexStmt.SqlString()
		require.Contains(t, sqlString, "CREATE INDEX idx_users_name ON users")
		require.Contains(t, sqlString, "(name)")

		t.Logf("IndexStmt SqlString: %s", sqlString)
	})

	t.Run("DropStmt SqlString", func(t *testing.T) {
		// Create a simple DROP TABLE statement node
		dropStmt := &ast.DropStmt{
			BaseNode:   ast.BaseNode{Tag: ast.T_DropStmt},
			RemoveType: ast.OBJECT_TABLE,
			Objects:    ast.NewNodeList(),
			Behavior:   ast.DropRestrict,
			MissingOk:  false,
		}

		// Add table name
		dropStmt.Objects.Append(ast.NewString("users"))

		sqlString := dropStmt.SqlString()
		require.Contains(t, sqlString, "DROP TABLE users")

		t.Logf("DropStmt SqlString: %s", sqlString)
	})

	t.Run("Constraint SqlString", func(t *testing.T) {
		// Test PRIMARY KEY constraint
		pkConstraint := ast.NewConstraint(ast.CONSTR_PRIMARY)
		pkConstraint.Keys = ast.NewNodeList(ast.NewString("id"))

		sqlString := pkConstraint.SqlString()
		require.Equal(t, "PRIMARY KEY (id)", sqlString)

		// Test UNIQUE constraint
		uniqueConstraint := ast.NewConstraint(ast.CONSTR_UNIQUE)
		uniqueConstraint.Keys = ast.NewNodeList(ast.NewString("email"))

		sqlString2 := uniqueConstraint.SqlString()
		require.Equal(t, "UNIQUE (email)", sqlString2)

		t.Logf("PRIMARY KEY SqlString: %s", sqlString)
		t.Logf("UNIQUE SqlString: %s", sqlString2)
	})
}

// TestKeyActionsSetNullWithColumnList tests SET NULL with optional column list
func TestKeyActionsSetNullWithColumnList(t *testing.T) {
	tests := []struct {
		name   string
		input  string
		hasCol bool
	}{
		{
			name:   "SET NULL without column list",
			input:  "CREATE TABLE test (id int REFERENCES parent(id) ON DELETE SET NULL);",
			hasCol: false,
		},
		{
			name:   "SET NULL with column list",
			input:  "CREATE TABLE test (id int REFERENCES parent(id) ON DELETE SET NULL (id));",
			hasCol: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			stmts, err := ParseSQL(tt.input)
			require.NoError(t, err)
			require.Len(t, stmts, 1)

			createStmt, ok := stmts[0].(*ast.CreateStmt)
			require.True(t, ok)
			require.NotNil(t, createStmt.TableElts)
			require.Len(t, createStmt.TableElts.Items, 1)

			colDef := createStmt.TableElts.Items[0].(*ast.ColumnDef)
			require.NotNil(t, colDef.Constraints)
			require.Len(t, colDef.Constraints.Items, 1)

			constraint, ok := colDef.Constraints.Items[0].(*ast.Constraint)
			require.True(t, ok)
			require.Equal(t, ast.CONSTR_FOREIGN, constraint.Contype)
			require.Equal(t, ast.FKCONSTR_ACTION_SETNULL, constraint.FkDelAction)

			// The actual KeyActions struct should contain the column information
			// but for now we're testing that it parses without error
		})
	}
}

// TestKeyActionsSetDefaultWithColumnList tests SET DEFAULT with optional column list
func TestKeyActionsSetDefaultWithColumnList(t *testing.T) {
	input := "CREATE TABLE test (id int REFERENCES parent(id) ON DELETE SET DEFAULT (id));"

	stmts, err := ParseSQL(input)
	require.NoError(t, err)
	require.Len(t, stmts, 1)

	createStmt, ok := stmts[0].(*ast.CreateStmt)
	require.True(t, ok)
	require.NotNil(t, createStmt.TableElts)
	require.Len(t, createStmt.TableElts.Items, 1)

	colDef := createStmt.TableElts.Items[0].(*ast.ColumnDef)
	require.NotNil(t, colDef.Constraints)
	require.Len(t, colDef.Constraints.Items, 1)

	constraint, ok := colDef.Constraints.Items[0].(*ast.Constraint)
	require.True(t, ok)
	require.Equal(t, ast.CONSTR_FOREIGN, constraint.Contype)
	require.Equal(t, ast.FKCONSTR_ACTION_SETDEFAULT, constraint.FkDelAction)
}

// TestKeyActionsUpdateRestriction tests that UPDATE actions don't allow column lists
func TestKeyActionsUpdateRestriction(t *testing.T) {
	// This should cause a parser error since column lists are not supported for UPDATE actions
	input := "CREATE TABLE test (id int REFERENCES parent(id) ON UPDATE SET NULL (id));"

	_, err := ParseSQL(input)
	// We expect an error here since UPDATE with column list should not be supported
	require.Error(t, err)
}
