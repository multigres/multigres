[
  {
    "comment": "select_parallel - Statement 1",
    "query": "create function sp_parallel_restricted(int) returns int as $$begin return $1; end$$ language plpgsql parallel restricted"
  },
  {
    "comment": "select_parallel - Statement 2",
    "query": "begin"
  },
  {
    "comment": "select_parallel - Statement 3",
    "query": "set parallel_setup_cost=0"
  },
  {
    "comment": "select_parallel - Statement 4",
    "query": "set parallel_tuple_cost=0"
  },
  {
    "comment": "select_parallel - Statement 5",
    "query": "set min_parallel_table_scan_size=0"
  },
  {
    "comment": "select_parallel - Statement 6",
    "query": "set max_parallel_workers_per_gather=4"
  },
  {
    "comment": "select_parallel - Statement 7",
    "query": "explain (costs off) select round(avg(aa)), sum(aa) from a_star"
  },
  {
    "comment": "select_parallel - Statement 8",
    "query": "select round(avg(aa)), sum(aa) from a_star a1"
  },
  {
    "comment": "select_parallel - Statement 9",
    "query": "alter table c_star set (parallel_workers = 0)"
  },
  {
    "comment": "select_parallel - Statement 10",
    "query": "alter table d_star set (parallel_workers = 0)"
  },
  {
    "comment": "select_parallel - Statement 11",
    "query": "select round(avg(aa)), sum(aa) from a_star a2"
  },
  {
    "comment": "select_parallel - Statement 12",
    "query": "alter table a_star set (parallel_workers = 0)"
  },
  {
    "comment": "select_parallel - Statement 13",
    "query": "alter table b_star set (parallel_workers = 0)"
  },
  {
    "comment": "select_parallel - Statement 14",
    "query": "alter table e_star set (parallel_workers = 0)"
  },
  {
    "comment": "select_parallel - Statement 15",
    "query": "alter table f_star set (parallel_workers = 0)"
  },
  {
    "comment": "select_parallel - Statement 16",
    "query": "select round(avg(aa)), sum(aa) from a_star a3"
  },
  {
    "comment": "select_parallel - Statement 17",
    "query": "alter table a_star reset (parallel_workers)"
  },
  {
    "comment": "select_parallel - Statement 18",
    "query": "alter table b_star reset (parallel_workers)"
  },
  {
    "comment": "select_parallel - Statement 19",
    "query": "alter table c_star reset (parallel_workers)"
  },
  {
    "comment": "select_parallel - Statement 20",
    "query": "alter table d_star reset (parallel_workers)"
  },
  {
    "comment": "select_parallel - Statement 21",
    "query": "alter table e_star reset (parallel_workers)"
  },
  {
    "comment": "select_parallel - Statement 22",
    "query": "alter table f_star reset (parallel_workers)"
  },
  {
    "comment": "select_parallel - Statement 23",
    "query": "set enable_parallel_append to off"
  },
  {
    "comment": "select_parallel - Statement 24",
    "query": "select round(avg(aa)), sum(aa) from a_star a4"
  },
  {
    "comment": "select_parallel - Statement 25",
    "query": "reset enable_parallel_append"
  },
  {
    "comment": "select_parallel - Statement 26",
    "query": "create function sp_test_func() returns setof text as $$ select 'foo'::varchar union all select 'bar'::varchar $$ language sql stable; select sp_test_func() order by 1;   create table part_pa_test(a int, b int) partition by range(a); create table part_pa_test_p1 partition of part_pa_test for values from (minvalue) to (0); create table part_pa_test_p2 partition of part_pa_test for values from (0) to (maxvalue); explain (costs off) select (select max((select pa1.b from part_pa_test pa1 where pa1.a = pa2.a))) from part_pa_test pa2; drop table part_pa_test;   set parallel_leader_participation = off; explain (costs off) select count(*) from tenk1 where stringu1 = 'GRAAAA'; select count(*) from tenk1 where stringu1 = 'GRAAAA';    set max_parallel_workers = 0; explain (costs off) select count(*) from tenk1 where stringu1 = 'GRAAAA'; select count(*) from tenk1 where stringu1 = 'GRAAAA';  reset max_parallel_workers; reset parallel_leader_participation;   alter table tenk1 set (parallel_workers = 4); explain (verbose, costs off) select sp_parallel_restricted(unique1) from tenk1 where stringu1 = 'GRAAAA' order by 1;   explain (costs off) select length(stringu1) from tenk1 group by length(stringu1); select length(stringu1) from tenk1 group by length(stringu1);  explain (costs off) select stringu1, count(*) from tenk1 group by stringu1 order by stringu1;    explain (costs off) select  sum(sp_parallel_restricted(unique1)) from tenk1 group by(sp_parallel_restricted(unique1));   prepare tenk1_count(integer) As select  count((unique1)) from tenk1 where hundred > $1; explain (costs off) execute tenk1_count(1); execute tenk1_count(1); deallocate tenk1_count;   alter table tenk2 set (parallel_workers = 0); explain (costs off) select count(*) from tenk1 where (two, four) not in (select hundred, thousand from tenk2 where thousand > 100); select count(*) from tenk1 where (two, four) not in (select hundred, thousand from tenk2 where thousand > 100);  explain (costs off) select * from tenk1 where (unique1 + random())::integer not in (select ten from tenk2); alter table tenk2 reset (parallel_workers);   set enable_indexscan = off; set enable_indexonlyscan = off; set enable_bitmapscan = off; alter table tenk2 set (parallel_workers = 2);  explain (costs off) select count(*) from tenk1 where tenk1.unique1 = (Select max(tenk2.unique1) from tenk2); select count(*) from tenk1 where tenk1.unique1 = (Select max(tenk2.unique1) from tenk2);  reset enable_indexscan; reset enable_indexonlyscan; reset enable_bitmapscan; alter table tenk2 reset (parallel_workers);   set enable_seqscan to off; set enable_bitmapscan to off; set random_page_cost = 2;  explain (costs off) select  count((unique1)) from tenk1 where hundred > 1; select  count((unique1)) from tenk1 where hundred > 1;   explain (costs off) select count((unique1)) from tenk1 where hundred = any ((select array_agg(i) from generate_series(1, 100, 15) i)::int[]); select count((unique1)) from tenk1 where hundred = any ((select array_agg(i) from generate_series(1, 100, 15) i)::int[]);   explain (costs off) select  count(*) from tenk1 where thousand > 95; select  count(*) from tenk1 where thousand > 95;   set enable_material = false;  explain (costs off) select * from (select count(unique1) from tenk1 where hundred > 10) ss right join (values (1),(2),(3)) v(x) on true; select * from (select count(unique1) from tenk1 where hundred > 10) ss right join (values (1),(2),(3)) v(x) on true;  explain (costs off) select * from (select count(*) from tenk1 where thousand > 99) ss right join (values (1),(2),(3)) v(x) on true; select * from (select count(*) from tenk1 where thousand > 99) ss right join (values (1),(2),(3)) v(x) on true;   reset enable_seqscan; set enable_indexonlyscan to off; set enable_indexscan to off; alter table tenk1 set (parallel_workers = 0); alter table tenk2 set (parallel_workers = 1); explain (costs off) select count(*) from tenk1 left join (select tenk2.unique1 from tenk2 order by 1 limit 1000) ss on tenk1.unique1 < ss.unique1 + 1 where tenk1.unique1 < 2; select count(*) from tenk1 left join (select tenk2.unique1 from tenk2 order by 1 limit 1000) ss on tenk1.unique1 < ss.unique1 + 1 where tenk1.unique1 < 2;  alter table tenk1 set (parallel_workers = 4); alter table tenk2 reset (parallel_workers);  reset enable_material; reset enable_bitmapscan; reset enable_indexonlyscan; reset enable_indexscan;   set enable_seqscan to off; set enable_indexscan to off; set enable_hashjoin to off; set enable_mergejoin to off; set enable_material to off;  DO $$ BEGIN SET effective_io_concurrency = 50; EXCEPTION WHEN invalid_parameter_value THEN END $$"
  },
  {
    "comment": "select_parallel - Statement 27",
    "query": "set work_mem='64kB'"
  },
  {
    "comment": "select_parallel - Statement 28",
    "query": "explain (costs off) select count(*) from tenk1, tenk2 where tenk1.hundred > 1 and tenk2.thousand=0"
  },
  {
    "comment": "select_parallel - Statement 29",
    "query": "select count(*) from tenk1, tenk2 where tenk1.hundred > 1 and tenk2.thousand=0"
  },
  {
    "comment": "select_parallel - Statement 30",
    "query": "create table bmscantest (a int, t text)"
  },
  {
    "comment": "select_parallel - Statement 31",
    "query": "insert into bmscantest select r, 'fooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo' FROM generate_series(1,100000) r"
  },
  {
    "comment": "select_parallel - Statement 32",
    "query": "create index i_bmtest ON bmscantest(a)"
  },
  {
    "comment": "select_parallel - Statement 33",
    "query": "select count(*) from bmscantest where a>1"
  },
  {
    "comment": "select_parallel - Statement 34",
    "query": "reset enable_seqscan"
  },
  {
    "comment": "select_parallel - Statement 35",
    "query": "alter table tenk2 set (parallel_workers = 0)"
  },
  {
    "comment": "select_parallel - Statement 36",
    "query": "explain (analyze, timing off, summary off, costs off) select count(*) from tenk1, tenk2 where tenk1.hundred > 1 and tenk2.thousand=0"
  },
  {
    "comment": "select_parallel - Statement 37",
    "query": "alter table tenk2 reset (parallel_workers)"
  },
  {
    "comment": "select_parallel - Statement 38",
    "query": "reset work_mem"
  },
  {
    "comment": "select_parallel - Statement 39",
    "query": "create function explain_parallel_sort_stats() returns setof text language plpgsql as $$ declare ln text; begin for ln in explain (analyze, timing off, summary off, costs off) select * from (select ten from tenk1 where ten < 100 order by ten) ss right join (values (1),(2),(3)) v(x) on true loop ln := regexp_replace(ln, 'Memory: \\S*',  'Memory: xxx'); return next ln; end loop; end; $$"
  },
  {
    "comment": "select_parallel - Statement 40",
    "query": "select * from explain_parallel_sort_stats()"
  },
  {
    "comment": "select_parallel - Statement 41",
    "query": "reset enable_indexscan"
  },
  {
    "comment": "select_parallel - Statement 42",
    "query": "reset enable_hashjoin"
  },
  {
    "comment": "select_parallel - Statement 43",
    "query": "reset enable_mergejoin"
  },
  {
    "comment": "select_parallel - Statement 44",
    "query": "reset enable_material"
  },
  {
    "comment": "select_parallel - Statement 45",
    "query": "reset effective_io_concurrency"
  },
  {
    "comment": "select_parallel - Statement 46",
    "query": "drop table bmscantest"
  },
  {
    "comment": "select_parallel - Statement 47",
    "query": "drop function explain_parallel_sort_stats()"
  },
  {
    "comment": "select_parallel - Statement 48",
    "query": "set enable_hashjoin to off"
  },
  {
    "comment": "select_parallel - Statement 49",
    "query": "set enable_nestloop to off"
  },
  {
    "comment": "select_parallel - Statement 50",
    "query": "explain (costs off) select  count(*) from tenk1, tenk2 where tenk1.unique1 = tenk2.unique1"
  },
  {
    "comment": "select_parallel - Statement 51",
    "query": "select  count(*) from tenk1, tenk2 where tenk1.unique1 = tenk2.unique1"
  },
  {
    "comment": "select_parallel - Statement 52",
    "query": "reset enable_nestloop"
  },
  {
    "comment": "select_parallel - Statement 53",
    "query": "set enable_hashagg = false"
  },
  {
    "comment": "select_parallel - Statement 54",
    "query": "explain (costs off) select count(*) from tenk1 group by twenty"
  },
  {
    "comment": "select_parallel - Statement 55",
    "query": "select count(*) from tenk1 group by twenty"
  },
  {
    "comment": "select_parallel - Statement 56",
    "query": "create function sp_simple_func(var1 integer) returns integer as $$ begin return var1 + 10; end; $$ language plpgsql PARALLEL SAFE"
  },
  {
    "comment": "select_parallel - Statement 57",
    "query": "explain (costs off, verbose) select ten, sp_simple_func(ten) from tenk1 where ten < 100 order by ten"
  },
  {
    "comment": "select_parallel - Statement 58",
    "query": "drop function sp_simple_func(integer)"
  },
  {
    "comment": "select_parallel - Statement 59",
    "query": "explain (costs off) select count(*), generate_series(1,2) from tenk1 group by twenty"
  },
  {
    "comment": "select_parallel - Statement 60",
    "query": "select count(*), generate_series(1,2) from tenk1 group by twenty"
  },
  {
    "comment": "select_parallel - Statement 61",
    "query": "set parallel_leader_participation = off"
  },
  {
    "comment": "select_parallel - Statement 62",
    "query": "reset parallel_leader_participation"
  },
  {
    "comment": "select_parallel - Statement 63",
    "query": "set enable_material = false"
  },
  {
    "comment": "select_parallel - Statement 64",
    "query": "explain (costs off) select * from (select string4, count(unique2) from tenk1 group by string4 order by string4) ss right join (values (1),(2),(3)) v(x) on true"
  },
  {
    "comment": "select_parallel - Statement 65",
    "query": "select * from (select string4, count(unique2) from tenk1 group by string4 order by string4) ss right join (values (1),(2),(3)) v(x) on true"
  },
  {
    "comment": "select_parallel - Statement 66",
    "query": "reset enable_hashagg"
  },
  {
    "comment": "select_parallel - Statement 67",
    "query": "explain (costs off) select avg(unique1::int8) from tenk1"
  },
  {
    "comment": "select_parallel - Statement 68",
    "query": "select avg(unique1::int8) from tenk1"
  },
  {
    "comment": "select_parallel - Statement 69",
    "query": "explain (costs off) select fivethous from tenk1 order by fivethous limit 4"
  },
  {
    "comment": "select_parallel - Statement 70",
    "query": "select fivethous from tenk1 order by fivethous limit 4"
  },
  {
    "comment": "select_parallel - Statement 71",
    "query": "set max_parallel_workers = 0"
  },
  {
    "comment": "select_parallel - Statement 72",
    "query": "explain (costs off) select string4 from tenk1 order by string4 limit 5"
  },
  {
    "comment": "select_parallel - Statement 73",
    "query": "select string4 from tenk1 order by string4 limit 5"
  },
  {
    "comment": "select_parallel - Statement 74",
    "query": "reset max_parallel_workers"
  },
  {
    "comment": "select_parallel - Statement 75",
    "query": "create function parallel_safe_volatile(a int) returns int as $$ begin return a; end; $$ parallel safe volatile language plpgsql;   explain (costs off) select * from tenk1 where four = 2 order by four, hundred, parallel_safe_volatile(thousand);   set min_parallel_index_scan_size = 0; set enable_seqscan = off;  explain (costs off) select * from tenk1 where four = 2 order by four, hundred, parallel_safe_volatile(thousand);  reset min_parallel_index_scan_size; reset enable_seqscan;   explain (costs off) select count(*) from tenk1 group by twenty, parallel_safe_volatile(two);  drop function parallel_safe_volatile(int);  SAVEPOINT settings; SET LOCAL debug_parallel_query = 1; explain (costs off) select stringu1::int2 from tenk1 where unique1 = 1; ROLLBACK TO SAVEPOINT settings;   CREATE FUNCTION make_record(n int) RETURNS RECORD LANGUAGE plpgsql PARALLEL SAFE AS $$ BEGIN RETURN CASE n WHEN 1 THEN ROW(1) WHEN 2 THEN ROW(1, 2) WHEN 3 THEN ROW(1, 2, 3) WHEN 4 THEN ROW(1, 2, 3, 4) ELSE ROW(1, 2, 3, 4, 5) END; END; $$"
  },
  {
    "comment": "select_parallel - Statement 76",
    "query": "SAVEPOINT settings"
  },
  {
    "comment": "select_parallel - Statement 77",
    "query": "SET LOCAL debug_parallel_query = 1"
  },
  {
    "comment": "select_parallel - Statement 78",
    "query": "SELECT make_record(x) FROM (SELECT generate_series(1, 5) x) ss ORDER BY x"
  },
  {
    "comment": "select_parallel - Statement 79",
    "query": "ROLLBACK TO SAVEPOINT settings"
  },
  {
    "comment": "select_parallel - Statement 80",
    "query": "DROP function make_record(n int)"
  },
  {
    "comment": "select_parallel - Statement 81",
    "query": "drop role if exists regress_parallel_worker"
  },
  {
    "comment": "select_parallel - Statement 82",
    "query": "create role regress_parallel_worker"
  },
  {
    "comment": "select_parallel - Statement 83",
    "query": "set role regress_parallel_worker"
  },
  {
    "comment": "select_parallel - Statement 84",
    "query": "reset session authorization"
  },
  {
    "comment": "select_parallel - Statement 85",
    "query": "drop role regress_parallel_worker"
  },
  {
    "comment": "select_parallel - Statement 86",
    "query": "set debug_parallel_query = 1"
  },
  {
    "comment": "select_parallel - Statement 87",
    "query": "select count(*) from tenk1"
  },
  {
    "comment": "select_parallel - Statement 88",
    "query": "reset debug_parallel_query"
  },
  {
    "comment": "select_parallel - Statement 89",
    "query": "reset role"
  },
  {
    "comment": "select_parallel - Statement 90",
    "query": "explain (costs off, verbose) select count(*) from tenk1 a where (unique1, two) in (select unique1, row_number() over() from tenk1 b)"
  },
  {
    "comment": "select_parallel - Statement 91",
    "query": "explain (costs off) select * from tenk1 a where two in (select two from tenk1 b where stringu1 like '%AAAA' limit 3)"
  },
  {
    "comment": "select_parallel - Statement 92",
    "query": "EXPLAIN (analyze, timing off, summary off, costs off) SELECT * FROM tenk1"
  },
  {
    "comment": "select_parallel - Statement 93",
    "query": "select (stringu1 || repeat('abcd', 5000))::int2 from tenk1 where unique1 = 1"
  },
  {
    "comment": "select_parallel - Statement 94",
    "query": "SET LOCAL parallel_setup_cost = 10"
  },
  {
    "comment": "select_parallel - Statement 95",
    "query": "EXPLAIN (COSTS OFF) SELECT unique1 FROM tenk1 WHERE fivethous = tenthous + 1 UNION ALL SELECT unique1 FROM tenk1 WHERE fivethous = tenthous + 1"
  },
  {
    "comment": "select_parallel - Statement 96",
    "query": "EXPLAIN (COSTS OFF) SELECT unique1 FROM tenk1 WHERE fivethous = (SELECT unique1 FROM tenk1 WHERE fivethous = 1 LIMIT 1) UNION ALL SELECT unique1 FROM tenk1 WHERE fivethous = (SELECT unique2 FROM tenk1 WHERE fivethous = 1 LIMIT 1) ORDER BY 1"
  },
  {
    "comment": "select_parallel - Statement 97",
    "query": "SELECT * FROM information_schema.foreign_data_wrapper_options ORDER BY 1, 2, 3"
  },
  {
    "comment": "select_parallel - Statement 98",
    "query": "EXPLAIN (VERBOSE, COSTS OFF) SELECT generate_series(1, two), array(select generate_series(1, two)) FROM tenk1 ORDER BY tenthous"
  },
  {
    "comment": "select_parallel - Statement 99",
    "query": "EXPLAIN (VERBOSE, COSTS OFF) SELECT unnest(ARRAY[]::integer[]) + 1 AS pathkey FROM tenk1 t1 JOIN tenk1 t2 ON TRUE ORDER BY pathkey"
  },
  {
    "comment": "select_parallel - Statement 100",
    "query": "CREATE FUNCTION make_some_array(int,int) returns int[] as $$declare x int[]; begin x[1] := $1; x[2] := $2; return x; end$$ language plpgsql parallel safe"
  },
  {
    "comment": "select_parallel - Statement 101",
    "query": "CREATE TABLE fooarr(f1 text, f2 int[], f3 text)"
  },
  {
    "comment": "select_parallel - Statement 102",
    "query": "INSERT INTO fooarr VALUES('1', ARRAY[1,2], 'one')"
  },
  {
    "comment": "select_parallel - Statement 103",
    "query": "PREPARE pstmt(text, int[]) AS SELECT * FROM fooarr WHERE f1 = $1 AND f2 = $2"
  },
  {
    "comment": "select_parallel - Statement 104",
    "query": "EXPLAIN (COSTS OFF) EXECUTE pstmt('1', make_some_array(1,2))"
  },
  {
    "comment": "select_parallel - Statement 105",
    "query": "EXECUTE pstmt('1', make_some_array(1,2))"
  },
  {
    "comment": "select_parallel - Statement 106",
    "query": "DEALLOCATE pstmt"
  },
  {
    "comment": "select_parallel - Statement 107",
    "query": "CREATE VIEW tenk1_vw_sec WITH (security_barrier) AS SELECT * FROM tenk1"
  },
  {
    "comment": "select_parallel - Statement 108",
    "query": "EXPLAIN (COSTS OFF) SELECT 1 FROM tenk1_vw_sec WHERE (SELECT sum(f1) FROM int4_tbl WHERE f1 < unique1) < 100"
  },
  {
    "comment": "select_parallel - Statement 109",
    "query": "rollback"
  },
  {
    "comment": "select_parallel - Statement 110",
    "query": "create function set_and_report_role() returns text as $$ select current_setting('role') $$ language sql parallel safe set role = regress_parallel_worker;  create function set_role_and_error(int) returns int as $$ select 1 / $1 $$ language sql parallel safe set role = regress_parallel_worker;  set debug_parallel_query = 0; select set_and_report_role(); select set_role_and_error(0); set debug_parallel_query = 1; select set_and_report_role(); select set_role_and_error(0); reset debug_parallel_query;  drop function set_and_report_role(); drop function set_role_and_error(int); drop role regress_parallel_worker;   BEGIN;  CREATE FUNCTION my_cmp (int4, int4) RETURNS int LANGUAGE sql AS $$ SELECT CASE WHEN $1 < $2 THEN -1 WHEN $1 > $2 THEN  1 ELSE 0 END; $$"
  },
  {
    "comment": "select_parallel - Statement 111",
    "query": "CREATE TABLE parallel_hang (i int4)"
  },
  {
    "comment": "select_parallel - Statement 112",
    "query": "INSERT INTO parallel_hang (SELECT * FROM generate_series(1, 400) gs)"
  },
  {
    "comment": "select_parallel - Statement 113",
    "query": "CREATE OPERATOR CLASS int4_custom_ops FOR TYPE int4 USING btree AS OPERATOR 1 < (int4, int4), OPERATOR 2 <= (int4, int4), OPERATOR 3 = (int4, int4), OPERATOR 4 >= (int4, int4), OPERATOR 5 > (int4, int4), FUNCTION 1 my_cmp(int4, int4)"
  },
  {
    "comment": "select_parallel - Statement 114",
    "query": "CREATE UNIQUE INDEX parallel_hang_idx ON parallel_hang USING btree (i int4_custom_ops)"
  },
  {
    "comment": "select_parallel - Statement 115",
    "query": "SET debug_parallel_query = on"
  },
  {
    "comment": "select_parallel - Statement 116",
    "query": "DELETE FROM parallel_hang WHERE 380 <= i AND i <= 420"
  }
]