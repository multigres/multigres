[
  {
    "comment": "Simple SELECT all",
    "query": "SELECT *"
  },
  {
    "comment": "SELECT specific columns",
    "query": "SELECT id, name"
  },
  {
    "comment": "SELECT with alias",
    "query": "SELECT id AS user_id"
  },
  {
    "comment": "SELECT from table",
    "query": "SELECT * FROM users"
  },
  {
    "comment": "SELECT from qualified table",
    "query": "SELECT * FROM public.users"
  },
  {
    "comment": "WHERE with equality",
    "query": "SELECT * FROM users WHERE id = 1"
  },
  {
    "comment": "WHERE with comparison",
    "query": "SELECT * FROM users WHERE age \u003e 18"
  },
  {
    "comment": "WHERE with AND",
    "query": "SELECT * FROM users WHERE (age \u003e 18 AND active = TRUE)"
  },
  {
    "comment": "WHERE with OR",
    "query": "SELECT * FROM users WHERE (active = TRUE OR admin = TRUE)"
  },
  {
    "comment": "WHERE with NOT",
    "query": "SELECT * FROM users WHERE NOT deleted"
  },
  {
    "comment": "SELECT DISTINCT",
    "query": "SELECT DISTINCT name FROM users"
  },
  {
    "comment": "SELECT DISTINCT ON",
    "query": "SELECT DISTINCT ON (department) name FROM employees"
  },
  {
    "comment": "Arithmetic addition",
    "query": "SELECT 1 + 2"
  },
  {
    "comment": "Arithmetic subtraction",
    "query": "SELECT 5 - 3"
  },
  {
    "comment": "Arithmetic multiplication",
    "query": "SELECT 4 * 6"
  },
  {
    "comment": "Arithmetic division",
    "query": "SELECT 10 / 2"
  },
  {
    "comment": "Unary minus",
    "query": "SELECT -42",
    "expected": "SELECT -42"
  },
  {
    "comment": "Unary plus",
    "query": "SELECT +42",
    "expected": "SELECT +42"
  },
  {
    "comment": "Complex arithmetic",
    "query": "SELECT ((1 + 2) * 3)"
  },
  {
    "comment": "Type cast simple",
    "query": "SELECT id::TEXT FROM users"
  },
  {
    "comment": "Type cast expression",
    "query": "SELECT (age + 1)::varchar FROM users",
    "expected": "SELECT (age + 1)::VARCHAR FROM users"
  },
  {
    "comment": "Function no args",
    "query": "SELECT now()",
    "expected": "SELECT NOW()"
  },
  {
    "comment": "Function with arg",
    "query": "SELECT length('hello')"
  },
  {
    "comment": "Function multiple args",
    "query": "SELECT substring('hello', 1, 3)"
  },
  {
    "comment": "JSON_OBJECTAGG simple",
    "query": "SELECT JSON_OBJECTAGG('name' VALUE value) FROM users"
  },
  {
    "comment": "JSON_ARRAYAGG simple",
    "query": "SELECT JSON_ARRAYAGG(name) FROM users"
  },
  {
    "comment": "JSON_OBJECTAGG with RETURNING",
    "query": "SELECT JSON_OBJECTAGG('key' VALUE value RETURNING TEXT) FROM users"
  },
  {
    "comment": "JSON_ARRAYAGG with RETURNING",
    "query": "SELECT JSON_ARRAYAGG(name RETURNING JSONB) FROM users"
  },
  {
    "comment": "JSON_OBJECTAGG with FILTER",
    "query": "SELECT JSON_OBJECTAGG('key' VALUE val) FILTER (WHERE val IS NOT NULL) FROM users"
  },
  {
    "comment": "JSON_ARRAYAGG with OVER",
    "query": "SELECT JSON_ARRAYAGG(name) OVER (PARTITION BY department) FROM users"
  },
  {
    "comment": "JSON_OBJECTAGG with FILTER and OVER",
    "query": "SELECT JSON_OBJECTAGG('key' VALUE val RETURNING TEXT) FILTER (WHERE val \u003e 0) OVER (ORDER BY id) FROM users"
  },
  {
    "comment": "JSON_OBJECT legacy",
    "query": "SELECT json_object('name', 'John', 'age', 30)"
  },
  {
    "comment": "JSON_OBJECT constructor simple",
    "query": "SELECT JSON_OBJECT('name' VALUE 'John', 'age' VALUE 30)"
  },
  {
    "comment": "JSON_OBJECT empty",
    "query": "SELECT JSON_OBJECT()"
  },
  {
    "comment": "JSON_OBJECT with returning",
    "query": "SELECT JSON_OBJECT('key' VALUE 'value' RETURNING TEXT)"
  },
  {
    "comment": "JSON_ARRAY constructor",
    "query": "SELECT JSON_ARRAY('a' FORMAT JSON, 'b', 'c')"
  },
  {
    "comment": "JSON_ARRAY empty",
    "query": "SELECT JSON_ARRAY()"
  },
  {
    "comment": "JSON_ARRAY with subquery",
    "query": "SELECT JSON_ARRAY(SELECT name FROM users)"
  },
  {
    "comment": "JSON_SCALAR",
    "query": "SELECT JSON_SCALAR('test')"
  },
  {
    "comment": "JSON parse",
    "query": "SELECT JSON('{\"name\": \"John\"}')"
  },
  {
    "comment": "JSON_SERIALIZE",
    "query": "SELECT JSON_SERIALIZE('{\"name\": \"John\"}')"
  },
  {
    "comment": "JSON_VALUE",
    "query": "SELECT JSON_VALUE('{\"name\": \"John\"}', '$.name')"
  },
  {
    "comment": "JSON_EXISTS",
    "query": "SELECT JSON_EXISTS('{\"name\": \"John\"}', '$.name')"
  },
  {
    "comment": "JSON_QUERY",
    "query": "SELECT JSON_QUERY('{\"items\": [1,2,3]}', '$.items')"
  },
  {
    "comment": "MERGE_ACTION",
    "query": "SELECT MERGE_ACTION()"
  },
  {
    "comment": "Simple column",
    "query": "SELECT name FROM users"
  },
  {
    "comment": "Qualified column",
    "query": "SELECT users.name FROM users"
  },
  {
    "comment": "Integer constant",
    "query": "SELECT 42"
  },
  {
    "comment": "Float constant",
    "query": "SELECT 3.14"
  },
  {
    "comment": "String constant",
    "query": "SELECT 'hello'",
    "expected": "SELECT 'hello'"
  },
  {
    "comment": "Boolean TRUE",
    "query": "SELECT TRUE"
  },
  {
    "comment": "Boolean FALSE",
    "query": "SELECT FALSE"
  },
  {
    "comment": "NULL constant",
    "query": "SELECT NULL"
  },
  {
    "comment": "Table with alias",
    "query": "SELECT * FROM users AS u"
  },
  {
    "comment": "Table with implicit alias",
    "query": "SELECT * FROM users u",
    "expected": "SELECT * FROM users AS u"
  },
  {
    "comment": "Multiple tables",
    "query": "SELECT * FROM users, orders"
  },
  {
    "comment": "Complex query",
    "query": "SELECT id, name FROM users WHERE age \u003e 21"
  },
  {
    "comment": "Query with multiple conditions",
    "query": "SELECT * FROM users WHERE (id \u003e 0 AND active = TRUE)"
  },
  {
    "comment": "SELECT INTO",
    "query": "SELECT * INTO new_table FROM users"
  },
  {
    "comment": "SELECT INTO TEMPORARY",
    "query": "SELECT * INTO TEMPORARY temp_users FROM users"
  },
  {
    "comment": "SELECT INTO TEMP",
    "query": "SELECT * INTO TEMP temp_users FROM users",
    "expected": "SELECT * INTO TEMPORARY temp_users FROM users"
  },
  {
    "comment": "SELECT INTO LOCAL TEMPORARY",
    "query": "SELECT * INTO LOCAL TEMPORARY local_temp_users FROM users",
    "expected": "SELECT * INTO TEMPORARY local_temp_users FROM users"
  },
  {
    "comment": "SELECT INTO UNLOGGED",
    "query": "SELECT * INTO UNLOGGED unlogged_users FROM users"
  },
  {
    "comment": "SELECT INTO TABLE explicit",
    "query": "SELECT * INTO TABLE explicit_table FROM users",
    "expected": "SELECT * INTO explicit_table FROM users"
  },
  {
    "comment": "TABLE statement",
    "query": "TABLE users",
    "expected": "SELECT * FROM users"
  },
  {
    "comment": "SELECT from ONLY",
    "query": "SELECT * FROM ONLY users"
  },
  {
    "comment": "INNER JOIN",
    "query": "SELECT * FROM users INNER JOIN orders ON users.id = orders.user_id"
  },
  {
    "comment": "LEFT JOIN",
    "query": "SELECT * FROM users LEFT JOIN orders ON users.id = orders.user_id",
    "expected": "SELECT * FROM users LEFT OUTER JOIN orders ON users.id = orders.user_id"
  },
  {
    "comment": "RIGHT JOIN",
    "query": "SELECT * FROM users RIGHT JOIN orders ON users.id = orders.user_id",
    "expected": "SELECT * FROM users RIGHT OUTER JOIN orders ON users.id = orders.user_id"
  },
  {
    "comment": "FULL JOIN",
    "query": "SELECT * FROM users FULL JOIN orders ON users.id = orders.user_id",
    "expected": "SELECT * FROM users FULL OUTER JOIN orders ON users.id = orders.user_id"
  },
  {
    "comment": "CROSS JOIN",
    "query": "SELECT * FROM users CROSS JOIN orders",
    "expected": "SELECT * FROM users INNER JOIN orders ON TRUE"
  },
  {
    "comment": "NATURAL JOIN",
    "query": "SELECT * FROM users NATURAL JOIN orders"
  },
  {
    "comment": "JOIN with USING",
    "query": "SELECT * FROM users JOIN orders USING (user_id)",
    "expected": "SELECT * FROM users INNER JOIN orders USING (user_id)"
  },
  {
    "comment": "JOIN implicit INNER",
    "query": "SELECT * FROM users JOIN orders ON users.id = orders.user_id",
    "expected": "SELECT * FROM users INNER JOIN orders ON users.id = orders.user_id"
  },
  {
    "comment": "LEFT OUTER JOIN explicit",
    "query": "SELECT * FROM users LEFT OUTER JOIN orders ON users.id = orders.user_id"
  },
  {
    "comment": "RIGHT OUTER JOIN explicit",
    "query": "SELECT * FROM users RIGHT OUTER JOIN orders ON users.id = orders.user_id"
  },
  {
    "comment": "FULL OUTER JOIN explicit",
    "query": "SELECT * FROM users FULL OUTER JOIN orders ON users.id = orders.user_id"
  },
  {
    "comment": "NATURAL INNER JOIN",
    "query": "SELECT * FROM users NATURAL INNER JOIN orders",
    "expected": "SELECT * FROM users NATURAL JOIN orders"
  },
  {
    "comment": "NATURAL LEFT JOIN",
    "query": "SELECT * FROM users NATURAL LEFT JOIN orders"
  },
  {
    "comment": "NATURAL RIGHT JOIN",
    "query": "SELECT * FROM users NATURAL RIGHT JOIN orders"
  },
  {
    "comment": "NATURAL FULL JOIN",
    "query": "SELECT * FROM users NATURAL FULL JOIN orders"
  },
  {
    "comment": "Multiple column USING",
    "query": "SELECT * FROM users JOIN orders USING (user_id, created_date)",
    "expected": "SELECT * FROM users INNER JOIN orders USING (user_id, created_date)"
  },
  {
    "comment": "Chained JOINs",
    "query": "SELECT * FROM users JOIN orders ON users.id = orders.user_id JOIN products ON orders.product_id = products.id",
    "expected": "SELECT * FROM users INNER JOIN orders ON users.id = orders.user_id INNER JOIN products ON orders.product_id = products.id"
  },
  {
    "comment": "Mixed JOIN types",
    "query": "SELECT * FROM users LEFT JOIN orders ON users.id = orders.user_id CROSS JOIN categories",
    "expected": "SELECT * FROM users LEFT OUTER JOIN orders ON users.id = orders.user_id INNER JOIN categories ON TRUE"
  },
  {
    "comment": "Parenthesized JOIN",
    "query": "SELECT * FROM users JOIN (orders JOIN products ON orders.product_id = products.id) ON users.id = orders.user_id",
    "expected": "SELECT * FROM users INNER JOIN (orders INNER JOIN products ON orders.product_id = products.id) ON users.id = orders.user_id"
  },
  {
    "comment": "JOIN with table aliases",
    "query": "SELECT * FROM users u JOIN orders o ON u.id = o.user_id",
    "expected": "SELECT * FROM users AS u INNER JOIN orders AS o ON u.id = o.user_id"
  },
  {
    "comment": "Basic CTE",
    "query": "WITH stats AS (SELECT * FROM users) SELECT * FROM stats"
  },
  {
    "comment": "Recursive CTE",
    "query": "WITH RECURSIVE t AS (SELECT 1) SELECT * FROM t"
  },
  {
    "comment": "Multiple CTEs",
    "query": "WITH t1 AS (SELECT id FROM users), t2 AS (SELECT * FROM t1) SELECT * FROM t2"
  },
  {
    "comment": "CTE with column list",
    "query": "WITH stats(user_id) AS (SELECT id FROM users) SELECT * FROM stats"
  },
  {
    "comment": "MATERIALIZED CTE",
    "query": "WITH stats AS MATERIALIZED (SELECT id FROM users) SELECT * FROM stats"
  },
  {
    "comment": "NOT MATERIALIZED CTE",
    "query": "WITH stats AS NOT MATERIALIZED (SELECT id FROM users) SELECT * FROM stats"
  },
  {
    "comment": "Recursive MATERIALIZED CTE",
    "query": "WITH RECURSIVE t AS MATERIALIZED (SELECT 1) SELECT * FROM t"
  },
  {
    "comment": "CTE with SEARCH DEPTH FIRST",
    "query": "WITH RECURSIVE tree AS (SELECT id FROM nodes) SEARCH DEPTH FIRST BY id SET search_seq SELECT * FROM tree"
  },
  {
    "comment": "CTE with SEARCH BREADTH FIRST",
    "query": "WITH RECURSIVE tree AS (SELECT id FROM nodes) SEARCH BREADTH FIRST BY id SET search_seq SELECT * FROM tree"
  },
  {
    "comment": "CTE with SEARCH multiple columns",
    "query": "WITH RECURSIVE tree AS (SELECT id, parent_id FROM nodes) SEARCH DEPTH FIRST BY id, parent_id SET search_seq SELECT * FROM tree"
  },
  {
    "comment": "CTE with CYCLE simple",
    "query": "WITH RECURSIVE tree AS (SELECT id FROM nodes) CYCLE id SET is_cycle USING path SELECT * FROM tree"
  },
  {
    "comment": "CTE with CYCLE full",
    "query": "WITH RECURSIVE tree AS (SELECT id FROM nodes) CYCLE id SET is_cycle TO TRUE DEFAULT FALSE USING path SELECT * FROM tree"
  },
  {
    "comment": "CTE with CYCLE multiple columns",
    "query": "WITH RECURSIVE tree AS (SELECT id, parent_id FROM nodes) CYCLE id, parent_id SET is_cycle USING path SELECT * FROM tree"
  },
  {
    "comment": "CTE with MATERIALIZED and SEARCH",
    "query": "WITH RECURSIVE tree AS MATERIALIZED (SELECT id FROM nodes) SEARCH DEPTH FIRST BY id SET search_seq SELECT * FROM tree"
  },
  {
    "comment": "CTE with SEARCH and CYCLE",
    "query": "WITH RECURSIVE tree AS (SELECT id FROM nodes) SEARCH DEPTH FIRST BY id SET search_seq CYCLE id SET is_cycle USING path SELECT * FROM tree"
  },
  {
    "comment": "CTE with all advanced features",
    "query": "WITH RECURSIVE tree AS MATERIALIZED (SELECT id FROM nodes) SEARCH DEPTH FIRST BY id SET search_seq CYCLE id SET is_cycle TO TRUE DEFAULT FALSE USING path SELECT * FROM tree"
  },
  {
    "comment": "Subquery in FROM",
    "query": "SELECT * FROM (SELECT id FROM users) AS sub"
  },
  {
    "comment": "LATERAL subquery",
    "query": "SELECT * FROM users, LATERAL (SELECT * FROM orders) AS sub"
  },
  {
    "comment": "Subquery with alias and columns",
    "query": "SELECT * FROM (SELECT id, name FROM users) AS sub(user_id, user_name)"
  },
  {
    "comment": "Simple SELECT statement",
    "query": "SELECT 1"
  },
  {
    "comment": "SELECT statement with expected normalization",
    "query": "select   1",
    "expected": "SELECT 1"
  },
  {
    "comment": "SELECT with FROM clause",
    "query": "SELECT * FROM users"
  },
  {
    "comment": "SELECT with WHERE clause",
    "query": "SELECT id, name FROM users WHERE id = 1"
  },
  {
    "comment": "SELECT with JOIN",
    "query": "SELECT u.name, o.total FROM users u JOIN orders o ON u.id = o.user_id",
    "expected": "SELECT u.name, o.total FROM users AS u INNER JOIN orders AS o ON u.id = o.user_id"
  },
  {
    "comment": "SELECT with GROUP BY",
    "query": "SELECT department, COUNT(*) FROM employees GROUP BY department"
  },
  {
    "comment": "SELECT with ORDER BY",
    "query": "SELECT * FROM products ORDER BY price DESC"
  },
  {
    "comment": "SELECT with LIMIT",
    "query": "SELECT * FROM logs LIMIT 10"
  },
  {
    "comment": "SELECT with CTE",
    "query": "WITH active_users AS (SELECT * FROM users WHERE active = true) SELECT * FROM active_users",
    "expected": "WITH active_users AS (SELECT * FROM users WHERE active = TRUE) SELECT * FROM active_users"
  },
  {
    "comment": "SELECT with window function",
    "query": "SELECT name, salary, RANK() OVER (ORDER BY salary DESC) FROM employees"
  },
  {
    "comment": "Invalid SELECT - should error",
    "query": "SELECT FROM WHERE",
    "error": "parse error at position 17: syntax error"
  },
  {
    "comment": "Basic GROUP BY",
    "query": "SELECT dept_id, COUNT(*) FROM employees GROUP BY dept_id"
  },
  {
    "comment": "GROUP BY multiple columns",
    "query": "SELECT dept_id, status, COUNT(*) FROM employees GROUP BY dept_id, status"
  },
  {
    "comment": "GROUP BY with expression",
    "query": "SELECT DATE(created_at), COUNT(*) FROM orders GROUP BY DATE(created_at)",
    "expected": "SELECT date(created_at), COUNT(*) FROM orders GROUP BY date(created_at)"
  },
  {
    "comment": "GROUP BY ROLLUP",
    "query": "SELECT year, quarter, SUM(sales) FROM sales GROUP BY ROLLUP(year, quarter)"
  },
  {
    "comment": "GROUP BY CUBE",
    "query": "SELECT category, subcategory, COUNT(*) FROM products GROUP BY CUBE(category, subcategory)"
  },
  {
    "comment": "GROUP BY GROUPING SETS",
    "query": "SELECT col1, col2, COUNT(*) FROM table1 GROUP BY GROUPING SETS ((col1), (col2), ())"
  },
  {
    "comment": "GROUP BY empty grouping set",
    "query": "SELECT COUNT(*) FROM table1 GROUP BY ()"
  },
  {
    "comment": "Basic HAVING",
    "query": "SELECT dept_id, COUNT(*) FROM employees GROUP BY dept_id HAVING COUNT(*) \u003e 5"
  },
  {
    "comment": "HAVING with AND",
    "query": "SELECT dept_id, AVG(salary) FROM employees GROUP BY dept_id HAVING COUNT(*) \u003e 5 AND AVG(salary) \u003e 50000"
  },
  {
    "comment": "HAVING with complex expression",
    "query": "SELECT category, SUM(amount) FROM transactions GROUP BY category HAVING SUM(amount) \u003e 1000 AND COUNT(*) \u003e 10"
  },
  {
    "comment": "Basic ORDER BY",
    "query": "SELECT name, age FROM users ORDER BY name"
  },
  {
    "comment": "ORDER BY ASC/DESC",
    "query": "SELECT name, age FROM users ORDER BY name ASC, age DESC"
  },
  {
    "comment": "ORDER BY NULLS FIRST",
    "query": "SELECT name, score FROM users ORDER BY score NULLS FIRST"
  },
  {
    "comment": "ORDER BY NULLS LAST",
    "query": "SELECT name, score FROM users ORDER BY score DESC NULLS LAST"
  },
  {
    "comment": "ORDER BY multiple with mixed nulls",
    "query": "SELECT name, score, age FROM users ORDER BY score ASC NULLS FIRST, age DESC NULLS LAST"
  },
  {
    "comment": "ORDER BY with expression",
    "query": "SELECT name FROM users ORDER BY upper(name)"
  },
  {
    "comment": "GROUP BY + HAVING",
    "query": "SELECT dept_id, COUNT(*) FROM employees GROUP BY dept_id HAVING COUNT(*) \u003e 5"
  },
  {
    "comment": "GROUP BY + ORDER BY",
    "query": "SELECT dept_id, COUNT(*) FROM employees GROUP BY dept_id ORDER BY dept_id"
  },
  {
    "comment": "HAVING + ORDER BY",
    "query": "SELECT dept_id, COUNT(*) FROM employees GROUP BY dept_id HAVING COUNT(*) \u003e 5 ORDER BY COUNT(*) DESC"
  },
  {
    "comment": "All three combined",
    "query": "SELECT dept_id, AVG(salary) FROM employees GROUP BY dept_id HAVING AVG(salary) \u003e 50000 ORDER BY AVG(salary) DESC"
  },
  {
    "comment": "Advanced ROLLUP with ORDER BY",
    "query": "SELECT year, quarter, SUM(sales) FROM sales GROUP BY ROLLUP(year, quarter) ORDER BY year NULLS LAST, quarter"
  },
  {
    "comment": "Complex GROUPING SETS with HAVING and ORDER BY",
    "query": "SELECT category, subcategory, COUNT(*), SUM(amount) FROM transactions GROUP BY GROUPING SETS ((category), (category, subcategory), ()) HAVING SUM(amount) \u003e 1000 ORDER BY category NULLS FIRST, subcategory DESC"
  },
  {
    "comment": "Aggregate with FILTER",
    "query": "SELECT COUNT(*) FILTER (WHERE active = TRUE) FROM users"
  },
  {
    "comment": "SUM with FILTER",
    "query": "SELECT SUM(amount) FILTER (WHERE status = 'paid') FROM invoices"
  },
  {
    "comment": "Multiple aggregates with FILTER",
    "query": "SELECT COUNT(*) FILTER (WHERE active), SUM(sales) FILTER (WHERE region = 'US') FROM data"
  },
  {
    "comment": "Aggregate FILTER with GROUP BY",
    "query": "SELECT dept, AVG(salary) FILTER (WHERE experience \u003e 5) FROM employees GROUP BY dept"
  },
  {
    "comment": "percentile_cont WITHIN GROUP",
    "query": "SELECT percentile_cont(0.5) WITHIN GROUP (ORDER BY score) FROM results"
  },
  {
    "comment": "mode WITHIN GROUP",
    "query": "SELECT mode() WITHIN GROUP (ORDER BY value) FROM measurements"
  },
  {
    "comment": "string_agg WITHIN GROUP",
    "query": "SELECT string_agg(name, ',') WITHIN GROUP (ORDER BY name) FROM users"
  },
  {
    "comment": "WITHIN GROUP with DESC",
    "query": "SELECT percentile_disc(0.9) WITHIN GROUP (ORDER BY amount DESC) FROM transactions"
  },
  {
    "comment": "Aggregate with FILTER and WITHIN GROUP",
    "query": "SELECT percentile_cont(0.5) WITHIN GROUP (ORDER BY score) FILTER (WHERE valid = TRUE) FROM tests"
  },
  {
    "comment": "Simple FOR UPDATE",
    "query": "SELECT * FROM users FOR UPDATE"
  },
  {
    "comment": "FOR UPDATE with table",
    "query": "SELECT * FROM users u FOR UPDATE OF u",
    "expected": "SELECT * FROM users AS u FOR UPDATE OF u"
  },
  {
    "comment": "FOR UPDATE NOWAIT",
    "query": "SELECT * FROM accounts FOR UPDATE NOWAIT"
  },
  {
    "comment": "FOR UPDATE SKIP LOCKED",
    "query": "SELECT * FROM queue FOR UPDATE SKIP LOCKED"
  },
  {
    "comment": "FOR NO KEY UPDATE",
    "query": "SELECT * FROM settings FOR NO KEY UPDATE"
  },
  {
    "comment": "FOR NO KEY UPDATE SKIP LOCKED",
    "query": "SELECT * FROM tasks FOR NO KEY UPDATE SKIP LOCKED"
  },
  {
    "comment": "FOR SHARE",
    "query": "SELECT * FROM products FOR SHARE"
  },
  {
    "comment": "FOR SHARE NOWAIT",
    "query": "SELECT * FROM inventory FOR SHARE NOWAIT"
  },
  {
    "comment": "FOR KEY SHARE",
    "query": "SELECT * FROM categories FOR KEY SHARE"
  },
  {
    "comment": "FOR KEY SHARE SKIP LOCKED",
    "query": "SELECT * FROM jobs FOR KEY SHARE SKIP LOCKED"
  },
  {
    "comment": "Multiple locking clauses",
    "query": "SELECT * FROM t1, t2 FOR UPDATE OF t1 FOR SHARE OF t2"
  },
  {
    "comment": "FOR READ ONLY",
    "query": "SELECT * FROM logs FOR READ ONLY",
    "expected": "SELECT * FROM logs"
  },
  {
    "comment": "Locking with ORDER BY LIMIT",
    "query": "SELECT * FROM queue ORDER BY priority LIMIT 10 FOR UPDATE SKIP LOCKED"
  },
  {
    "comment": "Locking with GROUP BY",
    "query": "SELECT user_id, COUNT(*) FROM orders GROUP BY user_id FOR UPDATE"
  },
  {
    "comment": "SELECT with array type cast",
    "query": "SELECT value::INT[]"
  },
  {
    "comment": "SELECT with bounded array type cast",
    "query": "SELECT value::INT[5]"
  },
  {
    "comment": "SELECT with SETOF type cast",
    "query": "SELECT value::SETOF INT"
  }
]
