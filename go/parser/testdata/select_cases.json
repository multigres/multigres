[
  {
    "comment": "Simple SELECT all",
    "query": "SELECT *"
  },
  {
    "comment": "SELECT specific columns",
    "query": "SELECT id, name"
  },
  {
    "comment": "SELECT with alias",
    "query": "SELECT id AS user_id"
  },
  {
    "comment": "SELECT from table",
    "query": "SELECT * FROM users"
  },
  {
    "comment": "SELECT from qualified table",
    "query": "SELECT * FROM public.users"
  },
  {
    "comment": "WHERE with equality",
    "query": "SELECT * FROM users WHERE id = 1"
  },
  {
    "comment": "WHERE with comparison",
    "query": "SELECT * FROM users WHERE age \u003e 18"
  },
  {
    "comment": "WHERE with AND",
    "query": "SELECT * FROM users WHERE (age \u003e 18 AND active = TRUE)"
  },
  {
    "comment": "WHERE with OR",
    "query": "SELECT * FROM users WHERE (active = TRUE OR admin = TRUE)"
  },
  {
    "comment": "WHERE with NOT",
    "query": "SELECT * FROM users WHERE NOT deleted"
  },
  {
    "comment": "SELECT DISTINCT",
    "query": "SELECT DISTINCT name FROM users"
  },
  {
    "comment": "SELECT DISTINCT ON",
    "query": "SELECT DISTINCT ON (department) name FROM employees"
  },
  {
    "comment": "Arithmetic addition",
    "query": "SELECT 1 + 2"
  },
  {
    "comment": "Arithmetic subtraction",
    "query": "SELECT 5 - 3"
  },
  {
    "comment": "Arithmetic multiplication",
    "query": "SELECT 4 * 6"
  },
  {
    "comment": "Arithmetic division",
    "query": "SELECT 10 / 2"
  },
  {
    "comment": "Unary minus",
    "query": "SELECT -42"
  },
  {
    "comment": "Unary plus",
    "query": "SELECT +42"
  },
  {
    "comment": "Complex arithmetic",
    "query": "SELECT ((1 + 2) * 3)"
  },
  {
    "comment": "Type cast simple",
    "query": "SELECT id::TEXT FROM users"
  },
  {
    "comment": "Type cast expression",
    "query": "SELECT (age + 1)::varchar FROM users",
    "expected": "SELECT (age + 1)::VARCHAR FROM users"
  },
  {
    "comment": "Function no args",
    "query": "SELECT now()",
    "expected": "SELECT NOW()"
  },
  {
    "comment": "Function with arg",
    "query": "SELECT length('hello')"
  },
  {
    "comment": "Function multiple args",
    "query": "SELECT substring('hello', 1, 3)"
  },
  {
    "comment": "JSON_OBJECTAGG simple",
    "query": "SELECT JSON_OBJECTAGG('name' VALUE value) FROM users"
  },
  {
    "comment": "JSON_ARRAYAGG simple",
    "query": "SELECT JSON_ARRAYAGG(name) FROM users"
  },
  {
    "comment": "JSON_OBJECTAGG with RETURNING",
    "query": "SELECT JSON_OBJECTAGG('key' VALUE value RETURNING TEXT) FROM users"
  },
  {
    "comment": "JSON_ARRAYAGG with RETURNING",
    "query": "SELECT JSON_ARRAYAGG(name RETURNING JSONB) FROM users"
  },
  {
    "comment": "JSON_OBJECTAGG with FILTER",
    "query": "SELECT JSON_OBJECTAGG('key' VALUE val) FILTER (WHERE val IS NOT NULL) FROM users"
  },
  {
    "comment": "JSON_ARRAYAGG with OVER",
    "query": "SELECT JSON_ARRAYAGG(name) OVER (PARTITION BY department) FROM users"
  },
  {
    "comment": "JSON_OBJECTAGG with FILTER and OVER",
    "query": "SELECT JSON_OBJECTAGG('key' VALUE val RETURNING TEXT) FILTER (WHERE val \u003e 0) OVER (ORDER BY id) FROM users"
  },
  {
    "comment": "JSON_OBJECT legacy",
    "query": "SELECT json_object('name', 'John', 'age', 30)"
  },
  {
    "comment": "JSON_OBJECT constructor simple",
    "query": "SELECT JSON_OBJECT('name' VALUE 'John', 'age' VALUE 30)"
  },
  {
    "comment": "JSON_OBJECT empty",
    "query": "SELECT JSON_OBJECT()"
  },
  {
    "comment": "JSON_OBJECT with returning",
    "query": "SELECT JSON_OBJECT('key' VALUE 'value' RETURNING TEXT)"
  },
  {
    "comment": "JSON_ARRAY constructor",
    "query": "SELECT JSON_ARRAY('a' FORMAT JSON, 'b', 'c')"
  },
  {
    "comment": "JSON_ARRAY empty",
    "query": "SELECT JSON_ARRAY()"
  },
  {
    "comment": "JSON_ARRAY with subquery",
    "query": "SELECT JSON_ARRAY(SELECT name FROM users)"
  },
  {
    "comment": "JSON_SCALAR",
    "query": "SELECT JSON_SCALAR('test')"
  },
  {
    "comment": "JSON parse",
    "query": "SELECT JSON('{\"name\": \"John\"}')"
  },
  {
    "comment": "JSON_SERIALIZE",
    "query": "SELECT JSON_SERIALIZE('{\"name\": \"John\"}')"
  },
  {
    "comment": "JSON_VALUE",
    "query": "SELECT JSON_VALUE('{\"name\": \"John\"}', '$.name')"
  },
  {
    "comment": "JSON_EXISTS",
    "query": "SELECT JSON_EXISTS('{\"name\": \"John\"}', '$.name')"
  },
  {
    "comment": "JSON_QUERY",
    "query": "SELECT JSON_QUERY('{\"items\": [1,2,3]}', '$.items')"
  },
  {
    "comment": "MERGE_ACTION",
    "query": "SELECT MERGE_ACTION()"
  },
  {
    "comment": "Simple column",
    "query": "SELECT name FROM users"
  },
  {
    "comment": "Qualified column",
    "query": "SELECT users.name FROM users"
  },
  {
    "comment": "Integer constant",
    "query": "SELECT 42"
  },
  {
    "comment": "Float constant",
    "query": "SELECT 3.14"
  },
  {
    "comment": "String constant",
    "query": "SELECT 'hello'"
  },
  {
    "comment": "Boolean TRUE",
    "query": "SELECT TRUE"
  },
  {
    "comment": "Boolean FALSE",
    "query": "SELECT FALSE"
  },
  {
    "comment": "NULL constant",
    "query": "SELECT NULL"
  },
  {
    "comment": "Table with alias",
    "query": "SELECT * FROM users AS u"
  },
  {
    "comment": "Table with implicit alias",
    "query": "SELECT * FROM users u",
    "expected": "SELECT * FROM users AS u"
  },
  {
    "comment": "Multiple tables",
    "query": "SELECT * FROM users, orders"
  },
  {
    "comment": "Complex query",
    "query": "SELECT id, name FROM users WHERE age \u003e 21"
  },
  {
    "comment": "Query with multiple conditions",
    "query": "SELECT * FROM users WHERE (id \u003e 0 AND active = TRUE)"
  },
  {
    "comment": "SELECT INTO",
    "query": "SELECT * INTO new_table FROM users"
  },
  {
    "comment": "SELECT INTO TEMPORARY",
    "query": "SELECT * INTO TEMPORARY temp_users FROM users"
  },
  {
    "comment": "SELECT INTO TEMP",
    "query": "SELECT * INTO TEMP temp_users FROM users",
    "expected": "SELECT * INTO TEMPORARY temp_users FROM users"
  },
  {
    "comment": "SELECT INTO LOCAL TEMPORARY",
    "query": "SELECT * INTO LOCAL TEMPORARY local_temp_users FROM users",
    "expected": "SELECT * INTO TEMPORARY local_temp_users FROM users"
  },
  {
    "comment": "SELECT INTO UNLOGGED",
    "query": "SELECT * INTO UNLOGGED unlogged_users FROM users"
  },
  {
    "comment": "SELECT INTO TABLE explicit",
    "query": "SELECT * INTO TABLE explicit_table FROM users",
    "expected": "SELECT * INTO explicit_table FROM users"
  },
  {
    "comment": "TABLE statement",
    "query": "TABLE users",
    "expected": "SELECT * FROM users"
  },
  {
    "comment": "SELECT from ONLY",
    "query": "SELECT * FROM ONLY users"
  },
  {
    "comment": "INNER JOIN",
    "query": "SELECT * FROM users INNER JOIN orders ON users.id = orders.user_id"
  },
  {
    "comment": "LEFT JOIN",
    "query": "SELECT * FROM users LEFT JOIN orders ON users.id = orders.user_id",
    "expected": "SELECT * FROM users LEFT OUTER JOIN orders ON users.id = orders.user_id"
  },
  {
    "comment": "RIGHT JOIN",
    "query": "SELECT * FROM users RIGHT JOIN orders ON users.id = orders.user_id",
    "expected": "SELECT * FROM users RIGHT OUTER JOIN orders ON users.id = orders.user_id"
  },
  {
    "comment": "FULL JOIN",
    "query": "SELECT * FROM users FULL JOIN orders ON users.id = orders.user_id",
    "expected": "SELECT * FROM users FULL OUTER JOIN orders ON users.id = orders.user_id"
  },
  {
    "comment": "CROSS JOIN",
    "query": "SELECT * FROM users CROSS JOIN orders",
    "expected": "SELECT * FROM users INNER JOIN orders ON TRUE"
  },
  {
    "comment": "NATURAL JOIN",
    "query": "SELECT * FROM users NATURAL JOIN orders"
  },
  {
    "comment": "JOIN with USING",
    "query": "SELECT * FROM users JOIN orders USING (user_id)",
    "expected": "SELECT * FROM users INNER JOIN orders USING (user_id)"
  },
  {
    "comment": "JOIN implicit INNER",
    "query": "SELECT * FROM users JOIN orders ON users.id = orders.user_id",
    "expected": "SELECT * FROM users INNER JOIN orders ON users.id = orders.user_id"
  },
  {
    "comment": "LEFT OUTER JOIN explicit",
    "query": "SELECT * FROM users LEFT OUTER JOIN orders ON users.id = orders.user_id"
  },
  {
    "comment": "RIGHT OUTER JOIN explicit",
    "query": "SELECT * FROM users RIGHT OUTER JOIN orders ON users.id = orders.user_id"
  },
  {
    "comment": "FULL OUTER JOIN explicit",
    "query": "SELECT * FROM users FULL OUTER JOIN orders ON users.id = orders.user_id"
  },
  {
    "comment": "NATURAL INNER JOIN",
    "query": "SELECT * FROM users NATURAL INNER JOIN orders",
    "expected": "SELECT * FROM users NATURAL JOIN orders"
  },
  {
    "comment": "NATURAL LEFT JOIN",
    "query": "SELECT * FROM users NATURAL LEFT JOIN orders"
  },
  {
    "comment": "NATURAL RIGHT JOIN",
    "query": "SELECT * FROM users NATURAL RIGHT JOIN orders"
  },
  {
    "comment": "NATURAL FULL JOIN",
    "query": "SELECT * FROM users NATURAL FULL JOIN orders"
  },
  {
    "comment": "Multiple column USING",
    "query": "SELECT * FROM users JOIN orders USING (user_id, created_date)",
    "expected": "SELECT * FROM users INNER JOIN orders USING (user_id, created_date)"
  },
  {
    "comment": "Chained JOINs",
    "query": "SELECT * FROM users JOIN orders ON users.id = orders.user_id JOIN products ON orders.product_id = products.id",
    "expected": "SELECT * FROM users INNER JOIN orders ON users.id = orders.user_id INNER JOIN products ON orders.product_id = products.id"
  },
  {
    "comment": "Mixed JOIN types",
    "query": "SELECT * FROM users LEFT JOIN orders ON users.id = orders.user_id CROSS JOIN categories",
    "expected": "SELECT * FROM users LEFT OUTER JOIN orders ON users.id = orders.user_id INNER JOIN categories ON TRUE"
  },
  {
    "comment": "Parenthesized JOIN",
    "query": "SELECT * FROM users JOIN (orders JOIN products ON orders.product_id = products.id) ON users.id = orders.user_id",
    "expected": "SELECT * FROM users INNER JOIN (orders INNER JOIN products ON orders.product_id = products.id) ON users.id = orders.user_id"
  },
  {
    "comment": "JOIN with table aliases",
    "query": "SELECT * FROM users u JOIN orders o ON u.id = o.user_id",
    "expected": "SELECT * FROM users AS u INNER JOIN orders AS o ON u.id = o.user_id"
  },
  {
    "comment": "Basic CTE",
    "query": "WITH stats AS (SELECT * FROM users) SELECT * FROM stats"
  },
  {
    "comment": "Recursive CTE",
    "query": "WITH RECURSIVE t AS (SELECT 1) SELECT * FROM t"
  },
  {
    "comment": "Multiple CTEs",
    "query": "WITH t1 AS (SELECT id FROM users), t2 AS (SELECT * FROM t1) SELECT * FROM t2"
  },
  {
    "comment": "CTE with column list",
    "query": "WITH stats(user_id) AS (SELECT id FROM users) SELECT * FROM stats"
  },
  {
    "comment": "MATERIALIZED CTE",
    "query": "WITH stats AS MATERIALIZED (SELECT id FROM users) SELECT * FROM stats"
  },
  {
    "comment": "NOT MATERIALIZED CTE",
    "query": "WITH stats AS NOT MATERIALIZED (SELECT id FROM users) SELECT * FROM stats"
  },
  {
    "comment": "Recursive MATERIALIZED CTE",
    "query": "WITH RECURSIVE t AS MATERIALIZED (SELECT 1) SELECT * FROM t"
  },
  {
    "comment": "CTE with SEARCH DEPTH FIRST",
    "query": "WITH RECURSIVE tree AS (SELECT id FROM nodes) SEARCH DEPTH FIRST BY id SET search_seq SELECT * FROM tree"
  },
  {
    "comment": "CTE with SEARCH BREADTH FIRST",
    "query": "WITH RECURSIVE tree AS (SELECT id FROM nodes) SEARCH BREADTH FIRST BY id SET search_seq SELECT * FROM tree"
  },
  {
    "comment": "CTE with SEARCH multiple columns",
    "query": "WITH RECURSIVE tree AS (SELECT id, parent_id FROM nodes) SEARCH DEPTH FIRST BY id, parent_id SET search_seq SELECT * FROM tree"
  },
  {
    "comment": "CTE with CYCLE simple",
    "query": "WITH RECURSIVE tree AS (SELECT id FROM nodes) CYCLE id SET is_cycle USING path SELECT * FROM tree"
  },
  {
    "comment": "CTE with CYCLE full",
    "query": "WITH RECURSIVE tree AS (SELECT id FROM nodes) CYCLE id SET is_cycle TO TRUE DEFAULT FALSE USING path SELECT * FROM tree"
  },
  {
    "comment": "CTE with CYCLE multiple columns",
    "query": "WITH RECURSIVE tree AS (SELECT id, parent_id FROM nodes) CYCLE id, parent_id SET is_cycle USING path SELECT * FROM tree"
  },
  {
    "comment": "CTE with MATERIALIZED and SEARCH",
    "query": "WITH RECURSIVE tree AS MATERIALIZED (SELECT id FROM nodes) SEARCH DEPTH FIRST BY id SET search_seq SELECT * FROM tree"
  },
  {
    "comment": "CTE with SEARCH and CYCLE",
    "query": "WITH RECURSIVE tree AS (SELECT id FROM nodes) SEARCH DEPTH FIRST BY id SET search_seq CYCLE id SET is_cycle USING path SELECT * FROM tree"
  },
  {
    "comment": "CTE with all advanced features",
    "query": "WITH RECURSIVE tree AS MATERIALIZED (SELECT id FROM nodes) SEARCH DEPTH FIRST BY id SET search_seq CYCLE id SET is_cycle TO TRUE DEFAULT FALSE USING path SELECT * FROM tree"
  },
  {
    "comment": "Subquery in FROM",
    "query": "SELECT * FROM (SELECT id FROM users) AS sub"
  },
  {
    "comment": "LATERAL subquery",
    "query": "SELECT * FROM users, LATERAL (SELECT * FROM orders) AS sub"
  },
  {
    "comment": "Subquery with alias and columns",
    "query": "SELECT * FROM (SELECT id, name FROM users) AS sub(user_id, user_name)"
  },
  {
    "comment": "Simple SELECT statement",
    "query": "SELECT 1"
  },
  {
    "comment": "SELECT statement with expected normalization",
    "query": "select   1",
    "expected": "SELECT 1"
  },
  {
    "comment": "SELECT with FROM clause",
    "query": "SELECT * FROM users"
  },
  {
    "comment": "SELECT with WHERE clause",
    "query": "SELECT id, name FROM users WHERE id = 1"
  },
  {
    "comment": "SELECT with JOIN",
    "query": "SELECT u.name, o.total FROM users u JOIN orders o ON u.id = o.user_id",
    "expected": "SELECT u.name, o.total FROM users AS u INNER JOIN orders AS o ON u.id = o.user_id"
  },
  {
    "comment": "SELECT with GROUP BY",
    "query": "SELECT department, COUNT(*) FROM employees GROUP BY department"
  },
  {
    "comment": "SELECT with ORDER BY",
    "query": "SELECT * FROM products ORDER BY price DESC"
  },
  {
    "comment": "SELECT with LIMIT",
    "query": "SELECT * FROM logs LIMIT 10"
  },
  {
    "comment": "SELECT with CTE",
    "query": "WITH active_users AS (SELECT * FROM users WHERE active = true) SELECT * FROM active_users",
    "expected": "WITH active_users AS (SELECT * FROM users WHERE active = TRUE) SELECT * FROM active_users"
  },
  {
    "comment": "SELECT with window function",
    "query": "SELECT name, salary, RANK() OVER (ORDER BY salary DESC) FROM employees"
  },
  {
    "comment": "Invalid SELECT - should error",
    "query": "SELECT FROM WHERE",
    "error": "parse error at position 17: syntax error"
  },
  {
    "comment": "Basic GROUP BY",
    "query": "SELECT dept_id, COUNT(*) FROM employees GROUP BY dept_id"
  },
  {
    "comment": "GROUP BY multiple columns",
    "query": "SELECT dept_id, status, COUNT(*) FROM employees GROUP BY dept_id, status"
  },
  {
    "comment": "GROUP BY with expression",
    "query": "SELECT DATE(created_at), COUNT(*) FROM orders GROUP BY DATE(created_at)",
    "expected": "SELECT date(created_at), COUNT(*) FROM orders GROUP BY date(created_at)"
  },
  {
    "comment": "GROUP BY ROLLUP",
    "query": "SELECT year, quarter, SUM(sales) FROM sales GROUP BY ROLLUP(year, quarter)"
  },
  {
    "comment": "GROUP BY CUBE",
    "query": "SELECT category, subcategory, COUNT(*) FROM products GROUP BY CUBE(category, subcategory)"
  },
  {
    "comment": "GROUP BY GROUPING SETS",
    "query": "SELECT col1, col2, COUNT(*) FROM table1 GROUP BY GROUPING SETS ((col1), (col2), ())"
  },
  {
    "comment": "GROUP BY empty grouping set",
    "query": "SELECT COUNT(*) FROM table1 GROUP BY ()"
  },
  {
    "comment": "Basic HAVING",
    "query": "SELECT dept_id, COUNT(*) FROM employees GROUP BY dept_id HAVING COUNT(*) \u003e 5"
  },
  {
    "comment": "HAVING with AND",
    "query": "SELECT dept_id, AVG(salary) FROM employees GROUP BY dept_id HAVING COUNT(*) \u003e 5 AND AVG(salary) \u003e 50000"
  },
  {
    "comment": "HAVING with complex expression",
    "query": "SELECT category, SUM(amount) FROM transactions GROUP BY category HAVING SUM(amount) \u003e 1000 AND COUNT(*) \u003e 10"
  },
  {
    "comment": "Basic ORDER BY",
    "query": "SELECT name, age FROM users ORDER BY name"
  },
  {
    "comment": "ORDER BY ASC/DESC",
    "query": "SELECT name, age FROM users ORDER BY name ASC, age DESC"
  },
  {
    "comment": "ORDER BY NULLS FIRST",
    "query": "SELECT name, score FROM users ORDER BY score NULLS FIRST"
  },
  {
    "comment": "ORDER BY NULLS LAST",
    "query": "SELECT name, score FROM users ORDER BY score DESC NULLS LAST"
  },
  {
    "comment": "ORDER BY multiple with mixed nulls",
    "query": "SELECT name, score, age FROM users ORDER BY score ASC NULLS FIRST, age DESC NULLS LAST"
  },
  {
    "comment": "ORDER BY with expression",
    "query": "SELECT name FROM users ORDER BY upper(name)"
  },
  {
    "comment": "GROUP BY + HAVING",
    "query": "SELECT dept_id, COUNT(*) FROM employees GROUP BY dept_id HAVING COUNT(*) \u003e 5"
  },
  {
    "comment": "GROUP BY + ORDER BY",
    "query": "SELECT dept_id, COUNT(*) FROM employees GROUP BY dept_id ORDER BY dept_id"
  },
  {
    "comment": "HAVING + ORDER BY",
    "query": "SELECT dept_id, COUNT(*) FROM employees GROUP BY dept_id HAVING COUNT(*) \u003e 5 ORDER BY COUNT(*) DESC"
  },
  {
    "comment": "All three combined",
    "query": "SELECT dept_id, AVG(salary) FROM employees GROUP BY dept_id HAVING AVG(salary) \u003e 50000 ORDER BY AVG(salary) DESC"
  },
  {
    "comment": "Advanced ROLLUP with ORDER BY",
    "query": "SELECT year, quarter, SUM(sales) FROM sales GROUP BY ROLLUP(year, quarter) ORDER BY year NULLS LAST, quarter"
  },
  {
    "comment": "Complex GROUPING SETS with HAVING and ORDER BY",
    "query": "SELECT category, subcategory, COUNT(*), SUM(amount) FROM transactions GROUP BY GROUPING SETS ((category), (category, subcategory), ()) HAVING SUM(amount) \u003e 1000 ORDER BY category NULLS FIRST, subcategory DESC"
  },
  {
    "comment": "Aggregate with FILTER",
    "query": "SELECT COUNT(*) FILTER (WHERE active = TRUE) FROM users"
  },
  {
    "comment": "SUM with FILTER",
    "query": "SELECT SUM(amount) FILTER (WHERE status = 'paid') FROM invoices"
  },
  {
    "comment": "Multiple aggregates with FILTER",
    "query": "SELECT COUNT(*) FILTER (WHERE active), SUM(sales) FILTER (WHERE region = 'US') FROM data"
  },
  {
    "comment": "Aggregate FILTER with GROUP BY",
    "query": "SELECT dept, AVG(salary) FILTER (WHERE experience \u003e 5) FROM employees GROUP BY dept"
  },
  {
    "comment": "percentile_cont WITHIN GROUP",
    "query": "SELECT percentile_cont(0.5) WITHIN GROUP (ORDER BY score) FROM results"
  },
  {
    "comment": "mode WITHIN GROUP",
    "query": "SELECT mode() WITHIN GROUP (ORDER BY value) FROM measurements"
  },
  {
    "comment": "string_agg WITHIN GROUP",
    "query": "SELECT string_agg(name, ',') WITHIN GROUP (ORDER BY name) FROM users"
  },
  {
    "comment": "WITHIN GROUP with DESC",
    "query": "SELECT percentile_disc(0.9) WITHIN GROUP (ORDER BY amount DESC) FROM transactions"
  },
  {
    "comment": "Aggregate with FILTER and WITHIN GROUP",
    "query": "SELECT percentile_cont(0.5) WITHIN GROUP (ORDER BY score) FILTER (WHERE valid = TRUE) FROM tests"
  },
  {
    "comment": "Simple FOR UPDATE",
    "query": "SELECT * FROM users FOR UPDATE"
  },
  {
    "comment": "FOR UPDATE with table",
    "query": "SELECT * FROM users u FOR UPDATE OF u",
    "expected": "SELECT * FROM users AS u FOR UPDATE OF u"
  },
  {
    "comment": "FOR UPDATE NOWAIT",
    "query": "SELECT * FROM accounts FOR UPDATE NOWAIT"
  },
  {
    "comment": "FOR UPDATE SKIP LOCKED",
    "query": "SELECT * FROM queue FOR UPDATE SKIP LOCKED"
  },
  {
    "comment": "FOR NO KEY UPDATE",
    "query": "SELECT * FROM settings FOR NO KEY UPDATE"
  },
  {
    "comment": "FOR NO KEY UPDATE SKIP LOCKED",
    "query": "SELECT * FROM tasks FOR NO KEY UPDATE SKIP LOCKED"
  },
  {
    "comment": "FOR SHARE",
    "query": "SELECT * FROM products FOR SHARE"
  },
  {
    "comment": "FOR SHARE NOWAIT",
    "query": "SELECT * FROM inventory FOR SHARE NOWAIT"
  },
  {
    "comment": "FOR KEY SHARE",
    "query": "SELECT * FROM categories FOR KEY SHARE"
  },
  {
    "comment": "FOR KEY SHARE SKIP LOCKED",
    "query": "SELECT * FROM jobs FOR KEY SHARE SKIP LOCKED"
  },
  {
    "comment": "Multiple locking clauses",
    "query": "SELECT * FROM t1, t2 FOR UPDATE OF t1 FOR SHARE OF t2"
  },
  {
    "comment": "FOR READ ONLY",
    "query": "SELECT * FROM logs FOR READ ONLY",
    "expected": "SELECT * FROM logs"
  },
  {
    "comment": "Locking with ORDER BY LIMIT",
    "query": "SELECT * FROM queue ORDER BY priority LIMIT 10 FOR UPDATE SKIP LOCKED"
  },
  {
    "comment": "Locking with GROUP BY",
    "query": "SELECT user_id, COUNT(*) FROM orders GROUP BY user_id FOR UPDATE"
  },
  {
    "comment": "SELECT with array type cast",
    "query": "SELECT value::INT[]"
  },
  {
    "comment": "SELECT with bounded array type cast",
    "query": "SELECT value::INT[5]"
  },
  {
    "comment": "SELECT with SETOF type cast",
    "query": "SELECT value::SETOF INT"
  },
  {
    "comment": "Nested arithmetic",
    "query": "SELECT ((1 + 2) * (3 - 4))"
  },
  {
    "comment": "Division and modulo",
    "query": "SELECT (10 / 3) % 2"
  },
  {
    "comment": "Power operator",
    "query": "SELECT 2 ^ 3"
  },
  {
    "comment": "Not equal",
    "query": "SELECT * FROM users WHERE id \u003c\u003e 1"
  },
  {
    "comment": "Less than or equal",
    "query": "SELECT * FROM users WHERE age \u003c= 65"
  },
  {
    "comment": "Greater than or equal",
    "query": "SELECT * FROM users WHERE age \u003e= 18"
  },
  {
    "comment": "Complex AND/OR",
    "query": "SELECT * FROM users WHERE ((active = TRUE OR admin = TRUE) AND NOT deleted)"
  },
  {
    "comment": "Nested NOT",
    "query": "SELECT * FROM users WHERE NOT NOT active"
  },
  {
    "comment": "Arithmetic in WHERE",
    "query": "SELECT * FROM users WHERE (age * 2) \u003e 50"
  },
  {
    "comment": "Function in expression",
    "query": "SELECT * FROM users WHERE length(name) \u003e 5"
  },
  {
    "comment": "Column arithmetic",
    "query": "SELECT age + 1 FROM users"
  },
  {
    "comment": "Column with function",
    "query": "SELECT upper(name) FROM users"
  },
  {
    "comment": "Deeply nested",
    "query": "SELECT (((1 + 2) * 3) - 4) / 5"
  },
  {
    "comment": "Mixed operators",
    "query": "SELECT * FROM users WHERE (age + 5) * 2 \u003e 30"
  },
  {
    "comment": "SELECT * FROM users",
    "query": "SELECT * FROM users"
  },
  {
    "comment": "SELECT id, name FROM users WHERE active = TRUE",
    "query": "SELECT id, name FROM users WHERE active = TRUE"
  },
  {
    "comment": "SELECT DISTINCT department FROM employees",
    "query": "SELECT DISTINCT department FROM employees"
  },
  {
    "comment": "SELECT 1 + 2 * 3",
    "query": "SELECT 1 + 2 * 3"
  },
  {
    "comment": "SELECT age::TEXT FROM users",
    "query": "SELECT age::TEXT FROM users"
  },
  {
    "comment": "SELECT length(name) FROM users",
    "query": "SELECT length(name) FROM users"
  },
  {
    "comment": "SELECT * FROM users WHERE (age \u003e 18 AND active = TRUE)",
    "query": "SELECT * FROM users WHERE (age \u003e 18 AND active = TRUE)"
  },
  {
    "comment": "SELECT id AS user_id, name AS user_name FROM users AS u",
    "query": "SELECT id AS user_id, name AS user_name FROM users AS u"
  },
  {
    "comment": "SELECT * FROM users, orders WHERE users.id = orders.user_id",
    "query": "SELECT * FROM users, orders WHERE users.id = orders.user_id"
  },
  {
    "comment": "TABLE users",
    "query": "TABLE users",
    "expected": "SELECT * FROM users"
  },
  {
    "comment": "SELECT * FROM ONLY users",
    "query": "SELECT * FROM ONLY users"
  },
  {
    "comment": "SELECT * INTO backup FROM users",
    "query": "SELECT * INTO backup FROM users"
  },
  {
    "comment": "Simple function table",
    "query": "SELECT * FROM generate_series(1, 5)"
  },
  {
    "comment": "Function table with ORDINALITY",
    "query": "SELECT * FROM generate_series(1, 5) WITH ORDINALITY"
  },
  {
    "comment": "LATERAL function table",
    "query": "SELECT * FROM LATERAL generate_series(1, t.max_val)"
  },
  {
    "comment": "Function table with alias",
    "query": "SELECT * FROM generate_series(1, 5) AS t"
  },
  {
    "comment": "Basic XMLTABLE",
    "query": "SELECT * FROM XMLTABLE('/root/item' PASSING '\u003croot\u003e\u003citem\u003e1\u003c/item\u003e\u003c/root\u003e' COLUMNS id INT, name TEXT)"
  },
  {
    "comment": "XMLTABLE with FOR ORDINALITY",
    "query": "SELECT * FROM XMLTABLE('/root/item' PASSING '\u003croot\u003e\u003citem\u003e1\u003c/item\u003e\u003c/root\u003e' COLUMNS pos FOR ORDINALITY, id INT)"
  },
  {
    "comment": "LATERAL XMLTABLE",
    "query": "SELECT * FROM LATERAL XMLTABLE('/root/item' PASSING t.xml_data COLUMNS id INT)"
  },
  {
    "comment": "Column alias with AS",
    "query": "SELECT id AS user_id"
  },
  {
    "comment": "Column alias without AS",
    "query": "SELECT id user_id",
    "expected": "SELECT id AS user_id"
  },
  {
    "comment": "Multiple column aliases",
    "query": "SELECT id AS user_id, name AS user_name"
  },
  {
    "comment": "Table alias with AS",
    "query": "SELECT * FROM users AS u"
  },
  {
    "comment": "Table alias without AS",
    "query": "SELECT * FROM users u",
    "expected": "SELECT * FROM users AS u"
  },
  {
    "comment": "Complex aliases",
    "query": "SELECT u.id AS user_id FROM users AS u"
  },
  {
    "comment": "Function with alias",
    "query": "SELECT length(name) AS name_length FROM users"
  },
  {
    "comment": "Expression with alias",
    "query": "SELECT age + 1 AS next_age FROM users"
  },
  {
    "comment": "simple limit",
    "query": "SELECT * FROM users LIMIT 10"
  },
  {
    "comment": "limit with offset",
    "query": "SELECT * FROM users LIMIT 10 OFFSET 5"
  },
  {
    "comment": "fetch first only",
    "query": "SELECT * FROM users FETCH FIRST 10 ROWS ONLY",
    "expected": "SELECT * FROM users LIMIT 10"
  },
  {
    "comment": "fetch first with ties",
    "query": "SELECT * FROM users ORDER BY id FETCH FIRST 5 ROWS WITH TIES"
  },
  {
    "comment": "offset with rows",
    "query": "SELECT * FROM users OFFSET 10 ROWS",
    "expected": "SELECT * FROM users OFFSET 10"
  },
  {
    "comment": "complex query",
    "query": "SELECT name, COUNT(*) FROM users WHERE active = true GROUP BY name ORDER BY COUNT(*) DESC LIMIT 20 OFFSET 10",
    "expected": "SELECT name, COUNT(*) FROM users WHERE active = TRUE GROUP BY name ORDER BY COUNT(*) DESC LIMIT 20 OFFSET 10"
  },
  {
    "comment": "simple LIMIT",
    "query": "SELECT * FROM users LIMIT 10"
  },
  {
    "comment": "LIMIT with expression",
    "query": "SELECT * FROM users LIMIT 5 + 5"
  },
  {
    "comment": "LIMIT ALL",
    "query": "SELECT * FROM users LIMIT ALL"
  },
  {
    "comment": "simple OFFSET",
    "query": "SELECT * FROM users OFFSET 20"
  },
  {
    "comment": "OFFSET with expression",
    "query": "SELECT * FROM users OFFSET 10 * 2"
  },
  {
    "comment": "LIMIT and OFFSET",
    "query": "SELECT * FROM users LIMIT 10 OFFSET 20"
  },
  {
    "comment": "OFFSET before LIMIT",
    "query": "SELECT * FROM users OFFSET 20 LIMIT 10",
    "expected": "SELECT * FROM users LIMIT 10 OFFSET 20"
  },
  {
    "comment": "FETCH FIRST ROW ONLY",
    "query": "SELECT * FROM users FETCH FIRST ROW ONLY",
    "expected": "SELECT * FROM users LIMIT 1"
  },
  {
    "comment": "FETCH FIRST ROWS ONLY (implicit 1)",
    "query": "SELECT * FROM users FETCH FIRST ROWS ONLY",
    "expected": "SELECT * FROM users LIMIT 1"
  },
  {
    "comment": "FETCH NEXT ROW ONLY",
    "query": "SELECT * FROM users FETCH NEXT ROW ONLY",
    "expected": "SELECT * FROM users LIMIT 1"
  },
  {
    "comment": "FETCH FIRST 5 ROWS ONLY",
    "query": "SELECT * FROM users FETCH FIRST 5 ROWS ONLY",
    "expected": "SELECT * FROM users LIMIT 5"
  },
  {
    "comment": "FETCH NEXT 10 ROWS ONLY",
    "query": "SELECT * FROM users FETCH NEXT 10 ROWS ONLY",
    "expected": "SELECT * FROM users LIMIT 10"
  },
  {
    "comment": "FETCH FIRST ROW WITH TIES",
    "query": "SELECT * FROM users ORDER BY score FETCH FIRST ROW WITH TIES"
  },
  {
    "comment": "FETCH FIRST 5 ROWS WITH TIES",
    "query": "SELECT * FROM users ORDER BY score FETCH FIRST 5 ROWS WITH TIES"
  },
  {
    "comment": "OFFSET with ROWS keyword",
    "query": "SELECT * FROM users OFFSET 10 ROWS",
    "expected": "SELECT * FROM users OFFSET 10"
  },
  {
    "comment": "OFFSET with ROW keyword",
    "query": "SELECT * FROM users OFFSET 1 ROW",
    "expected": "SELECT * FROM users OFFSET 1"
  },
  {
    "comment": "OFFSET and FETCH FIRST",
    "query": "SELECT * FROM users OFFSET 20 FETCH FIRST 10 ROWS ONLY",
    "expected": "SELECT * FROM users LIMIT 10 OFFSET 20"
  },
  {
    "comment": "ORDER BY with LIMIT",
    "query": "SELECT * FROM users ORDER BY name LIMIT 10"
  },
  {
    "comment": "ORDER BY with FETCH FIRST WITH TIES",
    "query": "SELECT * FROM users ORDER BY score DESC FETCH FIRST 5 ROWS WITH TIES"
  },
  {
    "comment": "WHERE with LIMIT and OFFSET",
    "query": "SELECT * FROM users WHERE active = true OFFSET 50 LIMIT 25",
    "expected": "SELECT * FROM users WHERE active = TRUE LIMIT 25 OFFSET 50"
  },
  {
    "comment": "Complex query with CTE and FETCH",
    "query": "WITH top_users AS (SELECT * FROM users ORDER BY score DESC FETCH FIRST 20 ROWS ONLY) SELECT * FROM top_users",
    "expected": "WITH top_users AS (SELECT * FROM users ORDER BY score DESC LIMIT 20) SELECT * FROM top_users"
  },
  {
    "comment": "Subquery with LIMIT",
    "query": "SELECT * FROM (SELECT * FROM users LIMIT 10) AS u WHERE u.age \u003e 25"
  },
  {
    "comment": "Simple function table",
    "query": "SELECT * FROM generate_series(1, 5)"
  },
  {
    "comment": "Function table with ORDINALITY",
    "query": "SELECT * FROM generate_series(1, 5) WITH ORDINALITY"
  },
  {
    "comment": "LATERAL function table",
    "query": "SELECT * FROM LATERAL generate_series(1, t.max_val)"
  },
  {
    "comment": "ROWS FROM syntax",
    "query": "SELECT * FROM ROWS FROM (generate_series(1, 5))"
  },
  {
    "comment": "ROWS FROM with ORDINALITY",
    "query": "SELECT * FROM ROWS FROM (generate_series(1, 5)) WITH ORDINALITY"
  },
  {
    "comment": "Basic XMLTABLE",
    "query": "SELECT * FROM XMLTABLE('/root/item' PASSING '\u003croot\u003e\u003citem\u003e1\u003c/item\u003e\u003c/root\u003e' COLUMNS id INT, name TEXT)"
  },
  {
    "comment": "XMLTABLE with FOR ORDINALITY",
    "query": "SELECT * FROM XMLTABLE('/root/item' PASSING '\u003croot\u003e\u003citem\u003e1\u003c/item\u003e\u003c/root\u003e' COLUMNS pos FOR ORDINALITY, id INT)"
  },
  {
    "comment": "LATERAL XMLTABLE",
    "query": "SELECT * FROM LATERAL XMLTABLE('/root/item' PASSING t.xml_data COLUMNS id INT)"
  },
  {
    "comment": "Basic JSON_TABLE",
    "query": "SELECT * FROM JSON_TABLE('{}', '$' COLUMNS (id INT))"
  },
  {
    "comment": "JSON_TABLE with FOR ORDINALITY",
    "query": "SELECT * FROM JSON_TABLE('{\"items\": [1, 2, 3]}', '$.items[*]' COLUMNS (pos FOR ORDINALITY, val INT PATH '$'))"
  },
  {
    "comment": "JSON_TABLE with EXISTS column",
    "query": "SELECT * FROM JSON_TABLE('{\"items\": [{\"id\": 1}]}', '$.items[*]' COLUMNS (has_id BOOLEAN EXISTS PATH '$.id'))"
  },
  {
    "comment": "JSON_TABLE with NESTED columns",
    "query": "SELECT * FROM JSON_TABLE('{\"items\": [{\"props\": {\"a\": 1}}]}', '$.items[*]' COLUMNS (NESTED PATH '$.props' COLUMNS (a INT PATH '$.a')))"
  },
  {
    "comment": "LATERAL JSON_TABLE",
    "query": "SELECT * FROM LATERAL JSON_TABLE(t.json_data, '$.items[*]' COLUMNS (id INT PATH '$.id'))"
  },
  {
    "comment": "Function table with alias",
    "query": "SELECT * FROM generate_series(1, 5) AS t"
  },
  {
    "comment": "XMLTABLE with alias",
    "query": "SELECT * FROM XMLTABLE('/root/item' PASSING '\u003croot\u003e\u003c/root\u003e' COLUMNS id INT) AS xt"
  },
  {
    "comment": "JSON_TABLE with alias",
    "query": "SELECT * FROM JSON_TABLE('[]', '$[*]' COLUMNS (id INT)) AS jt"
  },
  {
    "comment": "Function table with column aliases",
    "query": "SELECT * FROM generate_series(1, 5) AS t(num)"
  },
  {
    "comment": "MATERIALIZED CTE deparsing",
    "query": "WITH stats AS MATERIALIZED (SELECT COUNT(a) FROM users) SELECT * FROM stats"
  },
  {
    "comment": "NOT MATERIALIZED CTE deparsing",
    "query": "WITH stats AS NOT MATERIALIZED (SELECT COUNT(a) FROM users) SELECT * FROM stats"
  },
  {
    "comment": "RECURSIVE MATERIALIZED CTE",
    "query": "WITH RECURSIVE t AS MATERIALIZED (SELECT 1) SELECT * FROM t"
  },
  {
    "comment": "SEARCH DEPTH FIRST single column",
    "query": "WITH RECURSIVE t AS (SELECT id FROM tree) SEARCH DEPTH FIRST BY id SET seq SELECT * FROM t"
  },
  {
    "comment": "SEARCH BREADTH FIRST single column",
    "query": "WITH RECURSIVE t AS (SELECT id FROM tree) SEARCH BREADTH FIRST BY id SET seq SELECT * FROM t"
  },
  {
    "comment": "CYCLE simple form single column",
    "query": "WITH RECURSIVE t AS (SELECT id FROM tree) CYCLE id SET mark USING path SELECT * FROM t"
  },
  {
    "comment": "CYCLE full form single column",
    "query": "WITH RECURSIVE t AS (SELECT id FROM tree) CYCLE id SET mark TO TRUE DEFAULT FALSE USING path SELECT * FROM t"
  },
  {
    "comment": "MATERIALIZED with SEARCH",
    "query": "WITH RECURSIVE tree AS MATERIALIZED (SELECT id FROM nodes) SEARCH DEPTH FIRST BY id SET search_seq SELECT * FROM tree"
  },
  {
    "comment": "SEARCH with CYCLE",
    "query": "WITH RECURSIVE tree AS (SELECT id FROM nodes) SEARCH DEPTH FIRST BY id SET search_seq CYCLE id SET is_cycle USING path SELECT * FROM tree"
  },
  {
    "comment": "JOIN with table aliases",
    "query": "SELECT u.name, o.total FROM users u INNER JOIN orders o ON u.id = o.user_id",
    "expected": "SELECT u.name, o.total FROM users AS u INNER JOIN orders AS o ON u.id = o.user_id"
  },
  {
    "comment": "JOIN with complex ON condition",
    "query": "SELECT * FROM users u JOIN orders o ON u.id = o.user_id AND u.active = TRUE",
    "expected": "SELECT * FROM users AS u INNER JOIN orders AS o ON u.id = o.user_id AND u.active = TRUE"
  },
  {
    "comment": "NATURAL JOIN with explicit type",
    "query": "SELECT * FROM users NATURAL INNER JOIN orders",
    "expected": "SELECT * FROM users NATURAL JOIN orders"
  },
  {
    "comment": "NATURAL LEFT JOIN",
    "query": "SELECT * FROM users NATURAL LEFT JOIN orders"
  },
  {
    "comment": "NATURAL RIGHT JOIN",
    "query": "SELECT * FROM users NATURAL RIGHT JOIN orders"
  },
  {
    "comment": "NATURAL FULL JOIN",
    "query": "SELECT * FROM users NATURAL FULL JOIN orders"
  },
  {
    "comment": "LATERAL with simple subquery",
    "query": "SELECT * FROM users u, LATERAL (SELECT * FROM orders o WHERE o.user_id = u.id) AS recent_orders",
    "expected": "SELECT * FROM users AS u, LATERAL (SELECT * FROM orders AS o WHERE o.user_id = u.id) AS recent_orders"
  },
  {
    "comment": "Nested subqueries in FROM",
    "query": "SELECT * FROM (SELECT id FROM (SELECT user_id AS id FROM orders) AS inner_sub) AS outer_sub"
  },
  {
    "comment": "Addition and multiplication",
    "query": "SELECT 1 + 2 * 3"
  },
  {
    "comment": "Parentheses override precedence",
    "query": "SELECT (1 + 2) * 3"
  },
  {
    "comment": "Multiple operators",
    "query": "SELECT 1 + 2 * 3 - 4 / 2"
  },
  {
    "comment": "Unary and binary",
    "query": "SELECT -1 + 2"
  },
  {
    "comment": "Power has highest precedence",
    "query": "SELECT 2 + 3 ^ 2"
  },
  {
    "comment": "Modulo precedence",
    "query": "SELECT 10 + 5 % 3"
  },
  {
    "comment": "Comparison and logical",
    "query": "SELECT * FROM users WHERE age \u003e 18 AND active"
  },
  {
    "comment": "Mixed precedence",
    "query": "SELECT * FROM users WHERE age + 1 \u003e 18 AND NOT deleted"
  },
  {
    "comment": "OR has lower precedence than AND",
    "query": "SELECT * FROM users WHERE active AND verified OR admin"
  },
  {
    "comment": "Parentheses with logical",
    "query": "SELECT * FROM users WHERE (active OR admin) AND verified"
  },
  {
    "comment": "Deeply nested arithmetic",
    "query": "SELECT ((1 + 2) * 3) - (4 / 2)"
  },
  {
    "comment": "Mixed arithmetic and comparison",
    "query": "SELECT * FROM users WHERE (age * 2) + 5 \u003e 30"
  },
  {
    "comment": "Function call precedence",
    "query": "SELECT length(name) + 10 FROM users"
  },
  {
    "comment": "Type cast precedence",
    "query": "SELECT age::text FROM users",
    "expected": "SELECT age::TEXT FROM users"
  },
  {
    "comment": "Complex WHERE precedence",
    "query": "SELECT * FROM users WHERE id = 1 OR id = 2 AND active"
  },
  {
    "comment": "WHERE with parentheses",
    "query": "SELECT * FROM users WHERE (id = 1 OR id = 2) AND active"
  },
  {
    "comment": "NOT precedence",
    "query": "SELECT * FROM users WHERE NOT active AND verified"
  },
  {
    "comment": "NOT with parentheses",
    "query": "SELECT * FROM users WHERE NOT (active AND verified)"
  },
  {
    "comment": "Simple SELECT star",
    "query": "SELECT *"
  },
  {
    "comment": "SELECT single column",
    "query": "SELECT id"
  },
  {
    "comment": "SELECT with column alias AS",
    "query": "SELECT id AS user_id"
  },
  {
    "comment": "SELECT with column alias implicit",
    "query": "SELECT id user_id",
    "expected": "SELECT id AS user_id"
  },
  {
    "comment": "SELECT multiple columns",
    "query": "SELECT id, name"
  },
  {
    "comment": "SELECT all columns from table",
    "query": "SELECT * FROM users"
  },
  {
    "comment": "FROM with table alias AS",
    "query": "SELECT * FROM users AS u"
  },
  {
    "comment": "FROM with table alias implicit",
    "query": "SELECT * FROM users u",
    "expected": "SELECT * FROM users AS u"
  },
  {
    "comment": "FROM with qualified table",
    "query": "SELECT * FROM public.users"
  },
  {
    "comment": "FROM with ONLY modifier",
    "query": "SELECT * FROM ONLY users"
  },
  {
    "comment": "FROM multiple tables",
    "query": "SELECT * FROM users, orders"
  },
  {
    "comment": "SELECT without FROM",
    "query": "SELECT 1"
  },
  {
    "comment": "SELECT DISTINCT single",
    "query": "SELECT DISTINCT id"
  },
  {
    "comment": "SELECT DISTINCT multiple",
    "query": "SELECT DISTINCT id, name"
  },
  {
    "comment": "SELECT DISTINCT ON single",
    "query": "SELECT DISTINCT ON (id) name"
  },
  {
    "comment": "SELECT DISTINCT ON multiple",
    "query": "SELECT DISTINCT ON (department, level) name"
  },
  {
    "comment": "WHERE simple boolean",
    "query": "SELECT * FROM users WHERE active"
  },
  {
    "comment": "WHERE equality",
    "query": "SELECT * FROM users WHERE id = 1"
  },
  {
    "comment": "WHERE not equal",
    "query": "SELECT * FROM users WHERE id \u003c\u003e 1"
  },
  {
    "comment": "WHERE less than",
    "query": "SELECT * FROM users WHERE age \u003c 30"
  },
  {
    "comment": "WHERE greater than",
    "query": "SELECT * FROM users WHERE age \u003e 18"
  },
  {
    "comment": "WHERE less or equal",
    "query": "SELECT * FROM users WHERE age \u003c= 65"
  },
  {
    "comment": "WHERE greater or equal",
    "query": "SELECT * FROM users WHERE age \u003e= 18"
  },
  {
    "comment": "WHERE complex AND",
    "query": "SELECT * FROM users WHERE id \u003e 10 AND active = TRUE"
  },
  {
    "comment": "WHERE complex OR",
    "query": "SELECT * FROM users WHERE admin = TRUE OR moderator = TRUE"
  },
  {
    "comment": "WHERE complex NOT",
    "query": "SELECT * FROM users WHERE NOT deleted"
  },
  {
    "comment": "WHERE mixed logical",
    "query": "SELECT * FROM users WHERE (active = TRUE OR admin = TRUE) AND NOT deleted"
  },
  {
    "comment": "Arithmetic addition",
    "query": "SELECT 1 + 2"
  },
  {
    "comment": "Arithmetic subtraction",
    "query": "SELECT 5 - 3"
  },
  {
    "comment": "Arithmetic multiplication",
    "query": "SELECT 4 * 6"
  },
  {
    "comment": "Arithmetic division",
    "query": "SELECT 10 / 2"
  },
  {
    "comment": "Arithmetic modulo",
    "query": "SELECT 10 % 3"
  },
  {
    "comment": "Arithmetic power",
    "query": "SELECT 2 ^ 3"
  },
  {
    "comment": "Unary plus",
    "query": "SELECT +42"
  },
  {
    "comment": "Unary minus",
    "query": "SELECT -42"
  },
  {
    "comment": "Complex arithmetic",
    "query": "SELECT (1 + 2) * 3 - 4 / 2"
  },
  {
    "comment": "Column arithmetic",
    "query": "SELECT age + 1 FROM users"
  },
  {
    "comment": "Mixed arithmetic",
    "query": "SELECT id + age * 2 FROM users"
  },
  {
    "comment": "Type cast to text",
    "query": "SELECT id::text FROM users",
    "expected": "SELECT id::TEXT FROM users"
  },
  {
    "comment": "Type cast with spaces",
    "query": "SELECT id :: integer FROM users",
    "expected": "SELECT id::INT FROM users"
  },
  {
    "comment": "Complex expression cast",
    "query": "SELECT (age + 1)::varchar FROM users",
    "expected": "SELECT (age + 1)::VARCHAR FROM users"
  },
  {
    "comment": "Multiple casts",
    "query": "SELECT id::text, age::varchar FROM users",
    "expected": "SELECT id::TEXT, age::VARCHAR FROM users"
  },
  {
    "comment": "Simple column reference",
    "query": "SELECT id FROM users"
  },
  {
    "comment": "Qualified column reference",
    "query": "SELECT users.id FROM users"
  },
  {
    "comment": "Schema qualified column",
    "query": "SELECT public.users.id FROM public.users"
  },
  {
    "comment": "Multiple qualified columns",
    "query": "SELECT u.id, u.name FROM users AS u"
  },
  {
    "comment": "Function no args",
    "query": "SELECT now()",
    "expected": "SELECT NOW()"
  },
  {
    "comment": "Function single arg",
    "query": "SELECT length(name) FROM users"
  },
  {
    "comment": "Function multiple args",
    "query": "SELECT substring(name, 1, 5) FROM users"
  },
  {
    "comment": "Qualified function",
    "query": "SELECT my_catalog.length(name) FROM users"
  },
  {
    "comment": "Nested functions",
    "query": "SELECT upper(trim(name)) FROM users"
  },
  {
    "comment": "Function in WHERE",
    "query": "SELECT * FROM users WHERE length(name) \u003e 5"
  },
  {
    "comment": "Integer constant",
    "query": "SELECT 42"
  },
  {
    "comment": "Negative integer",
    "query": "SELECT -123"
  },
  {
    "comment": "Float constant",
    "query": "SELECT 3.14"
  },
  {
    "comment": "String literal",
    "query": "SELECT 'hello world'"
  },
  {
    "comment": "Boolean TRUE",
    "query": "SELECT TRUE"
  },
  {
    "comment": "Boolean FALSE",
    "query": "SELECT FALSE"
  },
  {
    "comment": "NULL constant",
    "query": "SELECT NULL"
  },
  {
    "comment": "SELECT INTO basic",
    "query": "SELECT * INTO backup_users FROM users"
  },
  {
    "comment": "SELECT INTO with WHERE",
    "query": "SELECT id, name INTO temp_users FROM users WHERE active = TRUE"
  },
  {
    "comment": "TABLE statement",
    "query": "TABLE users",
    "expected": "SELECT * FROM users"
  },
  {
    "comment": "TABLE with qualified name",
    "query": "TABLE public.users",
    "expected": "SELECT * FROM public.users"
  },
  {
    "comment": "Complex SELECT with all features",
    "query": "SELECT u.id AS user_id, upper(u.name) AS user_name FROM users AS u WHERE u.active = TRUE AND u.age \u003e 18"
  },
  {
    "comment": "Multiple expressions with aliases",
    "query": "SELECT id AS user_id, name AS user_name, age + 1 AS next_age FROM users"
  },
  {
    "comment": "Arithmetic in WHERE with functions",
    "query": "SELECT * FROM users WHERE length(name) + age \u003e 25"
  },
  {
    "comment": "column list in function",
    "query": "SELECT func(a, b, c)"
  },
  {
    "comment": "multiple column references",
    "query": "SELECT a, b, c FROM table1"
  },
  {
    "comment": "qualified column list",
    "query": "SELECT t1.a, t2.b, t3.c FROM t1, t2, t3"
  },
  {
    "comment": "array subscript",
    "query": "SELECT column_val[1]"
  },
  {
    "comment": "array slice",
    "query": "SELECT column_val[1:5]"
  },
  {
    "comment": "field access",
    "query": "SELECT record.field"
  },
  {
    "comment": "nested field access",
    "query": "SELECT record.subrecord.field"
  },
  {
    "comment": "mixed indirection",
    "query": "SELECT array_col[1].field"
  },
  {
    "comment": "qualified operator",
    "query": "SELECT a OPERATOR(pg_catalog.+) b"
  },
  {
    "comment": "schema qualified operator",
    "query": "SELECT a OPERATOR(myschema.=) b"
  },
  {
    "comment": "custom operator",
    "query": "SELECT a OPERATOR(public.@@) b"
  },
  {
    "comment": "bit type casting",
    "query": "SELECT value::bit"
  },
  {
    "comment": "bit with length",
    "query": "SELECT value::bit(8)"
  },
  {
    "comment": "timestamp type",
    "query": "SELECT value::TIMESTAMP"
  },
  {
    "comment": "timestamp with precision",
    "query": "SELECT value::timestamp(6)",
    "expected": "SELECT value::TIMESTAMP(6)"
  },
  {
    "comment": "timestamptz type",
    "query": "SELECT value::timestamptz",
    "expected": "SELECT value::TIMESTAMP WITH TIME ZONE"
  },
  {
    "comment": "date type",
    "query": "SELECT value::DATE"
  },
  {
    "comment": "time type",
    "query": "SELECT value::TIME"
  },
  {
    "comment": "interval type",
    "query": "SELECT value::INTERVAL"
  },
  {
    "comment": "select all",
    "query": "SELECT ALL * FROM users",
    "expected": "SELECT * FROM users"
  },
  {
    "comment": "select all with columns",
    "query": "SELECT ALL id, name FROM users",
    "expected": "SELECT id, name FROM users"
  },
  {
    "comment": "select all with where",
    "query": "SELECT ALL * FROM users WHERE active = true",
    "expected": "SELECT * FROM users WHERE active = TRUE"
  },
  {
    "comment": "two simple statements",
    "query": "SELECT 1; SELECT 2"
  },
  {
    "comment": "multiple statements with different types",
    "query": "SELECT * FROM users; SELECT name FROM orders"
  },
  {
    "comment": "statements with whitespace",
    "query": "SELECT 1;   SELECT 2;   SELECT 3",
    "expected": "SELECT 1; SELECT 2; SELECT 3"
  },
  {
    "comment": "trailing semicolon",
    "query": "SELECT 1; SELECT 2;",
    "expected": "SELECT 1; SELECT 2"
  }
]
