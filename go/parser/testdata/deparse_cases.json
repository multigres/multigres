[
  {
    "comment": "Nested arithmetic",
    "query": "SELECT ((1 + 2) * (3 - 4))"
  },
  {
    "comment": "Division and modulo",
    "query": "SELECT (10 / 3) % 2"
  },
  {
    "comment": "Power operator",
    "query": "SELECT 2 ^ 3"
  },
  {
    "comment": "Not equal",
    "query": "SELECT * FROM users WHERE id \u003c\u003e 1"
  },
  {
    "comment": "Less than or equal",
    "query": "SELECT * FROM users WHERE age \u003c= 65"
  },
  {
    "comment": "Greater than or equal",
    "query": "SELECT * FROM users WHERE age \u003e= 18"
  },
  {
    "comment": "Complex AND/OR",
    "query": "SELECT * FROM users WHERE ((active = TRUE OR admin = TRUE) AND NOT deleted)"
  },
  {
    "comment": "Nested NOT",
    "query": "SELECT * FROM users WHERE NOT NOT active"
  },
  {
    "comment": "Arithmetic in WHERE",
    "query": "SELECT * FROM users WHERE (age * 2) \u003e 50"
  },
  {
    "comment": "Function in expression",
    "query": "SELECT * FROM users WHERE length(name) \u003e 5"
  },
  {
    "comment": "Column arithmetic",
    "query": "SELECT age + 1 FROM users"
  },
  {
    "comment": "Column with function",
    "query": "SELECT upper(name) FROM users"
  },
  {
    "comment": "Deeply nested",
    "query": "SELECT (((1 + 2) * 3) - 4) / 5"
  },
  {
    "comment": "Mixed operators",
    "query": "SELECT * FROM users WHERE (age + 5) * 2 \u003e 30"
  },
  {
    "comment": "SELECT * FROM users",
    "query": "SELECT * FROM users"
  },
  {
    "comment": "SELECT id, name FROM users WHERE active = TRUE",
    "query": "SELECT id, name FROM users WHERE active = TRUE"
  },
  {
    "comment": "SELECT DISTINCT department FROM employees",
    "query": "SELECT DISTINCT department FROM employees"
  },
  {
    "comment": "SELECT 1 + 2 * 3",
    "query": "SELECT 1 + 2 * 3"
  },
  {
    "comment": "SELECT age::TEXT FROM users",
    "query": "SELECT age::TEXT FROM users"
  },
  {
    "comment": "SELECT length(name) FROM users",
    "query": "SELECT length(name) FROM users"
  },
  {
    "comment": "SELECT * FROM users WHERE (age \u003e 18 AND active = TRUE)",
    "query": "SELECT * FROM users WHERE (age \u003e 18 AND active = TRUE)"
  },
  {
    "comment": "SELECT id AS user_id, name AS user_name FROM users AS u",
    "query": "SELECT id AS user_id, name AS user_name FROM users AS u"
  },
  {
    "comment": "SELECT * FROM users, orders WHERE users.id = orders.user_id",
    "query": "SELECT * FROM users, orders WHERE users.id = orders.user_id"
  },
  {
    "comment": "TABLE users",
    "query": "TABLE users",
    "expected": "SELECT * FROM users"
  },
  {
    "comment": "SELECT * FROM ONLY users",
    "query": "SELECT * FROM ONLY users"
  },
  {
    "comment": "SELECT * INTO backup FROM users",
    "query": "SELECT * INTO backup FROM users"
  },
  {
    "comment": "COPY users FROM '/path/to/file.csv'",
    "query": "COPY users FROM '/path/to/file.csv'"
  },
  {
    "comment": "COPY users FROM '/path/to/file.csv' (format 'csv')",
    "query": "COPY users FROM '/path/to/file.csv' (format 'csv')"
  },
  {
    "comment": "COPY users (id, name) FROM '/path/to/file.csv' (format 'csv')",
    "query": "COPY users (id, name) FROM '/path/to/file.csv' (format 'csv')"
  },
  {
    "comment": "COPY users TO '/path/to/file.csv' (format 'csv', header true)",
    "query": "COPY users TO '/path/to/file.csv' (format 'csv', header true)"
  },
  {
    "comment": "Simple function table",
    "query": "SELECT * FROM generate_series(1, 5)"
  },
  {
    "comment": "Function table with ORDINALITY",
    "query": "SELECT * FROM generate_series(1, 5) WITH ORDINALITY"
  },
  {
    "comment": "LATERAL function table",
    "query": "SELECT * FROM LATERAL generate_series(1, t.max_val)"
  },
  {
    "comment": "Function table with alias",
    "query": "SELECT * FROM generate_series(1, 5) AS t"
  },
  {
    "comment": "Basic XMLTABLE",
    "query": "SELECT * FROM XMLTABLE('/root/item' PASSING '\u003croot\u003e\u003citem\u003e1\u003c/item\u003e\u003c/root\u003e' COLUMNS id INT, name TEXT)"
  },
  {
    "comment": "XMLTABLE with FOR ORDINALITY",
    "query": "SELECT * FROM XMLTABLE('/root/item' PASSING '\u003croot\u003e\u003citem\u003e1\u003c/item\u003e\u003c/root\u003e' COLUMNS pos FOR ORDINALITY, id INT)"
  },
  {
    "comment": "LATERAL XMLTABLE",
    "query": "SELECT * FROM LATERAL XMLTABLE('/root/item' PASSING t.xml_data COLUMNS id INT)"
  },
  {
    "comment": "Column alias with AS",
    "query": "SELECT id AS user_id"
  },
  {
    "comment": "Column alias without AS",
    "query": "SELECT id user_id",
    "expected": "SELECT id AS user_id"
  },
  {
    "comment": "Multiple column aliases",
    "query": "SELECT id AS user_id, name AS user_name"
  },
  {
    "comment": "Table alias with AS",
    "query": "SELECT * FROM users AS u"
  },
  {
    "comment": "Table alias without AS",
    "query": "SELECT * FROM users u",
    "expected": "SELECT * FROM users AS u"
  },
  {
    "comment": "Complex aliases",
    "query": "SELECT u.id AS user_id FROM users AS u"
  },
  {
    "comment": "Function with alias",
    "query": "SELECT length(name) AS name_length FROM users"
  },
  {
    "comment": "Expression with alias",
    "query": "SELECT age + 1 AS next_age FROM users"
  },
  {
    "comment": "simple limit",
    "query": "SELECT * FROM users LIMIT 10"
  },
  {
    "comment": "limit with offset",
    "query": "SELECT * FROM users LIMIT 10 OFFSET 5"
  },
  {
    "comment": "fetch first only",
    "query": "SELECT * FROM users FETCH FIRST 10 ROWS ONLY"
  },
  {
    "comment": "fetch first with ties",
    "query": "SELECT * FROM users ORDER BY id FETCH FIRST 5 ROWS WITH TIES"
  },
  {
    "comment": "offset with rows",
    "query": "SELECT * FROM users OFFSET 10 ROWS"
  },
  {
    "comment": "complex query",
    "query": "SELECT name, COUNT(*) FROM users WHERE active = true GROUP BY name ORDER BY COUNT(*) DESC LIMIT 20 OFFSET 10"
  },
  {
    "comment": "simple LIMIT",
    "query": "SELECT * FROM users LIMIT 10",
    "expected": "SELECT * FROM users LIMIT 10"
  },
  {
    "comment": "LIMIT with expression",
    "query": "SELECT * FROM users LIMIT 5 + 5",
    "expected": "SELECT * FROM users LIMIT 5 + 5"
  },
  {
    "comment": "LIMIT ALL",
    "query": "SELECT * FROM users LIMIT ALL",
    "expected": "SELECT * FROM users LIMIT ALL"
  },
  {
    "comment": "simple OFFSET",
    "query": "SELECT * FROM users OFFSET 20",
    "expected": "SELECT * FROM users OFFSET 20"
  },
  {
    "comment": "OFFSET with expression",
    "query": "SELECT * FROM users OFFSET 10 * 2",
    "expected": "SELECT * FROM users OFFSET 10 * 2"
  },
  {
    "comment": "LIMIT and OFFSET",
    "query": "SELECT * FROM users LIMIT 10 OFFSET 20",
    "expected": "SELECT * FROM users LIMIT 10 OFFSET 20"
  },
  {
    "comment": "OFFSET before LIMIT",
    "query": "SELECT * FROM users OFFSET 20 LIMIT 10",
    "expected": "SELECT * FROM users LIMIT 10 OFFSET 20"
  },
  {
    "comment": "FETCH FIRST ROW ONLY",
    "query": "SELECT * FROM users FETCH FIRST ROW ONLY",
    "expected": "SELECT * FROM users LIMIT 1"
  },
  {
    "comment": "FETCH FIRST ROWS ONLY (implicit 1)",
    "query": "SELECT * FROM users FETCH FIRST ROWS ONLY",
    "expected": "SELECT * FROM users LIMIT 1"
  },
  {
    "comment": "FETCH NEXT ROW ONLY",
    "query": "SELECT * FROM users FETCH NEXT ROW ONLY",
    "expected": "SELECT * FROM users LIMIT 1"
  },
  {
    "comment": "FETCH FIRST 5 ROWS ONLY",
    "query": "SELECT * FROM users FETCH FIRST 5 ROWS ONLY",
    "expected": "SELECT * FROM users LIMIT 5"
  },
  {
    "comment": "FETCH NEXT 10 ROWS ONLY",
    "query": "SELECT * FROM users FETCH NEXT 10 ROWS ONLY",
    "expected": "SELECT * FROM users LIMIT 10"
  },
  {
    "comment": "FETCH FIRST ROW WITH TIES",
    "query": "SELECT * FROM users ORDER BY score FETCH FIRST ROW WITH TIES",
    "expected": "SELECT * FROM users ORDER BY score FETCH FIRST ROW WITH TIES"
  },
  {
    "comment": "FETCH FIRST 5 ROWS WITH TIES",
    "query": "SELECT * FROM users ORDER BY score FETCH FIRST 5 ROWS WITH TIES",
    "expected": "SELECT * FROM users ORDER BY score FETCH FIRST 5 ROWS WITH TIES"
  },
  {
    "comment": "OFFSET with ROWS keyword",
    "query": "SELECT * FROM users OFFSET 10 ROWS",
    "expected": "SELECT * FROM users OFFSET 10"
  },
  {
    "comment": "OFFSET with ROW keyword",
    "query": "SELECT * FROM users OFFSET 1 ROW",
    "expected": "SELECT * FROM users OFFSET 1"
  },
  {
    "comment": "OFFSET and FETCH FIRST",
    "query": "SELECT * FROM users OFFSET 20 FETCH FIRST 10 ROWS ONLY",
    "expected": "SELECT * FROM users LIMIT 10 OFFSET 20"
  },
  {
    "comment": "ORDER BY with LIMIT",
    "query": "SELECT * FROM users ORDER BY name LIMIT 10",
    "expected": "SELECT * FROM users ORDER BY name LIMIT 10"
  },
  {
    "comment": "ORDER BY with FETCH FIRST WITH TIES",
    "query": "SELECT * FROM users ORDER BY score DESC FETCH FIRST 5 ROWS WITH TIES",
    "expected": "SELECT * FROM users ORDER BY score DESC FETCH FIRST 5 ROWS WITH TIES"
  },
  {
    "comment": "WHERE with LIMIT and OFFSET",
    "query": "SELECT * FROM users WHERE active = true OFFSET 50 LIMIT 25",
    "expected": "SELECT * FROM users WHERE active = TRUE LIMIT 25 OFFSET 50"
  },
  {
    "comment": "Complex query with CTE and FETCH",
    "query": "WITH top_users AS (SELECT * FROM users ORDER BY score DESC FETCH FIRST 20 ROWS ONLY) SELECT * FROM top_users",
    "expected": "WITH top_users AS (SELECT * FROM users ORDER BY score DESC LIMIT 20) SELECT * FROM top_users"
  },
  {
    "comment": "Subquery with LIMIT",
    "query": "SELECT * FROM (SELECT * FROM users LIMIT 10) AS u WHERE u.age \u003e 25",
    "expected": "SELECT * FROM (SELECT * FROM users LIMIT 10) AS u WHERE u.age \u003e 25"
  },
  {
    "comment": "TABLE without IF EXISTS",
    "query": "ALTER TABLE users RENAME TO customers"
  },
  {
    "comment": "TABLE with IF EXISTS",
    "query": "ALTER TABLE IF EXISTS users RENAME TO customers"
  },
  {
    "comment": "INDEX without IF EXISTS",
    "query": "ALTER INDEX users_idx RENAME TO customers_idx"
  },
  {
    "comment": "INDEX with IF EXISTS",
    "query": "ALTER INDEX IF EXISTS users_idx RENAME TO customers_idx"
  },
  {
    "comment": "VIEW without IF EXISTS",
    "query": "ALTER VIEW user_view RENAME TO customer_view"
  },
  {
    "comment": "VIEW with IF EXISTS",
    "query": "ALTER VIEW IF EXISTS user_view RENAME TO customer_view"
  },
  {
    "comment": "SEQUENCE without IF EXISTS",
    "query": "ALTER SEQUENCE user_id_seq RENAME TO customer_id_seq"
  },
  {
    "comment": "SEQUENCE with IF EXISTS",
    "query": "ALTER SEQUENCE IF EXISTS user_id_seq RENAME TO customer_id_seq"
  },
  {
    "comment": "MATERIALIZED VIEW without IF EXISTS",
    "query": "ALTER MATERIALIZED VIEW mat_view RENAME TO new_mat_view"
  },
  {
    "comment": "MATERIALIZED VIEW with IF EXISTS",
    "query": "ALTER MATERIALIZED VIEW IF EXISTS mat_view RENAME TO new_mat_view"
  },
  {
    "comment": "FOREIGN TABLE without IF EXISTS",
    "query": "ALTER FOREIGN TABLE foreign_users RENAME TO foreign_customers"
  },
  {
    "comment": "FOREIGN TABLE with IF EXISTS",
    "query": "ALTER FOREIGN TABLE IF EXISTS foreign_users RENAME TO foreign_customers"
  },
  {
    "comment": "COLUMN without IF EXISTS",
    "query": "ALTER TABLE users RENAME COLUMN name TO full_name"
  },
  {
    "comment": "COLUMN with IF EXISTS",
    "query": "ALTER TABLE IF EXISTS users RENAME COLUMN name TO full_name"
  },
  {
    "comment": "CONSTRAINT without IF EXISTS",
    "query": "ALTER TABLE users RENAME CONSTRAINT old_c TO new_c"
  },
  {
    "comment": "CONSTRAINT with IF EXISTS",
    "query": "ALTER TABLE IF EXISTS users RENAME CONSTRAINT old_c TO new_c"
  },
  {
    "comment": "DATABASE",
    "query": "ALTER DATABASE old_db RENAME TO new_db"
  },
  {
    "comment": "SCHEMA",
    "query": "ALTER SCHEMA old_schema RENAME TO new_schema"
  },
  {
    "comment": "ROLE",
    "query": "ALTER ROLE old_role RENAME TO new_role"
  },
  {
    "comment": "USER",
    "query": "ALTER USER old_user RENAME TO new_user"
  },
  {
    "comment": "GROUP",
    "query": "ALTER GROUP old_group RENAME TO new_group"
  },
  {
    "comment": "TABLESPACE",
    "query": "ALTER TABLESPACE old_ts RENAME TO new_ts"
  },
  {
    "comment": "DOMAIN",
    "query": "ALTER DOMAIN old_domain RENAME TO new_domain"
  },
  {
    "comment": "DOMAIN CONSTRAINT",
    "query": "ALTER DOMAIN my_domain RENAME CONSTRAINT old_check TO new_check"
  },
  {
    "comment": "TYPE",
    "query": "ALTER TYPE old_type RENAME TO new_type"
  },
  {
    "comment": "TYPE ATTRIBUTE",
    "query": "ALTER TYPE my_type RENAME ATTRIBUTE old_attr TO new_attr"
  },
  {
    "comment": "FUNCTION",
    "query": "ALTER FUNCTION old_func() RENAME TO new_func"
  },
  {
    "comment": "PROCEDURE",
    "query": "ALTER PROCEDURE old_proc() RENAME TO new_proc"
  },
  {
    "comment": "ROUTINE",
    "query": "ALTER ROUTINE old_routine() RENAME TO new_routine"
  },
  {
    "comment": "AGGREGATE",
    "query": "ALTER AGGREGATE old_agg() RENAME TO new_agg"
  },
  {
    "comment": "COLLATION",
    "query": "ALTER COLLATION old_collation RENAME TO new_collation"
  },
  {
    "comment": "CONVERSION",
    "query": "ALTER CONVERSION old_conv RENAME TO new_conv"
  },
  {
    "comment": "LANGUAGE",
    "query": "ALTER LANGUAGE old_lang RENAME TO new_lang"
  },
  {
    "comment": "PROCEDURAL LANGUAGE",
    "query": "ALTER PROCEDURAL LANGUAGE old_lang RENAME TO new_lang"
  },
  {
    "comment": "OPERATOR CLASS",
    "query": "ALTER OPERATOR CLASS old_class USING btree RENAME TO new_class"
  },
  {
    "comment": "OPERATOR FAMILY",
    "query": "ALTER OPERATOR FAMILY old_family USING btree RENAME TO new_family"
  },
  {
    "comment": "POLICY",
    "query": "ALTER POLICY old_policy ON users RENAME TO new_policy"
  },
  {
    "comment": "RULE",
    "query": "ALTER RULE old_rule ON users RENAME TO new_rule"
  },
  {
    "comment": "TRIGGER",
    "query": "ALTER TRIGGER old_trigger ON users RENAME TO new_trigger"
  },
  {
    "comment": "EVENT TRIGGER",
    "query": "ALTER EVENT TRIGGER old_event_trigger RENAME TO new_event_trigger"
  },
  {
    "comment": "PUBLICATION",
    "query": "ALTER PUBLICATION old_pub RENAME TO new_pub"
  },
  {
    "comment": "SUBSCRIPTION",
    "query": "ALTER SUBSCRIPTION old_sub RENAME TO new_sub"
  },
  {
    "comment": "FOREIGN DATA WRAPPER",
    "query": "ALTER FOREIGN DATA WRAPPER old_fdw RENAME TO new_fdw"
  },
  {
    "comment": "SERVER",
    "query": "ALTER SERVER old_server RENAME TO new_server"
  },
  {
    "comment": "STATISTICS",
    "query": "ALTER STATISTICS old_stats RENAME TO new_stats"
  },
  {
    "comment": "TEXT SEARCH PARSER",
    "query": "ALTER TEXT SEARCH PARSER old_parser RENAME TO new_parser"
  },
  {
    "comment": "TEXT SEARCH DICTIONARY",
    "query": "ALTER TEXT SEARCH DICTIONARY old_dict RENAME TO new_dict"
  },
  {
    "comment": "TEXT SEARCH TEMPLATE",
    "query": "ALTER TEXT SEARCH TEMPLATE old_template RENAME TO new_template"
  },
  {
    "comment": "TEXT SEARCH CONFIGURATION",
    "query": "ALTER TEXT SEARCH CONFIGURATION old_config RENAME TO new_config"
  },
  {
    "comment": "ALTER DATABASE RENAME",
    "query": "ALTER DATABASE old_db RENAME TO new_db"
  },
  {
    "comment": "ALTER SCHEMA RENAME",
    "query": "ALTER SCHEMA old_schema RENAME TO new_schema"
  },
  {
    "comment": "ALTER ROLE RENAME",
    "query": "ALTER ROLE old_role RENAME TO new_role"
  },
  {
    "comment": "ALTER USER RENAME",
    "query": "ALTER USER old_user RENAME TO new_user"
  },
  {
    "comment": "ALTER GROUP RENAME",
    "query": "ALTER GROUP old_group RENAME TO new_group"
  },
  {
    "comment": "ALTER TABLESPACE RENAME",
    "query": "ALTER TABLESPACE old_ts RENAME TO new_ts"
  },
  {
    "comment": "ALTER DOMAIN RENAME",
    "query": "ALTER DOMAIN old_domain RENAME TO new_domain"
  },
  {
    "comment": "ALTER DOMAIN RENAME CONSTRAINT",
    "query": "ALTER DOMAIN my_domain RENAME CONSTRAINT old_check TO new_check"
  },
  {
    "comment": "ALTER TYPE RENAME",
    "query": "ALTER TYPE old_type RENAME TO new_type"
  },
  {
    "comment": "ALTER TYPE RENAME ATTRIBUTE",
    "query": "ALTER TYPE my_type RENAME ATTRIBUTE old_attr TO new_attr"
  },
  {
    "comment": "ALTER FUNCTION RENAME",
    "query": "ALTER FUNCTION old_func() RENAME TO new_func"
  },
  {
    "comment": "ALTER PROCEDURE RENAME",
    "query": "ALTER PROCEDURE old_proc() RENAME TO new_proc"
  },
  {
    "comment": "ALTER ROUTINE RENAME",
    "query": "ALTER ROUTINE old_routine() RENAME TO new_routine"
  },
  {
    "comment": "ALTER AGGREGATE RENAME",
    "query": "ALTER AGGREGATE old_agg() RENAME TO new_agg"
  },
  {
    "comment": "ALTER COLLATION RENAME",
    "query": "ALTER COLLATION old_collation RENAME TO new_collation"
  },
  {
    "comment": "ALTER CONVERSION RENAME",
    "query": "ALTER CONVERSION old_conv RENAME TO new_conv"
  },
  {
    "comment": "ALTER LANGUAGE RENAME",
    "query": "ALTER LANGUAGE old_lang RENAME TO new_lang"
  },
  {
    "comment": "ALTER PROCEDURAL LANGUAGE RENAME",
    "query": "ALTER PROCEDURAL LANGUAGE old_lang RENAME TO new_lang"
  },
  {
    "comment": "ALTER OPERATOR CLASS RENAME",
    "query": "ALTER OPERATOR CLASS old_class USING btree RENAME TO new_class"
  },
  {
    "comment": "ALTER OPERATOR FAMILY RENAME",
    "query": "ALTER OPERATOR FAMILY old_family USING btree RENAME TO new_family"
  },
  {
    "comment": "ALTER POLICY RENAME",
    "query": "ALTER POLICY old_policy ON users RENAME TO new_policy"
  },
  {
    "comment": "ALTER POLICY RENAME IF EXISTS",
    "query": "ALTER POLICY IF EXISTS old_policy ON users RENAME TO new_policy"
  },
  {
    "comment": "ALTER RULE RENAME",
    "query": "ALTER RULE old_rule ON users RENAME TO new_rule"
  },
  {
    "comment": "ALTER TRIGGER RENAME",
    "query": "ALTER TRIGGER old_trigger ON users RENAME TO new_trigger"
  },
  {
    "comment": "ALTER EVENT TRIGGER RENAME",
    "query": "ALTER EVENT TRIGGER old_event_trigger RENAME TO new_event_trigger"
  },
  {
    "comment": "ALTER PUBLICATION RENAME",
    "query": "ALTER PUBLICATION old_pub RENAME TO new_pub"
  },
  {
    "comment": "ALTER SUBSCRIPTION RENAME",
    "query": "ALTER SUBSCRIPTION old_sub RENAME TO new_sub"
  },
  {
    "comment": "ALTER FOREIGN DATA WRAPPER RENAME",
    "query": "ALTER FOREIGN DATA WRAPPER old_fdw RENAME TO new_fdw"
  },
  {
    "comment": "ALTER SERVER RENAME",
    "query": "ALTER SERVER old_server RENAME TO new_server"
  },
  {
    "comment": "ALTER STATISTICS RENAME",
    "query": "ALTER STATISTICS old_stats RENAME TO new_stats"
  },
  {
    "comment": "ALTER TEXT SEARCH PARSER RENAME",
    "query": "ALTER TEXT SEARCH PARSER old_parser RENAME TO new_parser"
  },
  {
    "comment": "ALTER TEXT SEARCH DICTIONARY RENAME",
    "query": "ALTER TEXT SEARCH DICTIONARY old_dict RENAME TO new_dict"
  },
  {
    "comment": "ALTER TEXT SEARCH TEMPLATE RENAME",
    "query": "ALTER TEXT SEARCH TEMPLATE old_template RENAME TO new_template"
  },
  {
    "comment": "ALTER TEXT SEARCH CONFIGURATION RENAME",
    "query": "ALTER TEXT SEARCH CONFIGURATION old_config RENAME TO new_config"
  },
  {
    "comment": "ALTER TABLE with schema",
    "query": "ALTER TABLE public.users RENAME TO public.customers"
  },
  {
    "comment": "ALTER INDEX with schema",
    "query": "ALTER INDEX public.users_idx RENAME TO public.customers_idx"
  },
  {
    "comment": "ALTER SEQUENCE with schema",
    "query": "ALTER SEQUENCE public.user_id_seq RENAME TO public.customer_id_seq"
  },
  {
    "comment": "ALTER VIEW with schema",
    "query": "ALTER VIEW public.user_view RENAME TO public.customer_view"
  },
  {
    "comment": "ALTER TABLE RENAME",
    "query": "ALTER TABLE users RENAME TO customers"
  },
  {
    "comment": "ALTER TABLE RENAME IF EXISTS",
    "query": "ALTER TABLE IF EXISTS users RENAME TO customers"
  },
  {
    "comment": "ALTER TABLE RENAME COLUMN",
    "query": "ALTER TABLE users RENAME COLUMN name TO full_name"
  },
  {
    "comment": "ALTER TABLE RENAME COLUMN IF EXISTS",
    "query": "ALTER TABLE IF EXISTS users RENAME COLUMN name TO full_name"
  },
  {
    "comment": "ALTER VIEW RENAME COLUMN",
    "query": "ALTER VIEW user_view RENAME COLUMN name TO full_name"
  },
  {
    "comment": "ALTER VIEW RENAME COLUMN IF EXISTS",
    "query": "ALTER VIEW IF EXISTS user_view RENAME COLUMN name TO full_name"
  },
  {
    "comment": "ALTER MATERIALIZED VIEW RENAME COLUMN",
    "query": "ALTER MATERIALIZED VIEW mat_view RENAME COLUMN name TO full_name"
  },
  {
    "comment": "ALTER MATERIALIZED VIEW RENAME COLUMN IF EXISTS",
    "query": "ALTER MATERIALIZED VIEW IF EXISTS mat_view RENAME COLUMN name TO full_name"
  },
  {
    "comment": "ALTER FOREIGN TABLE RENAME COLUMN",
    "query": "ALTER FOREIGN TABLE foreign_users RENAME COLUMN name TO full_name"
  },
  {
    "comment": "ALTER FOREIGN TABLE RENAME COLUMN IF EXISTS",
    "query": "ALTER FOREIGN TABLE IF EXISTS foreign_users RENAME COLUMN name TO full_name"
  },
  {
    "comment": "ALTER TABLE RENAME CONSTRAINT",
    "query": "ALTER TABLE users RENAME CONSTRAINT old_constraint TO new_constraint"
  },
  {
    "comment": "ALTER TABLE RENAME CONSTRAINT IF EXISTS",
    "query": "ALTER TABLE IF EXISTS users RENAME CONSTRAINT old_constraint TO new_constraint"
  },
  {
    "comment": "ALTER INDEX RENAME",
    "query": "ALTER INDEX users_idx RENAME TO customers_idx"
  },
  {
    "comment": "ALTER INDEX RENAME IF EXISTS",
    "query": "ALTER INDEX IF EXISTS users_idx RENAME TO customers_idx"
  },
  {
    "comment": "ALTER SEQUENCE RENAME",
    "query": "ALTER SEQUENCE user_id_seq RENAME TO customer_id_seq"
  },
  {
    "comment": "ALTER SEQUENCE RENAME IF EXISTS",
    "query": "ALTER SEQUENCE IF EXISTS user_id_seq RENAME TO customer_id_seq"
  },
  {
    "comment": "ALTER VIEW RENAME",
    "query": "ALTER VIEW user_view RENAME TO customer_view"
  },
  {
    "comment": "ALTER VIEW RENAME IF EXISTS",
    "query": "ALTER VIEW IF EXISTS user_view RENAME TO customer_view"
  },
  {
    "comment": "ALTER MATERIALIZED VIEW RENAME",
    "query": "ALTER MATERIALIZED VIEW mat_view RENAME TO new_mat_view"
  },
  {
    "comment": "ALTER MATERIALIZED VIEW RENAME IF EXISTS",
    "query": "ALTER MATERIALIZED VIEW IF EXISTS mat_view RENAME TO new_mat_view"
  },
  {
    "comment": "ALTER FOREIGN TABLE RENAME",
    "query": "ALTER FOREIGN TABLE foreign_users RENAME TO foreign_customers"
  },
  {
    "comment": "ALTER FOREIGN TABLE RENAME IF EXISTS",
    "query": "ALTER FOREIGN TABLE IF EXISTS foreign_users RENAME TO foreign_customers"
  },
  {
    "comment": "INSERT with nested function calls",
    "query": "INSERT INTO users (name, email) VALUES (upper(trim('  john  ')), lower(concat('john', '@', 'example.com')))"
  },
  {
    "comment": "INSERT with arithmetic in VALUES",
    "query": "INSERT INTO products (id, price, discounted_price) VALUES (1, 100.00, 100.00 * 0.9)"
  },
  {
    "comment": "INSERT with parenthesized expressions",
    "query": "INSERT INTO products (total) VALUES ((price + tax) * quantity)"
  },
  {
    "comment": "UPDATE with complex SET expressions",
    "query": "UPDATE products SET price = price * (1 + tax_rate), updated_at = now()"
  },
  {
    "comment": "UPDATE with nested arithmetic",
    "query": "UPDATE stats SET score = (score + bonus) * multiplier, rank = rank + 1"
  },
  {
    "comment": "UPDATE with function calls in SET",
    "query": "UPDATE users SET name = upper(trim(name)), email = lower(email)"
  },
  {
    "comment": "DELETE with arithmetic in WHERE",
    "query": "DELETE FROM products WHERE (price * 0.9) \u003c 10.00"
  },
  {
    "comment": "UPDATE with function calls in WHERE",
    "query": "UPDATE users SET active = FALSE WHERE length(name) \u003c 3 AND upper(status) = 'INACTIVE'"
  },
  {
    "comment": "DELETE with nested expressions in WHERE",
    "query": "DELETE FROM orders WHERE (total + tax) \u003e (limitval * 1.5) AND status = 'pending'"
  },
  {
    "comment": "INSERT with type casts and expressions",
    "query": "INSERT INTO logs (level, message, count) VALUES (upper('info')::text, concat('Log: ', details), (1 + retry_count)::integer)"
  },
  {
    "comment": "UPDATE with complex FROM and expressions",
    "query": "UPDATE orders SET total = o.quantity * p.price, updated_at = now() FROM order_items o, products p WHERE orders.id = o.order_id AND o.product_id = p.id"
  },
  {
    "comment": "INSERT with deeply nested functions",
    "query": "INSERT INTO processed (data) VALUES (upper(substring(trim(input_data), 1, 10)))"
  },
  {
    "comment": "UPDATE with multiple function calls",
    "query": "UPDATE users SET full_name = concat(upper(first_name), ' ', upper(last_name)), slug = lower(replace(name, ' ', '-'))"
  },
  {
    "comment": "INSERT basic VALUES",
    "query": "INSERT INTO users VALUES (1, 'John')"
  },
  {
    "comment": "INSERT with column list",
    "query": "INSERT INTO users (id, name) VALUES (1, 'John')"
  },
  {
    "comment": "INSERT multiple VALUES",
    "query": "INSERT INTO users (id, name) VALUES (1, 'John'), (2, 'Jane')"
  },
  {
    "comment": "INSERT with DEFAULT VALUES",
    "query": "INSERT INTO users DEFAULT VALUES"
  },
  {
    "comment": "INSERT with SELECT",
    "query": "INSERT INTO users SELECT id, name FROM temp_users"
  },
  {
    "comment": "INSERT with subquery",
    "query": "INSERT INTO users (SELECT id, name FROM temp_users WHERE active = TRUE)"
  },
  {
    "comment": "INSERT with RETURNING single column",
    "query": "INSERT INTO users (name) VALUES ('John') RETURNING id"
  },
  {
    "comment": "INSERT with RETURNING multiple columns",
    "query": "INSERT INTO users (name) VALUES ('John') RETURNING id, name, created_at"
  },
  {
    "comment": "INSERT with RETURNING *",
    "query": "INSERT INTO users (name) VALUES ('John') RETURNING *"
  },
  {
    "comment": "INSERT with qualified table name",
    "query": "INSERT INTO public.users (name) VALUES ('John')"
  },
  {
    "comment": "INSERT with table alias",
    "query": "INSERT INTO users AS u (name) VALUES ('John')"
  },
  {
    "comment": "INSERT with WITH clause",
    "query": "WITH temp AS (SELECT 'John' as name) INSERT INTO users (name) SELECT name FROM temp"
  },
  {
    "comment": "INSERT with complex expressions in VALUES",
    "query": "INSERT INTO users (id, name, age) VALUES (1 + 2, upper('john'), 25 * 2)"
  },
  {
    "comment": "UPDATE simple",
    "query": "UPDATE users SET name = 'Jane'"
  },
  {
    "comment": "UPDATE with WHERE",
    "query": "UPDATE users SET name = 'Jane' WHERE id = 1"
  },
  {
    "comment": "UPDATE multiple columns",
    "query": "UPDATE users SET name = 'Jane', age = 30 WHERE id = 1"
  },
  {
    "comment": "UPDATE with complex SET expressions",
    "query": "UPDATE users SET name = upper('jane'), age = age + 1, updated_at = now()"
  },
  {
    "comment": "UPDATE with FROM clause",
    "query": "UPDATE users SET name = temp.name FROM temp_users temp WHERE users.id = temp.id"
  },
  {
    "comment": "UPDATE with multiple FROM tables",
    "query": "UPDATE users SET name = t1.name FROM temp_users t1, other_table t2 WHERE users.id = t1.id AND t1.other_id = t2.id"
  },
  {
    "comment": "UPDATE with complex WHERE",
    "query": "UPDATE users SET name = 'Jane' WHERE id \u003e 10 AND active = TRUE AND created_at \u003e '2023-01-01'"
  },
  {
    "comment": "UPDATE with RETURNING single column",
    "query": "UPDATE users SET name = 'Jane' WHERE id = 1 RETURNING id"
  },
  {
    "comment": "UPDATE with RETURNING multiple columns",
    "query": "UPDATE users SET name = 'Jane' WHERE id = 1 RETURNING id, name, updated_at"
  },
  {
    "comment": "UPDATE with RETURNING *",
    "query": "UPDATE users SET name = 'Jane' WHERE id = 1 RETURNING *"
  },
  {
    "comment": "UPDATE with qualified table",
    "query": "UPDATE public.users SET name = 'Jane' WHERE id = 1"
  },
  {
    "comment": "UPDATE with WITH clause",
    "query": "WITH temp AS (SELECT id FROM active_users) UPDATE users SET active = FALSE WHERE id IN (SELECT id FROM temp)"
  },
  {
    "comment": "UPDATE with subquery in SET",
    "query": "UPDATE users SET name = (SELECT name FROM profiles WHERE profiles.user_id = users.id)"
  },
  {
    "comment": "UPDATE with subquery in WHERE",
    "query": "UPDATE users SET active = FALSE WHERE id IN (SELECT user_id FROM banned_users)"
  },
  {
    "comment": "DELETE simple",
    "query": "DELETE FROM users"
  },
  {
    "comment": "DELETE with WHERE",
    "query": "DELETE FROM users WHERE id = 1"
  },
  {
    "comment": "DELETE with complex WHERE",
    "query": "DELETE FROM users WHERE active = FALSE AND created_at \u003c '2020-01-01'"
  },
  {
    "comment": "DELETE with USING clause",
    "query": "DELETE FROM users USING temp_users temp WHERE users.id = temp.id"
  },
  {
    "comment": "DELETE with multiple USING tables",
    "query": "DELETE FROM users USING temp_users t1, other_table t2 WHERE users.id = t1.id AND t1.other_id = t2.id"
  },
  {
    "comment": "DELETE with RETURNING single column",
    "query": "DELETE FROM users WHERE id = 1 RETURNING id"
  },
  {
    "comment": "DELETE with RETURNING multiple columns",
    "query": "DELETE FROM users WHERE id = 1 RETURNING id, name, deleted_at"
  },
  {
    "comment": "DELETE with RETURNING *",
    "query": "DELETE FROM users WHERE id = 1 RETURNING *"
  },
  {
    "comment": "DELETE with qualified table",
    "query": "DELETE FROM public.users WHERE id = 1"
  },
  {
    "comment": "DELETE with WITH clause",
    "query": "WITH temp AS (SELECT id FROM inactive_users) DELETE FROM users WHERE id IN (SELECT id FROM temp)"
  },
  {
    "comment": "DELETE with subquery in WHERE",
    "query": "DELETE FROM users WHERE id IN (SELECT user_id FROM temp_table)"
  },
  {
    "comment": "MERGE basic",
    "query": "MERGE INTO target USING source ON target.id = source.id WHEN MATCHED THEN DO NOTHING"
  },
  {
    "comment": "MERGE with qualified tables",
    "query": "MERGE INTO public.target USING staging.source ON target.id = source.id WHEN MATCHED THEN DO NOTHING"
  },
  {
    "comment": "MERGE with table aliases",
    "query": "MERGE INTO target AS t USING source AS s ON t.id = s.id WHEN MATCHED THEN DO NOTHING"
  },
  {
    "comment": "MERGE with complex join condition",
    "query": "MERGE INTO target USING source ON target.id = source.id AND target.version = source.version WHEN MATCHED THEN DO NOTHING"
  },
  {
    "comment": "MERGE with subquery as source",
    "query": "MERGE INTO target USING (SELECT * FROM source WHERE active = TRUE) AS s ON target.id = s.id WHEN MATCHED THEN DO NOTHING"
  },
  {
    "comment": "MERGE with WITH clause",
    "query": "WITH filtered AS (SELECT * FROM source WHERE active = TRUE) MERGE INTO target USING filtered ON target.id = filtered.id WHEN MATCHED THEN DO NOTHING"
  },
  {
    "comment": "INSERT with function calls in VALUES",
    "query": "INSERT INTO logs (message, created_at) VALUES (concat('Hello ', 'World'), now())"
  },
  {
    "comment": "UPDATE with arithmetic expressions",
    "query": "UPDATE products SET price = price * 1.1, updated_count = updated_count + 1"
  },
  {
    "comment": "DELETE with function in WHERE",
    "query": "DELETE FROM users WHERE length(name) \u003c 3 OR extract(year FROM created_at) \u003c 2020"
  },
  {
    "comment": "DELETE with simple function in WHERE",
    "query": "DELETE FROM users WHERE length(name) \u003c 3"
  },
  {
    "comment": "INSERT with type casts",
    "query": "INSERT INTO users (id, name, age) VALUES (1::bigint, 'John'::varchar, '25'::integer)"
  },
  {
    "comment": "UPDATE with type casts",
    "query": "UPDATE users SET score = '95.5'::decimal, active = 'true'::boolean"
  },
  {
    "comment": "INSERT with ONLY modifier",
    "query": "INSERT INTO ONLY parent_table (id, name) VALUES (1, 'test')"
  },
  {
    "comment": "UPDATE with ONLY modifier",
    "query": "UPDATE ONLY parent_table SET name = 'updated'"
  },
  {
    "comment": "DELETE with ONLY modifier",
    "query": "DELETE FROM ONLY parent_table WHERE id = 1"
  },
  {
    "comment": "INSERT with empty column list and VALUES",
    "query": "INSERT INTO users () VALUES ()"
  },
  {
    "comment": "UPDATE with no WHERE clause",
    "query": "UPDATE users SET active = TRUE"
  },
  {
    "comment": "DELETE with no WHERE clause",
    "query": "DELETE FROM temp_table"
  },
  {
    "comment": "INSERT with VALUES",
    "query": "INSERT INTO users VALUES (1, 'John')"
  },
  {
    "comment": "INSERT with column list and VALUES",
    "query": "INSERT INTO users (id, name) VALUES (1, 'John')"
  },
  {
    "comment": "INSERT with SELECT",
    "query": "INSERT INTO users SELECT * FROM temp_users"
  },
  {
    "comment": "INSERT with DEFAULT VALUES",
    "query": "INSERT INTO users DEFAULT VALUES"
  },
  {
    "comment": "INSERT with RETURNING",
    "query": "INSERT INTO users (name) VALUES ('John') RETURNING id"
  },
  {
    "comment": "INSERT with schema qualified table",
    "query": "INSERT INTO public.users (name) VALUES ('John')"
  },
  {
    "comment": "simple UPDATE",
    "query": "UPDATE users SET name = 'Jane'"
  },
  {
    "comment": "UPDATE with WHERE",
    "query": "UPDATE users SET name = 'Jane' WHERE id = 1"
  },
  {
    "comment": "UPDATE with RETURNING",
    "query": "UPDATE users SET name = 'Jane' RETURNING id, name"
  },
  {
    "comment": "UPDATE with multiple columns",
    "query": "UPDATE users SET name = 'Jane', age = 30 WHERE id = 1"
  },
  {
    "comment": "UPDATE with schema qualified table",
    "query": "UPDATE public.users SET name = 'Jane'"
  },
  {
    "comment": "simple DELETE",
    "query": "DELETE FROM users"
  },
  {
    "comment": "DELETE with WHERE",
    "query": "DELETE FROM users WHERE id = 1"
  },
  {
    "comment": "DELETE with RETURNING",
    "query": "DELETE FROM users WHERE id = 1 RETURNING name"
  },
  {
    "comment": "DELETE with schema qualified table",
    "query": "DELETE FROM public.users WHERE id = 1"
  },
  {
    "comment": "basic MERGE",
    "query": "MERGE INTO target USING source ON target.id = source.id WHEN MATCHED THEN DO NOTHING"
  },
  {
    "comment": "MERGE with schema qualified tables",
    "query": "MERGE INTO public.target USING staging.source ON target.id = source.id WHEN MATCHED THEN DO NOTHING"
  },
  {
    "comment": "Simple function table",
    "query": "SELECT * FROM generate_series(1, 5)"
  },
  {
    "comment": "Function table with ORDINALITY",
    "query": "SELECT * FROM generate_series(1, 5) WITH ORDINALITY"
  },
  {
    "comment": "LATERAL function table",
    "query": "SELECT * FROM LATERAL generate_series(1, t.max_val)"
  },
  {
    "comment": "ROWS FROM syntax",
    "query": "SELECT * FROM ROWS FROM (generate_series(1, 5))"
  },
  {
    "comment": "ROWS FROM with ORDINALITY",
    "query": "SELECT * FROM ROWS FROM (generate_series(1, 5)) WITH ORDINALITY"
  },
  {
    "comment": "Basic XMLTABLE",
    "query": "SELECT * FROM XMLTABLE('/root/item' PASSING '\u003croot\u003e\u003citem\u003e1\u003c/item\u003e\u003c/root\u003e' COLUMNS id INT, name TEXT)"
  },
  {
    "comment": "XMLTABLE with FOR ORDINALITY",
    "query": "SELECT * FROM XMLTABLE('/root/item' PASSING '\u003croot\u003e\u003citem\u003e1\u003c/item\u003e\u003c/root\u003e' COLUMNS pos FOR ORDINALITY, id INT)"
  },
  {
    "comment": "LATERAL XMLTABLE",
    "query": "SELECT * FROM LATERAL XMLTABLE('/root/item' PASSING t.xml_data COLUMNS id INT)"
  },
  {
    "comment": "Basic JSON_TABLE",
    "query": "SELECT * FROM JSON_TABLE('{}', '$' COLUMNS (id INT))"
  },
  {
    "comment": "JSON_TABLE with FOR ORDINALITY",
    "query": "SELECT * FROM JSON_TABLE('{\"items\": [1, 2, 3]}', '$.items[*]' COLUMNS (pos FOR ORDINALITY, val INT PATH '$'))"
  },
  {
    "comment": "JSON_TABLE with EXISTS column",
    "query": "SELECT * FROM JSON_TABLE('{\"items\": [{\"id\": 1}]}', '$.items[*]' COLUMNS (has_id BOOLEAN EXISTS PATH '$.id'))"
  },
  {
    "comment": "JSON_TABLE with NESTED columns",
    "query": "SELECT * FROM JSON_TABLE('{\"items\": [{\"props\": {\"a\": 1}}]}', '$.items[*]' COLUMNS (NESTED PATH '$.props' COLUMNS (a INT PATH '$.a')))"
  },
  {
    "comment": "LATERAL JSON_TABLE",
    "query": "SELECT * FROM LATERAL JSON_TABLE(t.json_data, '$.items[*]' COLUMNS (id INT PATH '$.id'))"
  },
  {
    "comment": "Function table with alias",
    "query": "SELECT * FROM generate_series(1, 5) AS t"
  },
  {
    "comment": "XMLTABLE with alias",
    "query": "SELECT * FROM XMLTABLE('/root/item' PASSING '\u003croot\u003e\u003c/root\u003e' COLUMNS id INT) AS xt"
  },
  {
    "comment": "JSON_TABLE with alias",
    "query": "SELECT * FROM JSON_TABLE('[]', '$[*]' COLUMNS (id INT)) AS jt"
  },
  {
    "comment": "Function table with column aliases",
    "query": "SELECT * FROM generate_series(1, 5) AS t(num)"
  },
  {
    "comment": "MATERIALIZED CTE deparsing",
    "query": "WITH stats AS MATERIALIZED (SELECT COUNT(a) FROM users) SELECT * FROM stats"
  },
  {
    "comment": "NOT MATERIALIZED CTE deparsing",
    "query": "WITH stats AS NOT MATERIALIZED (SELECT COUNT(a) FROM users) SELECT * FROM stats"
  },
  {
    "comment": "RECURSIVE MATERIALIZED CTE",
    "query": "WITH RECURSIVE t AS MATERIALIZED (SELECT 1) SELECT * FROM t"
  },
  {
    "comment": "SEARCH DEPTH FIRST single column",
    "query": "WITH RECURSIVE t AS (SELECT id FROM tree) SEARCH DEPTH FIRST BY id SET seq SELECT * FROM t"
  },
  {
    "comment": "SEARCH BREADTH FIRST single column",
    "query": "WITH RECURSIVE t AS (SELECT id FROM tree) SEARCH BREADTH FIRST BY id SET seq SELECT * FROM t"
  },
  {
    "comment": "CYCLE simple form single column",
    "query": "WITH RECURSIVE t AS (SELECT id FROM tree) CYCLE id SET mark USING path SELECT * FROM t"
  },
  {
    "comment": "CYCLE full form single column",
    "query": "WITH RECURSIVE t AS (SELECT id FROM tree) CYCLE id SET mark TO TRUE DEFAULT FALSE USING path SELECT * FROM t"
  },
  {
    "comment": "MATERIALIZED with SEARCH",
    "query": "WITH RECURSIVE tree AS MATERIALIZED (SELECT id FROM nodes) SEARCH DEPTH FIRST BY id SET search_seq SELECT * FROM tree"
  },
  {
    "comment": "SEARCH with CYCLE",
    "query": "WITH RECURSIVE tree AS (SELECT id FROM nodes) SEARCH DEPTH FIRST BY id SET search_seq CYCLE id SET is_cycle USING path SELECT * FROM tree"
  },
  {
    "comment": "JOIN with table aliases",
    "query": "SELECT u.name, o.total FROM users u INNER JOIN orders o ON u.id = o.user_id",
    "expected": "SELECT u.name, o.total FROM users AS u INNER JOIN orders AS o ON u.id = o.user_id"
  },
  {
    "comment": "JOIN with complex ON condition",
    "query": "SELECT * FROM users u JOIN orders o ON u.id = o.user_id AND u.active = TRUE",
    "expected": "SELECT * FROM users AS u INNER JOIN orders AS o ON u.id = o.user_id AND u.active = TRUE"
  },
  {
    "comment": "NATURAL JOIN with explicit type",
    "query": "SELECT * FROM users NATURAL INNER JOIN orders",
    "expected": "SELECT * FROM users NATURAL JOIN orders"
  },
  {
    "comment": "NATURAL LEFT JOIN",
    "query": "SELECT * FROM users NATURAL LEFT JOIN orders"
  },
  {
    "comment": "NATURAL RIGHT JOIN",
    "query": "SELECT * FROM users NATURAL RIGHT JOIN orders"
  },
  {
    "comment": "NATURAL FULL JOIN",
    "query": "SELECT * FROM users NATURAL FULL JOIN orders"
  },
  {
    "comment": "LATERAL with simple subquery",
    "query": "SELECT * FROM users u, LATERAL (SELECT * FROM orders o WHERE o.user_id = u.id) AS recent_orders",
    "expected": "SELECT * FROM users AS u, LATERAL (SELECT * FROM orders AS o WHERE o.user_id = u.id) AS recent_orders"
  },
  {
    "comment": "Nested subqueries in FROM",
    "query": "SELECT * FROM (SELECT id FROM (SELECT user_id AS id FROM orders) AS inner_sub) AS outer_sub"
  },
  {
    "comment": "Addition and multiplication",
    "query": "SELECT 1 + 2 * 3"
  },
  {
    "comment": "Parentheses override precedence",
    "query": "SELECT (1 + 2) * 3"
  },
  {
    "comment": "Multiple operators",
    "query": "SELECT 1 + 2 * 3 - 4 / 2"
  },
  {
    "comment": "Unary and binary",
    "query": "SELECT -1 + 2"
  },
  {
    "comment": "Power has highest precedence",
    "query": "SELECT 2 + 3 ^ 2"
  },
  {
    "comment": "Modulo precedence",
    "query": "SELECT 10 + 5 % 3"
  },
  {
    "comment": "Comparison and logical",
    "query": "SELECT * FROM users WHERE age \u003e 18 AND active"
  },
  {
    "comment": "Mixed precedence",
    "query": "SELECT * FROM users WHERE age + 1 \u003e 18 AND NOT deleted"
  },
  {
    "comment": "OR has lower precedence than AND",
    "query": "SELECT * FROM users WHERE active AND verified OR admin"
  },
  {
    "comment": "Parentheses with logical",
    "query": "SELECT * FROM users WHERE (active OR admin) AND verified"
  },
  {
    "comment": "Deeply nested arithmetic",
    "query": "SELECT ((1 + 2) * 3) - (4 / 2)"
  },
  {
    "comment": "Mixed arithmetic and comparison",
    "query": "SELECT * FROM users WHERE (age * 2) + 5 \u003e 30"
  },
  {
    "comment": "Function call precedence",
    "query": "SELECT length(name) + 10 FROM users"
  },
  {
    "comment": "Type cast precedence",
    "query": "SELECT age::text FROM users",
    "expected": "SELECT age::TEXT FROM users"
  },
  {
    "comment": "Complex WHERE precedence",
    "query": "SELECT * FROM users WHERE id = 1 OR id = 2 AND active"
  },
  {
    "comment": "WHERE with parentheses",
    "query": "SELECT * FROM users WHERE (id = 1 OR id = 2) AND active"
  },
  {
    "comment": "NOT precedence",
    "query": "SELECT * FROM users WHERE NOT active AND verified"
  },
  {
    "comment": "NOT with parentheses",
    "query": "SELECT * FROM users WHERE NOT (active AND verified)"
  },
  {
    "comment": "Simple SELECT star",
    "query": "SELECT *"
  },
  {
    "comment": "SELECT single column",
    "query": "SELECT id"
  },
  {
    "comment": "SELECT with column alias AS",
    "query": "SELECT id AS user_id"
  },
  {
    "comment": "SELECT with column alias implicit",
    "query": "SELECT id user_id",
    "expected": "SELECT id AS user_id"
  },
  {
    "comment": "SELECT multiple columns",
    "query": "SELECT id, name"
  },
  {
    "comment": "SELECT all columns from table",
    "query": "SELECT * FROM users"
  },
  {
    "comment": "FROM with table alias AS",
    "query": "SELECT * FROM users AS u"
  },
  {
    "comment": "FROM with table alias implicit",
    "query": "SELECT * FROM users u",
    "expected": "SELECT * FROM users AS u"
  },
  {
    "comment": "FROM with qualified table",
    "query": "SELECT * FROM public.users"
  },
  {
    "comment": "FROM with ONLY modifier",
    "query": "SELECT * FROM ONLY users"
  },
  {
    "comment": "FROM multiple tables",
    "query": "SELECT * FROM users, orders"
  },
  {
    "comment": "SELECT without FROM",
    "query": "SELECT 1"
  },
  {
    "comment": "SELECT DISTINCT single",
    "query": "SELECT DISTINCT id"
  },
  {
    "comment": "SELECT DISTINCT multiple",
    "query": "SELECT DISTINCT id, name"
  },
  {
    "comment": "SELECT DISTINCT ON single",
    "query": "SELECT DISTINCT ON (id) name"
  },
  {
    "comment": "SELECT DISTINCT ON multiple",
    "query": "SELECT DISTINCT ON (department, level) name"
  },
  {
    "comment": "WHERE simple boolean",
    "query": "SELECT * FROM users WHERE active"
  },
  {
    "comment": "WHERE equality",
    "query": "SELECT * FROM users WHERE id = 1"
  },
  {
    "comment": "WHERE not equal",
    "query": "SELECT * FROM users WHERE id \u003c\u003e 1"
  },
  {
    "comment": "WHERE less than",
    "query": "SELECT * FROM users WHERE age \u003c 30"
  },
  {
    "comment": "WHERE greater than",
    "query": "SELECT * FROM users WHERE age \u003e 18"
  },
  {
    "comment": "WHERE less or equal",
    "query": "SELECT * FROM users WHERE age \u003c= 65"
  },
  {
    "comment": "WHERE greater or equal",
    "query": "SELECT * FROM users WHERE age \u003e= 18"
  },
  {
    "comment": "WHERE complex AND",
    "query": "SELECT * FROM users WHERE id \u003e 10 AND active = TRUE"
  },
  {
    "comment": "WHERE complex OR",
    "query": "SELECT * FROM users WHERE admin = TRUE OR moderator = TRUE"
  },
  {
    "comment": "WHERE complex NOT",
    "query": "SELECT * FROM users WHERE NOT deleted"
  },
  {
    "comment": "WHERE mixed logical",
    "query": "SELECT * FROM users WHERE (active = TRUE OR admin = TRUE) AND NOT deleted"
  },
  {
    "comment": "Arithmetic addition",
    "query": "SELECT 1 + 2"
  },
  {
    "comment": "Arithmetic subtraction",
    "query": "SELECT 5 - 3"
  },
  {
    "comment": "Arithmetic multiplication",
    "query": "SELECT 4 * 6"
  },
  {
    "comment": "Arithmetic division",
    "query": "SELECT 10 / 2"
  },
  {
    "comment": "Arithmetic modulo",
    "query": "SELECT 10 % 3"
  },
  {
    "comment": "Arithmetic power",
    "query": "SELECT 2 ^ 3"
  },
  {
    "comment": "Unary plus",
    "query": "SELECT +42"
  },
  {
    "comment": "Unary minus",
    "query": "SELECT -42"
  },
  {
    "comment": "Complex arithmetic",
    "query": "SELECT (1 + 2) * 3 - 4 / 2"
  },
  {
    "comment": "Column arithmetic",
    "query": "SELECT age + 1 FROM users"
  },
  {
    "comment": "Mixed arithmetic",
    "query": "SELECT id + age * 2 FROM users"
  },
  {
    "comment": "Type cast to text",
    "query": "SELECT id::text FROM users",
    "expected": "SELECT id::TEXT FROM users"
  },
  {
    "comment": "Type cast with spaces",
    "query": "SELECT id :: integer FROM users",
    "expected": "SELECT id::INT FROM users"
  },
  {
    "comment": "Complex expression cast",
    "query": "SELECT (age + 1)::varchar FROM users",
    "expected": "SELECT (age + 1)::VARCHAR FROM users"
  },
  {
    "comment": "Multiple casts",
    "query": "SELECT id::text, age::varchar FROM users",
    "expected": "SELECT id::TEXT, age::VARCHAR FROM users"
  },
  {
    "comment": "Simple column reference",
    "query": "SELECT id FROM users"
  },
  {
    "comment": "Qualified column reference",
    "query": "SELECT users.id FROM users"
  },
  {
    "comment": "Schema qualified column",
    "query": "SELECT public.users.id FROM public.users"
  },
  {
    "comment": "Multiple qualified columns",
    "query": "SELECT u.id, u.name FROM users AS u"
  },
  {
    "comment": "Function no args",
    "query": "SELECT now()",
    "expected": "SELECT NOW()"
  },
  {
    "comment": "Function single arg",
    "query": "SELECT length(name) FROM users"
  },
  {
    "comment": "Function multiple args",
    "query": "SELECT substring(name, 1, 5) FROM users"
  },
  {
    "comment": "Qualified function",
    "query": "SELECT my_catalog.length(name) FROM users"
  },
  {
    "comment": "Nested functions",
    "query": "SELECT upper(trim(name)) FROM users"
  },
  {
    "comment": "Function in WHERE",
    "query": "SELECT * FROM users WHERE length(name) \u003e 5"
  },
  {
    "comment": "Integer constant",
    "query": "SELECT 42"
  },
  {
    "comment": "Negative integer",
    "query": "SELECT -123"
  },
  {
    "comment": "Float constant",
    "query": "SELECT 3.14"
  },
  {
    "comment": "String literal",
    "query": "SELECT 'hello world'"
  },
  {
    "comment": "Boolean TRUE",
    "query": "SELECT TRUE"
  },
  {
    "comment": "Boolean FALSE",
    "query": "SELECT FALSE"
  },
  {
    "comment": "NULL constant",
    "query": "SELECT NULL"
  },
  {
    "comment": "SELECT INTO basic",
    "query": "SELECT * INTO backup_users FROM users"
  },
  {
    "comment": "SELECT INTO with WHERE",
    "query": "SELECT id, name INTO temp_users FROM users WHERE active = TRUE"
  },
  {
    "comment": "TABLE statement",
    "query": "TABLE users",
    "expected": "SELECT * FROM users"
  },
  {
    "comment": "TABLE with qualified name",
    "query": "TABLE public.users",
    "expected": "SELECT * FROM public.users"
  },
  {
    "comment": "Complex SELECT with all features",
    "query": "SELECT u.id AS user_id, upper(u.name) AS user_name FROM users AS u WHERE u.active = TRUE AND u.age \u003e 18"
  },
  {
    "comment": "Multiple expressions with aliases",
    "query": "SELECT id AS user_id, name AS user_name, age + 1 AS next_age FROM users"
  },
  {
    "comment": "Arithmetic in WHERE with functions",
    "query": "SELECT * FROM users WHERE length(name) + age \u003e 25"
  },
  {
    "comment": "column list in function",
    "query": "SELECT func(a, b, c)"
  },
  {
    "comment": "multiple column references",
    "query": "SELECT a, b, c FROM table1"
  },
  {
    "comment": "qualified column list",
    "query": "SELECT t1.a, t2.b, t3.c FROM t1, t2, t3"
  },
  {
    "comment": "array subscript",
    "query": "SELECT column[1]"
  },
  {
    "comment": "array slice",
    "query": "SELECT column[1:5]"
  },
  {
    "comment": "field access",
    "query": "SELECT record.field"
  },
  {
    "comment": "nested field access",
    "query": "SELECT record.subrecord.field"
  },
  {
    "comment": "mixed indirection",
    "query": "SELECT array_col[1].field"
  },
  {
    "comment": "qualified operator",
    "query": "SELECT a OPERATOR(pg_catalog.+) b"
  },
  {
    "comment": "schema qualified operator",
    "query": "SELECT a OPERATOR(myschema.=) b"
  },
  {
    "comment": "custom operator",
    "query": "SELECT a OPERATOR(public.@@) b"
  },
  {
    "comment": "bit type casting",
    "query": "SELECT value::bit"
  },
  {
    "comment": "bit with length",
    "query": "SELECT value::bit(8)"
  },
  {
    "comment": "timestamp type",
    "query": "SELECT value::TIMESTAMP"
  },
  {
    "comment": "timestamp with precision",
    "query": "SELECT value::timestamp(6)",
    "expected": "SELECT value::TIMESTAMP(6)"
  },
  {
    "comment": "timestamptz type",
    "query": "SELECT value::timestamptz",
    "expected": "SELECT value::TIMESTAMP WITH TIME ZONE"
  },
  {
    "comment": "date type",
    "query": "SELECT value::DATE"
  },
  {
    "comment": "time type",
    "query": "SELECT value::TIME"
  },
  {
    "comment": "interval type",
    "query": "SELECT value::INTERVAL"
  },
  {
    "comment": "select all",
    "query": "SELECT ALL * FROM users"
  },
  {
    "comment": "select all with columns",
    "query": "SELECT ALL id, name FROM users"
  },
  {
    "comment": "select all with where",
    "query": "SELECT ALL * FROM users WHERE active = true"
  },
  {
    "comment": "two simple statements",
    "query": "SELECT 1; SELECT 2",
    "expected": "SELECT 1; SELECT 2"
  },
  {
    "comment": "multiple statements with different types",
    "query": "SELECT * FROM users; SELECT name FROM orders",
    "expected": "SELECT * FROM users; SELECT name FROM orders"
  },
  {
    "comment": "statements with whitespace",
    "query": "SELECT 1;   SELECT 2;   SELECT 3",
    "expected": "SELECT 1; SELECT 2; SELECT 3"
  },
  {
    "comment": "trailing semicolon",
    "query": "SELECT 1; SELECT 2;",
    "expected": "SELECT 1; SELECT 2"
  }
]
