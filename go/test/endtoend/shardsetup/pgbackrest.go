// Copyright 2025 Supabase, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package shardsetup

import (
	"context"
	"os/exec"
	"path/filepath"
	"testing"
	"time"

	"github.com/multigres/multigres/go/provisioner/local"

	"github.com/stretchr/testify/require"
)

// PgBackRestInstance represents a pgBackRest server instance for testing.
type PgBackRestInstance struct {
	Name       string
	Port       int
	ConfigFile string
	Process    *exec.Cmd
	PoolerDir  string // The pooler directory where config will be generated
}

// generatePgBackRestCerts creates TLS certificates for pgBackRest server.
// Returns the certificate paths.
// Uses the public function from go/provisioner/local package.
func (s *ShardSetup) generatePgBackRestCerts(t *testing.T) *local.PgBackRestCertPaths {
	t.Helper()

	certDir := filepath.Join(s.TempDir, "certs")
	certPaths, err := local.GeneratePgBackRestCerts(certDir)
	if err != nil {
		t.Fatalf("failed to generate pgBackRest certificates: %v", err)
	}

	t.Logf("Generated pgBackRest certificates in %s", certDir)

	return certPaths
}

// startPgBackRestServer starts a pgBackRest server for a multipooler instance.
// It waits for the multipooler to generate the pgbackrest.conf file before starting.
// Uses the public function from go/provisioner/local package.
func (s *ShardSetup) startPgBackRestServer(t *testing.T, name, poolerDir string, port int) *PgBackRestInstance {
	t.Helper()

	// Config file path (will be generated by multipooler)
	configFile := filepath.Join(poolerDir, "pgbackrest", "pgbackrest.conf")

	// Wait for multipooler to generate the pgbackrest config file and get the command
	t.Logf("Waiting for pgbackrest config at: %s", configFile)
	ctx := context.Background()
	cmd, err := local.StartPgBackRestServer(ctx, poolerDir, 90*time.Second)
	require.NoError(t, err, "failed to start pgbackrest server")

	t.Logf("Config file found, starting pgBackRest server (port:%d)...", port)

	// Start the process
	err = cmd.Start()
	require.NoError(t, err, "failed to start pgbackrest server")

	t.Logf("pgbackrest server started (PID %d, port %d)", cmd.Process.Pid, port)

	instance := &PgBackRestInstance{
		Name:       name,
		Port:       port,
		ConfigFile: configFile,
		Process:    cmd,
		PoolerDir:  poolerDir,
	}

	// Note: cleanup is handled by ShardSetup.Cleanup(), not t.Cleanup()
	// This allows pgBackRest to survive across multiple tests in shared setups

	return instance
}

// Stop stops the pgBackRest server.
func (p *PgBackRestInstance) Stop() {
	if p.Process == nil || p.Process.Process == nil {
		return
	}
	_ = p.Process.Process.Kill()
	_ = p.Process.Wait()
}

// IsRunning checks if the pgBackRest server is still running.
func (p *PgBackRestInstance) IsRunning() bool {
	if p == nil || p.Process == nil || p.Process.Process == nil {
		return false
	}
	// ProcessState is set after Wait() returns
	if p.Process.ProcessState != nil {
		return false
	}
	return true
}
