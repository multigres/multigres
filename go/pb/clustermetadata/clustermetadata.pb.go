// Copyright 2025 The Multigres Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.7
// 	protoc        v4.25.1
// source: clustermetadata.proto

package clustermetadata

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// MultigresComponent enumerates the major components in a Multigres deployment.
type MultigresComponent int32

const (
	// MULTIGATEWAY handles query routing and traffic distribution across clusters.
	MultigresComponent_MULTIGATEWAY MultigresComponent = 0
	// MULTIPOOLER manages connection pooling and load balancing for database clients.
	MultigresComponent_MULTIPOOLER MultigresComponent = 1
	// MULTIORCH is the orchestrator responsible for cluster topology management,
	// failover coordination, and automated repairs.
	MultigresComponent_MULTIORCH MultigresComponent = 2
)

// Enum value maps for MultigresComponent.
var (
	MultigresComponent_name = map[int32]string{
		0: "MULTIGATEWAY",
		1: "MULTIPOOLER",
		2: "MULTIORCH",
	}
	MultigresComponent_value = map[string]int32{
		"MULTIGATEWAY": 0,
		"MULTIPOOLER":  1,
		"MULTIORCH":    2,
	}
)

func (x MultigresComponent) Enum() *MultigresComponent {
	p := new(MultigresComponent)
	*p = x
	return p
}

func (x MultigresComponent) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MultigresComponent) Descriptor() protoreflect.EnumDescriptor {
	return file_clustermetadata_proto_enumTypes[0].Descriptor()
}

func (MultigresComponent) Type() protoreflect.EnumType {
	return &file_clustermetadata_proto_enumTypes[0]
}

func (x MultigresComponent) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MultigresComponent.Descriptor instead.
func (MultigresComponent) EnumDescriptor() ([]byte, []int) {
	return file_clustermetadata_proto_rawDescGZIP(), []int{0}
}

// PoolerType represents the type of a given MultiPooler.
type PoolerType int32

const (
	// UNKNOWN this is not a valid type.
	// It is useful during upgrades to detect when a value is not initialized
	PoolerType_UNKNOWN PoolerType = 0
	// PRIMARY is the primary server for the shard. Only PRIMARY allows DMLs.
	PoolerType_PRIMARY PoolerType = 1
	// REPLICA replicates from leader. It is used to read only traffic
	PoolerType_REPLICA PoolerType = 2
)

// Enum value maps for PoolerType.
var (
	PoolerType_name = map[int32]string{
		0: "UNKNOWN",
		1: "PRIMARY",
		2: "REPLICA",
	}
	PoolerType_value = map[string]int32{
		"UNKNOWN": 0,
		"PRIMARY": 1,
		"REPLICA": 2,
	}
)

func (x PoolerType) Enum() *PoolerType {
	p := new(PoolerType)
	*p = x
	return p
}

func (x PoolerType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PoolerType) Descriptor() protoreflect.EnumDescriptor {
	return file_clustermetadata_proto_enumTypes[1].Descriptor()
}

func (PoolerType) Type() protoreflect.EnumType {
	return &file_clustermetadata_proto_enumTypes[1]
}

func (x PoolerType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PoolerType.Descriptor instead.
func (PoolerType) EnumDescriptor() ([]byte, []int) {
	return file_clustermetadata_proto_rawDescGZIP(), []int{1}
}

// PoolerServingStatus represents the serving status of the given MultiPooler.
type PoolerServingStatus int32

const (
	// SERVING is the status a server during normal operations when it is serving traffic.
	PoolerServingStatus_SERVING PoolerServingStatus = 0
	// NOT_SERVING is the status of a server when it is not serving traffic.
	// This typically occurs during startup, shutdown, or when the server is
	// in an error state and cannot accept connections.
	PoolerServingStatus_NOT_SERVING PoolerServingStatus = 1
	// BACKUP is the status of a server when it is taking a backup. No queries
	// can be served in BACKUP mode.
	PoolerServingStatus_BACKUP PoolerServingStatus = 2
	// RESTORE is the status a server uses when restoring a backup, at
	// startup time.  No queries can be served in RESTORE mode.
	PoolerServingStatus_RESTORE PoolerServingStatus = 3
	// DRAINED is the status a server goes into when used by Multigres tools
	// to perform an offline action. It is a serving type (as
	// the tools processes may need to run queries), but it's not used
	// to route queries from Multigres users. In this state,
	// this multipooler is dedicated to the process that uses it.
	PoolerServingStatus_DRAINED PoolerServingStatus = 4
)

// Enum value maps for PoolerServingStatus.
var (
	PoolerServingStatus_name = map[int32]string{
		0: "SERVING",
		1: "NOT_SERVING",
		2: "BACKUP",
		3: "RESTORE",
		4: "DRAINED",
	}
	PoolerServingStatus_value = map[string]int32{
		"SERVING":     0,
		"NOT_SERVING": 1,
		"BACKUP":      2,
		"RESTORE":     3,
		"DRAINED":     4,
	}
)

func (x PoolerServingStatus) Enum() *PoolerServingStatus {
	p := new(PoolerServingStatus)
	*p = x
	return p
}

func (x PoolerServingStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PoolerServingStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_clustermetadata_proto_enumTypes[2].Descriptor()
}

func (PoolerServingStatus) Type() protoreflect.EnumType {
	return &file_clustermetadata_proto_enumTypes[2]
}

func (x PoolerServingStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PoolerServingStatus.Descriptor instead.
func (PoolerServingStatus) EnumDescriptor() ([]byte, []int) {
	return file_clustermetadata_proto_rawDescGZIP(), []int{2}
}

// TopoConfig defines the connection parameters for a topology service.
// It specifies the type of topology backend, where it's hosted, and the
// logical root path within that backend.
// This is not stored in the topo itself, but it's the entry point to
// configure the global topo.
type GlobalTopoConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// implementation indicates the type of topology service in use
	// (for example: "etcd2",  "memory").
	Implementation string `protobuf:"bytes,1,opt,name=implementation,proto3" json:"implementation,omitempty"`
	// server is the network address (host:port) of the topology service.
	// Can be a list list for HA setups.
	ServerAddresses []string `protobuf:"bytes,2,rep,name=server_addresses,json=serverAddresses,proto3" json:"server_addresses,omitempty"`
	// root is the logical root directory or namespace inside the topology backend
	// under which all cluster metadata will be stored.
	Root          string `protobuf:"bytes,3,opt,name=root,proto3" json:"root,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GlobalTopoConfig) Reset() {
	*x = GlobalTopoConfig{}
	mi := &file_clustermetadata_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GlobalTopoConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GlobalTopoConfig) ProtoMessage() {}

func (x *GlobalTopoConfig) ProtoReflect() protoreflect.Message {
	mi := &file_clustermetadata_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GlobalTopoConfig.ProtoReflect.Descriptor instead.
func (*GlobalTopoConfig) Descriptor() ([]byte, []int) {
	return file_clustermetadata_proto_rawDescGZIP(), []int{0}
}

func (x *GlobalTopoConfig) GetImplementation() string {
	if x != nil {
		return x.Implementation
	}
	return ""
}

func (x *GlobalTopoConfig) GetServerAddresses() []string {
	if x != nil {
		return x.ServerAddresses
	}
	return nil
}

func (x *GlobalTopoConfig) GetRoot() string {
	if x != nil {
		return x.Root
	}
	return ""
}

// Cell describes how to connect to a cell topology.
// These records are stored in the global topology server.
type Cell struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name for this cell
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// server_address is the network address of the cell topology service.
	ServerAddresses []string `protobuf:"bytes,2,rep,name=server_addresses,json=serverAddresses,proto3" json:"server_addresses,omitempty"`
	// root is the namespace or directory path within the topology service
	// where this cell's metadata is stored. Used only when connecting to server_addresses.
	Root          string `protobuf:"bytes,3,opt,name=root,proto3" json:"root,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Cell) Reset() {
	*x = Cell{}
	mi := &file_clustermetadata_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Cell) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Cell) ProtoMessage() {}

func (x *Cell) ProtoReflect() protoreflect.Message {
	mi := &file_clustermetadata_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Cell.ProtoReflect.Descriptor instead.
func (*Cell) Descriptor() ([]byte, []int) {
	return file_clustermetadata_proto_rawDescGZIP(), []int{1}
}

func (x *Cell) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Cell) GetServerAddresses() []string {
	if x != nil {
		return x.ServerAddresses
	}
	return nil
}

func (x *Cell) GetRoot() string {
	if x != nil {
		return x.Root
	}
	return ""
}

type Database struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Name of the database
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Backups location
	BackupLocation string `protobuf:"bytes,2,opt,name=backup_location,json=backupLocation,proto3" json:"backup_location,omitempty"`
	// Durability policy used for consensus
	DurabilityPolicy string `protobuf:"bytes,3,opt,name=durability_policy,json=durabilityPolicy,proto3" json:"durability_policy,omitempty"`
	// List of cell identifiers where this database should be deployed
	Cells         []string `protobuf:"bytes,4,rep,name=cells,proto3" json:"cells,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Database) Reset() {
	*x = Database{}
	mi := &file_clustermetadata_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Database) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Database) ProtoMessage() {}

func (x *Database) ProtoReflect() protoreflect.Message {
	mi := &file_clustermetadata_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Database.ProtoReflect.Descriptor instead.
func (*Database) Descriptor() ([]byte, []int) {
	return file_clustermetadata_proto_rawDescGZIP(), []int{2}
}

func (x *Database) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Database) GetBackupLocation() string {
	if x != nil {
		return x.BackupLocation
	}
	return ""
}

func (x *Database) GetDurabilityPolicy() string {
	if x != nil {
		return x.DurabilityPolicy
	}
	return ""
}

func (x *Database) GetCells() []string {
	if x != nil {
		return x.Cells
	}
	return nil
}

// MultiPooler represents metadata about a running multipooler component instance in the cluster.
type MultiPooler struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// identifier is the unique identifier of the multipooler in the cluster.
	Identifier *ID `protobuf:"bytes,1,opt,name=identifier,proto3" json:"identifier,omitempty"`
	// Database name.
	Database string `protobuf:"bytes,2,opt,name=database,proto3" json:"database,omitempty"`
	// TableGroup name.
	TableGroup string `protobuf:"bytes,3,opt,name=table_group,json=tableGroup,proto3" json:"table_group,omitempty"`
	// Shard name. If range based sharding is used, it should match
	// key_range.
	Shard string `protobuf:"bytes,4,opt,name=shard,proto3" json:"shard,omitempty"`
	// If range based sharding is used, range for the pooler's shard.
	KeyRange *KeyRange `protobuf:"bytes,5,opt,name=key_range,json=keyRange,proto3" json:"key_range,omitempty"`
	// PoolerType is the kind of pooler: PRIMARY or REPLICA
	Type PoolerType `protobuf:"varint,6,opt,name=type,proto3,enum=clustermetadata.PoolerType" json:"type,omitempty"`
	// PoolerServingStatus is the current type of the pooler.
	ServingStatus PoolerServingStatus `protobuf:"varint,7,opt,name=serving_status,json=servingStatus,proto3,enum=clustermetadata.PoolerServingStatus" json:"serving_status,omitempty"`
	// Fully qualified domain name of the host.
	Hostname string `protobuf:"bytes,8,opt,name=hostname,proto3" json:"hostname,omitempty"`
	// Map of named ports. These are ports that the pooler exposes. Initially, this will only be gRPC
	PortMap       map[string]int32 `protobuf:"bytes,9,rep,name=port_map,json=portMap,proto3" json:"port_map,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MultiPooler) Reset() {
	*x = MultiPooler{}
	mi := &file_clustermetadata_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MultiPooler) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MultiPooler) ProtoMessage() {}

func (x *MultiPooler) ProtoReflect() protoreflect.Message {
	mi := &file_clustermetadata_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MultiPooler.ProtoReflect.Descriptor instead.
func (*MultiPooler) Descriptor() ([]byte, []int) {
	return file_clustermetadata_proto_rawDescGZIP(), []int{3}
}

func (x *MultiPooler) GetIdentifier() *ID {
	if x != nil {
		return x.Identifier
	}
	return nil
}

func (x *MultiPooler) GetDatabase() string {
	if x != nil {
		return x.Database
	}
	return ""
}

func (x *MultiPooler) GetTableGroup() string {
	if x != nil {
		return x.TableGroup
	}
	return ""
}

func (x *MultiPooler) GetShard() string {
	if x != nil {
		return x.Shard
	}
	return ""
}

func (x *MultiPooler) GetKeyRange() *KeyRange {
	if x != nil {
		return x.KeyRange
	}
	return nil
}

func (x *MultiPooler) GetType() PoolerType {
	if x != nil {
		return x.Type
	}
	return PoolerType_UNKNOWN
}

func (x *MultiPooler) GetServingStatus() PoolerServingStatus {
	if x != nil {
		return x.ServingStatus
	}
	return PoolerServingStatus_SERVING
}

func (x *MultiPooler) GetHostname() string {
	if x != nil {
		return x.Hostname
	}
	return ""
}

func (x *MultiPooler) GetPortMap() map[string]int32 {
	if x != nil {
		return x.PortMap
	}
	return nil
}

// MultiGateway represents metadata about a running multigateway component instance in the cluster.
type MultiGateway struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// identifier is the unique name of the multi gateway in the cluster.
	Identifier *ID `protobuf:"bytes,1,opt,name=identifier,proto3" json:"identifier,omitempty"`
	// Fully qualified domain name of the host.
	Hostname string `protobuf:"bytes,2,opt,name=hostname,proto3" json:"hostname,omitempty"`
	// Map of named ports. Normally this should include postgres and grpc.
	PortMap       map[string]int32 `protobuf:"bytes,3,rep,name=port_map,json=portMap,proto3" json:"port_map,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MultiGateway) Reset() {
	*x = MultiGateway{}
	mi := &file_clustermetadata_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MultiGateway) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MultiGateway) ProtoMessage() {}

func (x *MultiGateway) ProtoReflect() protoreflect.Message {
	mi := &file_clustermetadata_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MultiGateway.ProtoReflect.Descriptor instead.
func (*MultiGateway) Descriptor() ([]byte, []int) {
	return file_clustermetadata_proto_rawDescGZIP(), []int{4}
}

func (x *MultiGateway) GetIdentifier() *ID {
	if x != nil {
		return x.Identifier
	}
	return nil
}

func (x *MultiGateway) GetHostname() string {
	if x != nil {
		return x.Hostname
	}
	return ""
}

func (x *MultiGateway) GetPortMap() map[string]int32 {
	if x != nil {
		return x.PortMap
	}
	return nil
}

// MultiOrch represents information about a running instance of multiorch.
type MultiOrch struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// identifier is the unique name of the MultiOrch in the cluster.
	Identifier *ID `protobuf:"bytes,1,opt,name=identifier,proto3" json:"identifier,omitempty"`
	// Fully qualified domain name of the host.
	Hostname string `protobuf:"bytes,2,opt,name=hostname,proto3" json:"hostname,omitempty"`
	// Map of named ports. These are ports that MultiOrc exposes.
	PortMap       map[string]int32 `protobuf:"bytes,3,rep,name=port_map,json=portMap,proto3" json:"port_map,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MultiOrch) Reset() {
	*x = MultiOrch{}
	mi := &file_clustermetadata_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MultiOrch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MultiOrch) ProtoMessage() {}

func (x *MultiOrch) ProtoReflect() protoreflect.Message {
	mi := &file_clustermetadata_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MultiOrch.ProtoReflect.Descriptor instead.
func (*MultiOrch) Descriptor() ([]byte, []int) {
	return file_clustermetadata_proto_rawDescGZIP(), []int{5}
}

func (x *MultiOrch) GetIdentifier() *ID {
	if x != nil {
		return x.Identifier
	}
	return nil
}

func (x *MultiOrch) GetHostname() string {
	if x != nil {
		return x.Hostname
	}
	return ""
}

func (x *MultiOrch) GetPortMap() map[string]int32 {
	if x != nil {
		return x.PortMap
	}
	return nil
}

// ID is a globally unique pooler identifier.
type ID struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// component that this ID is used for (i.e multigateway / multiorch / multipooler)
	Component MultigresComponent `protobuf:"varint,1,opt,name=component,proto3,enum=clustermetadata.MultigresComponent" json:"component,omitempty"`
	// cell is the Multigres cell where the component is located
	Cell string `protobuf:"bytes,2,opt,name=cell,proto3" json:"cell,omitempty"`
	// uid is a unique identifier for the component within the multigres
	// cluster.
	Uid           uint32 `protobuf:"varint,3,opt,name=uid,proto3" json:"uid,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ID) Reset() {
	*x = ID{}
	mi := &file_clustermetadata_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ID) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ID) ProtoMessage() {}

func (x *ID) ProtoReflect() protoreflect.Message {
	mi := &file_clustermetadata_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ID.ProtoReflect.Descriptor instead.
func (*ID) Descriptor() ([]byte, []int) {
	return file_clustermetadata_proto_rawDescGZIP(), []int{6}
}

func (x *ID) GetComponent() MultigresComponent {
	if x != nil {
		return x.Component
	}
	return MultigresComponent_MULTIGATEWAY
}

func (x *ID) GetCell() string {
	if x != nil {
		return x.Cell
	}
	return ""
}

func (x *ID) GetUid() uint32 {
	if x != nil {
		return x.Uid
	}
	return 0
}

// KeyRange represents a range of keys for sharding
type KeyRange struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// start is the start key of the range (inclusive)
	Start []byte `protobuf:"bytes,1,opt,name=start,proto3" json:"start,omitempty"`
	// end is the end key of the range (exclusive)
	End           []byte `protobuf:"bytes,2,opt,name=end,proto3" json:"end,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KeyRange) Reset() {
	*x = KeyRange{}
	mi := &file_clustermetadata_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KeyRange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KeyRange) ProtoMessage() {}

func (x *KeyRange) ProtoReflect() protoreflect.Message {
	mi := &file_clustermetadata_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KeyRange.ProtoReflect.Descriptor instead.
func (*KeyRange) Descriptor() ([]byte, []int) {
	return file_clustermetadata_proto_rawDescGZIP(), []int{7}
}

func (x *KeyRange) GetStart() []byte {
	if x != nil {
		return x.Start
	}
	return nil
}

func (x *KeyRange) GetEnd() []byte {
	if x != nil {
		return x.End
	}
	return nil
}

var File_clustermetadata_proto protoreflect.FileDescriptor

const file_clustermetadata_proto_rawDesc = "" +
	"\n" +
	"\x15clustermetadata.proto\x12\x0fclustermetadata\"y\n" +
	"\x10GlobalTopoConfig\x12&\n" +
	"\x0eimplementation\x18\x01 \x01(\tR\x0eimplementation\x12)\n" +
	"\x10server_addresses\x18\x02 \x03(\tR\x0fserverAddresses\x12\x12\n" +
	"\x04root\x18\x03 \x01(\tR\x04root\"Y\n" +
	"\x04Cell\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12)\n" +
	"\x10server_addresses\x18\x02 \x03(\tR\x0fserverAddresses\x12\x12\n" +
	"\x04root\x18\x03 \x01(\tR\x04root\"\x8a\x01\n" +
	"\bDatabase\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12'\n" +
	"\x0fbackup_location\x18\x02 \x01(\tR\x0ebackupLocation\x12+\n" +
	"\x11durability_policy\x18\x03 \x01(\tR\x10durabilityPolicy\x12\x14\n" +
	"\x05cells\x18\x04 \x03(\tR\x05cells\"\xe9\x03\n" +
	"\vMultiPooler\x123\n" +
	"\n" +
	"identifier\x18\x01 \x01(\v2\x13.clustermetadata.IDR\n" +
	"identifier\x12\x1a\n" +
	"\bdatabase\x18\x02 \x01(\tR\bdatabase\x12\x1f\n" +
	"\vtable_group\x18\x03 \x01(\tR\n" +
	"tableGroup\x12\x14\n" +
	"\x05shard\x18\x04 \x01(\tR\x05shard\x126\n" +
	"\tkey_range\x18\x05 \x01(\v2\x19.clustermetadata.KeyRangeR\bkeyRange\x12/\n" +
	"\x04type\x18\x06 \x01(\x0e2\x1b.clustermetadata.PoolerTypeR\x04type\x12K\n" +
	"\x0eserving_status\x18\a \x01(\x0e2$.clustermetadata.PoolerServingStatusR\rservingStatus\x12\x1a\n" +
	"\bhostname\x18\b \x01(\tR\bhostname\x12D\n" +
	"\bport_map\x18\t \x03(\v2).clustermetadata.MultiPooler.PortMapEntryR\aportMap\x1a:\n" +
	"\fPortMapEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\x05R\x05value:\x028\x01\"\xe2\x01\n" +
	"\fMultiGateway\x123\n" +
	"\n" +
	"identifier\x18\x01 \x01(\v2\x13.clustermetadata.IDR\n" +
	"identifier\x12\x1a\n" +
	"\bhostname\x18\x02 \x01(\tR\bhostname\x12E\n" +
	"\bport_map\x18\x03 \x03(\v2*.clustermetadata.MultiGateway.PortMapEntryR\aportMap\x1a:\n" +
	"\fPortMapEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\x05R\x05value:\x028\x01\"\xdc\x01\n" +
	"\tMultiOrch\x123\n" +
	"\n" +
	"identifier\x18\x01 \x01(\v2\x13.clustermetadata.IDR\n" +
	"identifier\x12\x1a\n" +
	"\bhostname\x18\x02 \x01(\tR\bhostname\x12B\n" +
	"\bport_map\x18\x03 \x03(\v2'.clustermetadata.MultiOrch.PortMapEntryR\aportMap\x1a:\n" +
	"\fPortMapEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\x05R\x05value:\x028\x01\"m\n" +
	"\x02ID\x12A\n" +
	"\tcomponent\x18\x01 \x01(\x0e2#.clustermetadata.MultigresComponentR\tcomponent\x12\x12\n" +
	"\x04cell\x18\x02 \x01(\tR\x04cell\x12\x10\n" +
	"\x03uid\x18\x03 \x01(\rR\x03uid\"2\n" +
	"\bKeyRange\x12\x14\n" +
	"\x05start\x18\x01 \x01(\fR\x05start\x12\x10\n" +
	"\x03end\x18\x02 \x01(\fR\x03end*F\n" +
	"\x12MultigresComponent\x12\x10\n" +
	"\fMULTIGATEWAY\x10\x00\x12\x0f\n" +
	"\vMULTIPOOLER\x10\x01\x12\r\n" +
	"\tMULTIORCH\x10\x02*3\n" +
	"\n" +
	"PoolerType\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\v\n" +
	"\aPRIMARY\x10\x01\x12\v\n" +
	"\aREPLICA\x10\x02*Y\n" +
	"\x13PoolerServingStatus\x12\v\n" +
	"\aSERVING\x10\x00\x12\x0f\n" +
	"\vNOT_SERVING\x10\x01\x12\n" +
	"\n" +
	"\x06BACKUP\x10\x02\x12\v\n" +
	"\aRESTORE\x10\x03\x12\v\n" +
	"\aDRAINED\x10\x04B6Z4github.com/multigres/multigres/go/pb/clustermetadatab\x06proto3"

var (
	file_clustermetadata_proto_rawDescOnce sync.Once
	file_clustermetadata_proto_rawDescData []byte
)

func file_clustermetadata_proto_rawDescGZIP() []byte {
	file_clustermetadata_proto_rawDescOnce.Do(func() {
		file_clustermetadata_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_clustermetadata_proto_rawDesc), len(file_clustermetadata_proto_rawDesc)))
	})
	return file_clustermetadata_proto_rawDescData
}

var file_clustermetadata_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
var file_clustermetadata_proto_msgTypes = make([]protoimpl.MessageInfo, 11)
var file_clustermetadata_proto_goTypes = []any{
	(MultigresComponent)(0),  // 0: clustermetadata.MultigresComponent
	(PoolerType)(0),          // 1: clustermetadata.PoolerType
	(PoolerServingStatus)(0), // 2: clustermetadata.PoolerServingStatus
	(*GlobalTopoConfig)(nil), // 3: clustermetadata.GlobalTopoConfig
	(*Cell)(nil),             // 4: clustermetadata.Cell
	(*Database)(nil),         // 5: clustermetadata.Database
	(*MultiPooler)(nil),      // 6: clustermetadata.MultiPooler
	(*MultiGateway)(nil),     // 7: clustermetadata.MultiGateway
	(*MultiOrch)(nil),        // 8: clustermetadata.MultiOrch
	(*ID)(nil),               // 9: clustermetadata.ID
	(*KeyRange)(nil),         // 10: clustermetadata.KeyRange
	nil,                      // 11: clustermetadata.MultiPooler.PortMapEntry
	nil,                      // 12: clustermetadata.MultiGateway.PortMapEntry
	nil,                      // 13: clustermetadata.MultiOrch.PortMapEntry
}
var file_clustermetadata_proto_depIdxs = []int32{
	9,  // 0: clustermetadata.MultiPooler.identifier:type_name -> clustermetadata.ID
	10, // 1: clustermetadata.MultiPooler.key_range:type_name -> clustermetadata.KeyRange
	1,  // 2: clustermetadata.MultiPooler.type:type_name -> clustermetadata.PoolerType
	2,  // 3: clustermetadata.MultiPooler.serving_status:type_name -> clustermetadata.PoolerServingStatus
	11, // 4: clustermetadata.MultiPooler.port_map:type_name -> clustermetadata.MultiPooler.PortMapEntry
	9,  // 5: clustermetadata.MultiGateway.identifier:type_name -> clustermetadata.ID
	12, // 6: clustermetadata.MultiGateway.port_map:type_name -> clustermetadata.MultiGateway.PortMapEntry
	9,  // 7: clustermetadata.MultiOrch.identifier:type_name -> clustermetadata.ID
	13, // 8: clustermetadata.MultiOrch.port_map:type_name -> clustermetadata.MultiOrch.PortMapEntry
	0,  // 9: clustermetadata.ID.component:type_name -> clustermetadata.MultigresComponent
	10, // [10:10] is the sub-list for method output_type
	10, // [10:10] is the sub-list for method input_type
	10, // [10:10] is the sub-list for extension type_name
	10, // [10:10] is the sub-list for extension extendee
	0,  // [0:10] is the sub-list for field type_name
}

func init() { file_clustermetadata_proto_init() }
func file_clustermetadata_proto_init() {
	if File_clustermetadata_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_clustermetadata_proto_rawDesc), len(file_clustermetadata_proto_rawDesc)),
			NumEnums:      3,
			NumMessages:   11,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_clustermetadata_proto_goTypes,
		DependencyIndexes: file_clustermetadata_proto_depIdxs,
		EnumInfos:         file_clustermetadata_proto_enumTypes,
		MessageInfos:      file_clustermetadata_proto_msgTypes,
	}.Build()
	File_clustermetadata_proto = out.File
	file_clustermetadata_proto_goTypes = nil
	file_clustermetadata_proto_depIdxs = nil
}
