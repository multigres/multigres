// Copyright 2025 Supabase, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        v4.25.1
// source: clustermetadata.proto

package clustermetadata

import (
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"

	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// PoolerType represents the type of a given MultiPooler.
type PoolerType int32

const (
	// UNKNOWN this is not a valid type.
	// It is useful during upgrades to detect when a value is not initialized
	PoolerType_UNKNOWN PoolerType = 0
	// PRIMARY is the primary server for the shard. Only PRIMARY allows DMLs.
	PoolerType_PRIMARY PoolerType = 1
	// REPLICA replicates from leader. It is used to read only traffic
	PoolerType_REPLICA PoolerType = 2
)

// Enum value maps for PoolerType.
var (
	PoolerType_name = map[int32]string{
		0: "UNKNOWN",
		1: "PRIMARY",
		2: "REPLICA",
	}
	PoolerType_value = map[string]int32{
		"UNKNOWN": 0,
		"PRIMARY": 1,
		"REPLICA": 2,
	}
)

func (x PoolerType) Enum() *PoolerType {
	p := new(PoolerType)
	*p = x
	return p
}

func (x PoolerType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PoolerType) Descriptor() protoreflect.EnumDescriptor {
	return file_clustermetadata_proto_enumTypes[0].Descriptor()
}

func (PoolerType) Type() protoreflect.EnumType {
	return &file_clustermetadata_proto_enumTypes[0]
}

func (x PoolerType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PoolerType.Descriptor instead.
func (PoolerType) EnumDescriptor() ([]byte, []int) {
	return file_clustermetadata_proto_rawDescGZIP(), []int{0}
}

// PoolerServingStatus represents the serving status of the given MultiPooler.
type PoolerServingStatus int32

const (
	// SERVING is the status a server during normal operations when it is serving traffic.
	PoolerServingStatus_SERVING PoolerServingStatus = 0
	// NOT_SERVING is the status of a server when it is not serving traffic.
	// This typically occurs during startup, shutdown, or when the server is
	// in an error state and cannot accept connections.
	PoolerServingStatus_NOT_SERVING PoolerServingStatus = 1
	// BACKUP is the status of a server when it is taking a backup. No queries
	// can be served in BACKUP mode.
	PoolerServingStatus_BACKUP PoolerServingStatus = 2
	// RESTORE is the status a server uses when restoring a backup, at
	// startup time.  No queries can be served in RESTORE mode.
	PoolerServingStatus_RESTORE PoolerServingStatus = 3
	// DRAINED is the status a server goes into when used by Multigres tools
	// to perform an offline action. It is a serving type (as
	// the tools processes may need to run queries), but it's not used
	// to route queries from Multigres users. In this state,
	// this multipooler is dedicated to the process that uses it.
	PoolerServingStatus_DRAINED PoolerServingStatus = 4
	// SERVING_RDONLY is the status of a server in read-only mode.
	// This is used during demotion when the server transitions from PRIMARY to REPLICA,
	// or for read-only replicas. The server accepts connections but only serves read queries.
	PoolerServingStatus_SERVING_RDONLY PoolerServingStatus = 5
)

// Enum value maps for PoolerServingStatus.
var (
	PoolerServingStatus_name = map[int32]string{
		0: "SERVING",
		1: "NOT_SERVING",
		2: "BACKUP",
		3: "RESTORE",
		4: "DRAINED",
		5: "SERVING_RDONLY",
	}
	PoolerServingStatus_value = map[string]int32{
		"SERVING":        0,
		"NOT_SERVING":    1,
		"BACKUP":         2,
		"RESTORE":        3,
		"DRAINED":        4,
		"SERVING_RDONLY": 5,
	}
)

func (x PoolerServingStatus) Enum() *PoolerServingStatus {
	p := new(PoolerServingStatus)
	*p = x
	return p
}

func (x PoolerServingStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PoolerServingStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_clustermetadata_proto_enumTypes[1].Descriptor()
}

func (PoolerServingStatus) Type() protoreflect.EnumType {
	return &file_clustermetadata_proto_enumTypes[1]
}

func (x PoolerServingStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PoolerServingStatus.Descriptor instead.
func (PoolerServingStatus) EnumDescriptor() ([]byte, []int) {
	return file_clustermetadata_proto_rawDescGZIP(), []int{1}
}

// QuorumType enumerates supported quorum algorithms
type QuorumType int32

const (
	// QUORUM_TYPE_UNKNOWN represents an unknown or uninitialized quorum type
	QuorumType_QUORUM_TYPE_UNKNOWN QuorumType = 0
	// QUORUM_TYPE_ANY_N requires any N nodes from discovered cohort
	QuorumType_QUORUM_TYPE_ANY_N QuorumType = 1
	// QUORUM_TYPE_MULTI_CELL_ANY_N requires nodes from multiple cells (availability zones)
	// with at least one node from each of the required cells
	QuorumType_QUORUM_TYPE_MULTI_CELL_ANY_N QuorumType = 2
)

// Enum value maps for QuorumType.
var (
	QuorumType_name = map[int32]string{
		0: "QUORUM_TYPE_UNKNOWN",
		1: "QUORUM_TYPE_ANY_N",
		2: "QUORUM_TYPE_MULTI_CELL_ANY_N",
	}
	QuorumType_value = map[string]int32{
		"QUORUM_TYPE_UNKNOWN":          0,
		"QUORUM_TYPE_ANY_N":            1,
		"QUORUM_TYPE_MULTI_CELL_ANY_N": 2,
	}
)

func (x QuorumType) Enum() *QuorumType {
	p := new(QuorumType)
	*p = x
	return p
}

func (x QuorumType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (QuorumType) Descriptor() protoreflect.EnumDescriptor {
	return file_clustermetadata_proto_enumTypes[2].Descriptor()
}

func (QuorumType) Type() protoreflect.EnumType {
	return &file_clustermetadata_proto_enumTypes[2]
}

func (x QuorumType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use QuorumType.Descriptor instead.
func (QuorumType) EnumDescriptor() ([]byte, []int) {
	return file_clustermetadata_proto_rawDescGZIP(), []int{2}
}

// AsyncReplicationFallbackMode defines the behavior when insufficient standbys are available
// for synchronous replication to meet the quorum requirement
type AsyncReplicationFallbackMode int32

const (
	// ASYNC_REPLICATION_FALLBACK_MODE_UNKNOWN represents an unknown or uninitialized mode
	AsyncReplicationFallbackMode_ASYNC_REPLICATION_FALLBACK_MODE_UNKNOWN AsyncReplicationFallbackMode = 0
	// ASYNC_REPLICATION_FALLBACK_MODE_ALLOW permits falling back to async replication
	// when no standby servers are available. This is the default behavior.
	AsyncReplicationFallbackMode_ASYNC_REPLICATION_FALLBACK_MODE_ALLOW AsyncReplicationFallbackMode = 1
	// ASYNC_REPLICATION_FALLBACK_MODE_REJECT rejects the leader appointment
	// if synchronous replication cannot be established to meet quorum requirements
	AsyncReplicationFallbackMode_ASYNC_REPLICATION_FALLBACK_MODE_REJECT AsyncReplicationFallbackMode = 2
)

// Enum value maps for AsyncReplicationFallbackMode.
var (
	AsyncReplicationFallbackMode_name = map[int32]string{
		0: "ASYNC_REPLICATION_FALLBACK_MODE_UNKNOWN",
		1: "ASYNC_REPLICATION_FALLBACK_MODE_ALLOW",
		2: "ASYNC_REPLICATION_FALLBACK_MODE_REJECT",
	}
	AsyncReplicationFallbackMode_value = map[string]int32{
		"ASYNC_REPLICATION_FALLBACK_MODE_UNKNOWN": 0,
		"ASYNC_REPLICATION_FALLBACK_MODE_ALLOW":   1,
		"ASYNC_REPLICATION_FALLBACK_MODE_REJECT":  2,
	}
)

func (x AsyncReplicationFallbackMode) Enum() *AsyncReplicationFallbackMode {
	p := new(AsyncReplicationFallbackMode)
	*p = x
	return p
}

func (x AsyncReplicationFallbackMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (AsyncReplicationFallbackMode) Descriptor() protoreflect.EnumDescriptor {
	return file_clustermetadata_proto_enumTypes[3].Descriptor()
}

func (AsyncReplicationFallbackMode) Type() protoreflect.EnumType {
	return &file_clustermetadata_proto_enumTypes[3]
}

func (x AsyncReplicationFallbackMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use AsyncReplicationFallbackMode.Descriptor instead.
func (AsyncReplicationFallbackMode) EnumDescriptor() ([]byte, []int) {
	return file_clustermetadata_proto_rawDescGZIP(), []int{3}
}

// ComponentType represents the type of Multigres component
type ID_ComponentType int32

const (
	// UNKNOWN represents an unknown or uninitialized component type
	ID_UNKNOWN ID_ComponentType = 0
	// MULTIPOOLER represents a multipooler component
	ID_MULTIPOOLER ID_ComponentType = 1
	// MULTIGATEWAY represents a multigateway component
	ID_MULTIGATEWAY ID_ComponentType = 2
	// MULTIORCH represents a multiorch component
	ID_MULTIORCH ID_ComponentType = 3
)

// Enum value maps for ID_ComponentType.
var (
	ID_ComponentType_name = map[int32]string{
		0: "UNKNOWN",
		1: "MULTIPOOLER",
		2: "MULTIGATEWAY",
		3: "MULTIORCH",
	}
	ID_ComponentType_value = map[string]int32{
		"UNKNOWN":      0,
		"MULTIPOOLER":  1,
		"MULTIGATEWAY": 2,
		"MULTIORCH":    3,
	}
)

func (x ID_ComponentType) Enum() *ID_ComponentType {
	p := new(ID_ComponentType)
	*p = x
	return p
}

func (x ID_ComponentType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ID_ComponentType) Descriptor() protoreflect.EnumDescriptor {
	return file_clustermetadata_proto_enumTypes[4].Descriptor()
}

func (ID_ComponentType) Type() protoreflect.EnumType {
	return &file_clustermetadata_proto_enumTypes[4]
}

func (x ID_ComponentType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ID_ComponentType.Descriptor instead.
func (ID_ComponentType) EnumDescriptor() ([]byte, []int) {
	return file_clustermetadata_proto_rawDescGZIP(), []int{6, 0}
}

// TopoConfig defines the connection parameters for a topology service.
// It specifies the type of topology backend, where it's hosted, and the
// logical root path within that backend.
// This is not stored in the topo itself, but it's the entry point to
// configure the global topo.
type GlobalTopoConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// implementation indicates the type of topology service in use
	// (for example: "etcd2",  "memory").
	Implementation string `protobuf:"bytes,1,opt,name=implementation,proto3" json:"implementation,omitempty"`
	// server is the network address (host:port) of the topology service.
	// Can be a list list for HA setups.
	ServerAddresses []string `protobuf:"bytes,2,rep,name=server_addresses,json=serverAddresses,proto3" json:"server_addresses,omitempty"`
	// root is the logical root directory or namespace inside the topology backend
	// under which all cluster metadata will be stored.
	Root          string `protobuf:"bytes,3,opt,name=root,proto3" json:"root,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GlobalTopoConfig) Reset() {
	*x = GlobalTopoConfig{}
	mi := &file_clustermetadata_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GlobalTopoConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GlobalTopoConfig) ProtoMessage() {}

func (x *GlobalTopoConfig) ProtoReflect() protoreflect.Message {
	mi := &file_clustermetadata_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GlobalTopoConfig.ProtoReflect.Descriptor instead.
func (*GlobalTopoConfig) Descriptor() ([]byte, []int) {
	return file_clustermetadata_proto_rawDescGZIP(), []int{0}
}

func (x *GlobalTopoConfig) GetImplementation() string {
	if x != nil {
		return x.Implementation
	}
	return ""
}

func (x *GlobalTopoConfig) GetServerAddresses() []string {
	if x != nil {
		return x.ServerAddresses
	}
	return nil
}

func (x *GlobalTopoConfig) GetRoot() string {
	if x != nil {
		return x.Root
	}
	return ""
}

// Cell describes how to connect to a cell topology.
// These records are stored in the global topology server.
type Cell struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name for this cell
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// server_address is the network address of the cell topology service.
	ServerAddresses []string `protobuf:"bytes,2,rep,name=server_addresses,json=serverAddresses,proto3" json:"server_addresses,omitempty"`
	// root is the namespace or directory path within the topology service
	// where this cell's metadata is stored. Used only when connecting to server_addresses.
	Root          string `protobuf:"bytes,3,opt,name=root,proto3" json:"root,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Cell) Reset() {
	*x = Cell{}
	mi := &file_clustermetadata_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Cell) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Cell) ProtoMessage() {}

func (x *Cell) ProtoReflect() protoreflect.Message {
	mi := &file_clustermetadata_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Cell.ProtoReflect.Descriptor instead.
func (*Cell) Descriptor() ([]byte, []int) {
	return file_clustermetadata_proto_rawDescGZIP(), []int{1}
}

func (x *Cell) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Cell) GetServerAddresses() []string {
	if x != nil {
		return x.ServerAddresses
	}
	return nil
}

func (x *Cell) GetRoot() string {
	if x != nil {
		return x.Root
	}
	return ""
}

type Database struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Name of the database
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Backups location
	BackupLocation string `protobuf:"bytes,2,opt,name=backup_location,json=backupLocation,proto3" json:"backup_location,omitempty"`
	// Durability policy used for consensus
	DurabilityPolicy string `protobuf:"bytes,3,opt,name=durability_policy,json=durabilityPolicy,proto3" json:"durability_policy,omitempty"`
	// List of cell identifiers where this database should be deployed
	Cells         []string `protobuf:"bytes,4,rep,name=cells,proto3" json:"cells,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Database) Reset() {
	*x = Database{}
	mi := &file_clustermetadata_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Database) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Database) ProtoMessage() {}

func (x *Database) ProtoReflect() protoreflect.Message {
	mi := &file_clustermetadata_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Database.ProtoReflect.Descriptor instead.
func (*Database) Descriptor() ([]byte, []int) {
	return file_clustermetadata_proto_rawDescGZIP(), []int{2}
}

func (x *Database) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Database) GetBackupLocation() string {
	if x != nil {
		return x.BackupLocation
	}
	return ""
}

func (x *Database) GetDurabilityPolicy() string {
	if x != nil {
		return x.DurabilityPolicy
	}
	return ""
}

func (x *Database) GetCells() []string {
	if x != nil {
		return x.Cells
	}
	return nil
}

// MultiPooler represents metadata about a running multipooler component instance in the cluster.
type MultiPooler struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// id is the unique identifier of the multipooler in the cluster.
	Id *ID `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Database name.
	Database string `protobuf:"bytes,2,opt,name=database,proto3" json:"database,omitempty"`
	// TableGroup name.
	TableGroup string `protobuf:"bytes,3,opt,name=table_group,json=tableGroup,proto3" json:"table_group,omitempty"`
	// Shard name. If range based sharding is used, it should match
	// key_range.
	Shard string `protobuf:"bytes,4,opt,name=shard,proto3" json:"shard,omitempty"`
	// If range based sharding is used, range for the pooler's shard.
	KeyRange *KeyRange `protobuf:"bytes,5,opt,name=key_range,json=keyRange,proto3" json:"key_range,omitempty"`
	// PoolerType is the kind of pooler: PRIMARY or REPLICA
	Type PoolerType `protobuf:"varint,6,opt,name=type,proto3,enum=clustermetadata.PoolerType" json:"type,omitempty"`
	// PoolerServingStatus is the current type of the pooler.
	ServingStatus PoolerServingStatus `protobuf:"varint,7,opt,name=serving_status,json=servingStatus,proto3,enum=clustermetadata.PoolerServingStatus" json:"serving_status,omitempty"`
	// Fully qualified domain name of the host.
	Hostname string `protobuf:"bytes,8,opt,name=hostname,proto3" json:"hostname,omitempty"`
	// Map of named ports. These are ports that the pooler exposes. Initially, this will only be gRPC
	PortMap       map[string]int32 `protobuf:"bytes,9,rep,name=port_map,json=portMap,proto3" json:"port_map,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MultiPooler) Reset() {
	*x = MultiPooler{}
	mi := &file_clustermetadata_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MultiPooler) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MultiPooler) ProtoMessage() {}

func (x *MultiPooler) ProtoReflect() protoreflect.Message {
	mi := &file_clustermetadata_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MultiPooler.ProtoReflect.Descriptor instead.
func (*MultiPooler) Descriptor() ([]byte, []int) {
	return file_clustermetadata_proto_rawDescGZIP(), []int{3}
}

func (x *MultiPooler) GetId() *ID {
	if x != nil {
		return x.Id
	}
	return nil
}

func (x *MultiPooler) GetDatabase() string {
	if x != nil {
		return x.Database
	}
	return ""
}

func (x *MultiPooler) GetTableGroup() string {
	if x != nil {
		return x.TableGroup
	}
	return ""
}

func (x *MultiPooler) GetShard() string {
	if x != nil {
		return x.Shard
	}
	return ""
}

func (x *MultiPooler) GetKeyRange() *KeyRange {
	if x != nil {
		return x.KeyRange
	}
	return nil
}

func (x *MultiPooler) GetType() PoolerType {
	if x != nil {
		return x.Type
	}
	return PoolerType_UNKNOWN
}

func (x *MultiPooler) GetServingStatus() PoolerServingStatus {
	if x != nil {
		return x.ServingStatus
	}
	return PoolerServingStatus_SERVING
}

func (x *MultiPooler) GetHostname() string {
	if x != nil {
		return x.Hostname
	}
	return ""
}

func (x *MultiPooler) GetPortMap() map[string]int32 {
	if x != nil {
		return x.PortMap
	}
	return nil
}

// MultiGateway represents metadata about a running multigateway component instance in the cluster.
type MultiGateway struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// id is the unique name of the multi gateway in the cluster.
	Id *ID `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Fully qualified domain name of the host.
	Hostname string `protobuf:"bytes,2,opt,name=hostname,proto3" json:"hostname,omitempty"`
	// Map of named ports. Normally this should include postgres and grpc.
	PortMap       map[string]int32 `protobuf:"bytes,3,rep,name=port_map,json=portMap,proto3" json:"port_map,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MultiGateway) Reset() {
	*x = MultiGateway{}
	mi := &file_clustermetadata_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MultiGateway) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MultiGateway) ProtoMessage() {}

func (x *MultiGateway) ProtoReflect() protoreflect.Message {
	mi := &file_clustermetadata_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MultiGateway.ProtoReflect.Descriptor instead.
func (*MultiGateway) Descriptor() ([]byte, []int) {
	return file_clustermetadata_proto_rawDescGZIP(), []int{4}
}

func (x *MultiGateway) GetId() *ID {
	if x != nil {
		return x.Id
	}
	return nil
}

func (x *MultiGateway) GetHostname() string {
	if x != nil {
		return x.Hostname
	}
	return ""
}

func (x *MultiGateway) GetPortMap() map[string]int32 {
	if x != nil {
		return x.PortMap
	}
	return nil
}

// MultiOrch represents information about a running instance of multiorch.
type MultiOrch struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// id is the unique name of the MultiOrch in the cluster.
	Id *ID `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Fully qualified domain name of the host.
	Hostname string `protobuf:"bytes,2,opt,name=hostname,proto3" json:"hostname,omitempty"`
	// Map of named ports. These are ports that MultiOrc exposes.
	PortMap       map[string]int32 `protobuf:"bytes,3,rep,name=port_map,json=portMap,proto3" json:"port_map,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MultiOrch) Reset() {
	*x = MultiOrch{}
	mi := &file_clustermetadata_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MultiOrch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MultiOrch) ProtoMessage() {}

func (x *MultiOrch) ProtoReflect() protoreflect.Message {
	mi := &file_clustermetadata_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MultiOrch.ProtoReflect.Descriptor instead.
func (*MultiOrch) Descriptor() ([]byte, []int) {
	return file_clustermetadata_proto_rawDescGZIP(), []int{5}
}

func (x *MultiOrch) GetId() *ID {
	if x != nil {
		return x.Id
	}
	return nil
}

func (x *MultiOrch) GetHostname() string {
	if x != nil {
		return x.Hostname
	}
	return ""
}

func (x *MultiOrch) GetPortMap() map[string]int32 {
	if x != nil {
		return x.PortMap
	}
	return nil
}

// ID is a globally unique pooler identifier.
type ID struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// component identifies the type of Multigres component (multipooler, multigateway, or multiorch)
	Component ID_ComponentType `protobuf:"varint,1,opt,name=component,proto3,enum=clustermetadata.ID_ComponentType" json:"component,omitempty"`
	// cell is the Multigres cell where the component is located
	Cell string `protobuf:"bytes,2,opt,name=cell,proto3" json:"cell,omitempty"`
	// name is a unique identifier for the component within the multigres
	// cluster.
	Name          string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ID) Reset() {
	*x = ID{}
	mi := &file_clustermetadata_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ID) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ID) ProtoMessage() {}

func (x *ID) ProtoReflect() protoreflect.Message {
	mi := &file_clustermetadata_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ID.ProtoReflect.Descriptor instead.
func (*ID) Descriptor() ([]byte, []int) {
	return file_clustermetadata_proto_rawDescGZIP(), []int{6}
}

func (x *ID) GetComponent() ID_ComponentType {
	if x != nil {
		return x.Component
	}
	return ID_UNKNOWN
}

func (x *ID) GetCell() string {
	if x != nil {
		return x.Cell
	}
	return ""
}

func (x *ID) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

// KeyRange represents a range of keys for sharding
type KeyRange struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// start is the start key of the range (inclusive)
	Start []byte `protobuf:"bytes,1,opt,name=start,proto3" json:"start,omitempty"`
	// end is the end key of the range (exclusive)
	End           []byte `protobuf:"bytes,2,opt,name=end,proto3" json:"end,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KeyRange) Reset() {
	*x = KeyRange{}
	mi := &file_clustermetadata_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KeyRange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KeyRange) ProtoMessage() {}

func (x *KeyRange) ProtoReflect() protoreflect.Message {
	mi := &file_clustermetadata_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KeyRange.ProtoReflect.Descriptor instead.
func (*KeyRange) Descriptor() ([]byte, []int) {
	return file_clustermetadata_proto_rawDescGZIP(), []int{7}
}

func (x *KeyRange) GetStart() []byte {
	if x != nil {
		return x.Start
	}
	return nil
}

func (x *KeyRange) GetEnd() []byte {
	if x != nil {
		return x.End
	}
	return nil
}

// DurabilityPolicy defines consensus quorum rules for a shard.
// These policies are stored locally in each shard's postgres database
// and replicated via postgres streaming replication.
type DurabilityPolicy struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// policy_name references Database.durability_policy (e.g., "any-two")
	PolicyName string `protobuf:"bytes,1,opt,name=policy_name,json=policyName,proto3" json:"policy_name,omitempty"`
	// policy_version allows policy evolution over time
	PolicyVersion int64 `protobuf:"varint,2,opt,name=policy_version,json=policyVersion,proto3" json:"policy_version,omitempty"`
	// quorum_rule defines the actual quorum requirements
	QuorumRule *QuorumRule `protobuf:"bytes,3,opt,name=quorum_rule,json=quorumRule,proto3" json:"quorum_rule,omitempty"`
	// is_active indicates if this is the current active policy
	IsActive bool `protobuf:"varint,4,opt,name=is_active,json=isActive,proto3" json:"is_active,omitempty"`
	// Audit timestamps
	CreatedAt     *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	UpdatedAt     *timestamppb.Timestamp `protobuf:"bytes,6,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DurabilityPolicy) Reset() {
	*x = DurabilityPolicy{}
	mi := &file_clustermetadata_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DurabilityPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DurabilityPolicy) ProtoMessage() {}

func (x *DurabilityPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_clustermetadata_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DurabilityPolicy.ProtoReflect.Descriptor instead.
func (*DurabilityPolicy) Descriptor() ([]byte, []int) {
	return file_clustermetadata_proto_rawDescGZIP(), []int{8}
}

func (x *DurabilityPolicy) GetPolicyName() string {
	if x != nil {
		return x.PolicyName
	}
	return ""
}

func (x *DurabilityPolicy) GetPolicyVersion() int64 {
	if x != nil {
		return x.PolicyVersion
	}
	return 0
}

func (x *DurabilityPolicy) GetQuorumRule() *QuorumRule {
	if x != nil {
		return x.QuorumRule
	}
	return nil
}

func (x *DurabilityPolicy) GetIsActive() bool {
	if x != nil {
		return x.IsActive
	}
	return false
}

func (x *DurabilityPolicy) GetCreatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedAt
	}
	return nil
}

func (x *DurabilityPolicy) GetUpdatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.UpdatedAt
	}
	return nil
}

// QuorumRule defines how many nodes are required for quorum
type QuorumRule struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// quorum_type determines which quorum algorithm to use
	QuorumType QuorumType `protobuf:"varint,1,opt,name=quorum_type,json=quorumType,proto3,enum=clustermetadata.QuorumType" json:"quorum_type,omitempty"`
	// required_count: number of nodes/cells required
	//   - For QUORUM_TYPE_ANY_N: number of nodes required from discovered cohort
	//   - For QUORUM_TYPE_MULTI_CELL_ANY_N: number of distinct cells required,
	//     with at least one node from each cell
	RequiredCount int32 `protobuf:"varint,2,opt,name=required_count,json=requiredCount,proto3" json:"required_count,omitempty"`
	// Human-readable description
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// async_fallback defines behavior when insufficient standbys are available
	// for synchronous replication. Defaults to ALLOW if unset.
	AsyncFallback AsyncReplicationFallbackMode `protobuf:"varint,4,opt,name=async_fallback,json=asyncFallback,proto3,enum=clustermetadata.AsyncReplicationFallbackMode" json:"async_fallback,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QuorumRule) Reset() {
	*x = QuorumRule{}
	mi := &file_clustermetadata_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QuorumRule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QuorumRule) ProtoMessage() {}

func (x *QuorumRule) ProtoReflect() protoreflect.Message {
	mi := &file_clustermetadata_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QuorumRule.ProtoReflect.Descriptor instead.
func (*QuorumRule) Descriptor() ([]byte, []int) {
	return file_clustermetadata_proto_rawDescGZIP(), []int{9}
}

func (x *QuorumRule) GetQuorumType() QuorumType {
	if x != nil {
		return x.QuorumType
	}
	return QuorumType_QUORUM_TYPE_UNKNOWN
}

func (x *QuorumRule) GetRequiredCount() int32 {
	if x != nil {
		return x.RequiredCount
	}
	return 0
}

func (x *QuorumRule) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *QuorumRule) GetAsyncFallback() AsyncReplicationFallbackMode {
	if x != nil {
		return x.AsyncFallback
	}
	return AsyncReplicationFallbackMode_ASYNC_REPLICATION_FALLBACK_MODE_UNKNOWN
}

var File_clustermetadata_proto protoreflect.FileDescriptor

const file_clustermetadata_proto_rawDesc = "" +
	"\n" +
	"\x15clustermetadata.proto\x12\x0fclustermetadata\x1a\x1fgoogle/protobuf/timestamp.proto\"y\n" +
	"\x10GlobalTopoConfig\x12&\n" +
	"\x0eimplementation\x18\x01 \x01(\tR\x0eimplementation\x12)\n" +
	"\x10server_addresses\x18\x02 \x03(\tR\x0fserverAddresses\x12\x12\n" +
	"\x04root\x18\x03 \x01(\tR\x04root\"Y\n" +
	"\x04Cell\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12)\n" +
	"\x10server_addresses\x18\x02 \x03(\tR\x0fserverAddresses\x12\x12\n" +
	"\x04root\x18\x03 \x01(\tR\x04root\"\x8a\x01\n" +
	"\bDatabase\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12'\n" +
	"\x0fbackup_location\x18\x02 \x01(\tR\x0ebackupLocation\x12+\n" +
	"\x11durability_policy\x18\x03 \x01(\tR\x10durabilityPolicy\x12\x14\n" +
	"\x05cells\x18\x04 \x03(\tR\x05cells\"\xd9\x03\n" +
	"\vMultiPooler\x12#\n" +
	"\x02id\x18\x01 \x01(\v2\x13.clustermetadata.IDR\x02id\x12\x1a\n" +
	"\bdatabase\x18\x02 \x01(\tR\bdatabase\x12\x1f\n" +
	"\vtable_group\x18\x03 \x01(\tR\n" +
	"tableGroup\x12\x14\n" +
	"\x05shard\x18\x04 \x01(\tR\x05shard\x126\n" +
	"\tkey_range\x18\x05 \x01(\v2\x19.clustermetadata.KeyRangeR\bkeyRange\x12/\n" +
	"\x04type\x18\x06 \x01(\x0e2\x1b.clustermetadata.PoolerTypeR\x04type\x12K\n" +
	"\x0eserving_status\x18\a \x01(\x0e2$.clustermetadata.PoolerServingStatusR\rservingStatus\x12\x1a\n" +
	"\bhostname\x18\b \x01(\tR\bhostname\x12D\n" +
	"\bport_map\x18\t \x03(\v2).clustermetadata.MultiPooler.PortMapEntryR\aportMap\x1a:\n" +
	"\fPortMapEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\x05R\x05value:\x028\x01\"\xd2\x01\n" +
	"\fMultiGateway\x12#\n" +
	"\x02id\x18\x01 \x01(\v2\x13.clustermetadata.IDR\x02id\x12\x1a\n" +
	"\bhostname\x18\x02 \x01(\tR\bhostname\x12E\n" +
	"\bport_map\x18\x03 \x03(\v2*.clustermetadata.MultiGateway.PortMapEntryR\aportMap\x1a:\n" +
	"\fPortMapEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\x05R\x05value:\x028\x01\"\xcc\x01\n" +
	"\tMultiOrch\x12#\n" +
	"\x02id\x18\x01 \x01(\v2\x13.clustermetadata.IDR\x02id\x12\x1a\n" +
	"\bhostname\x18\x02 \x01(\tR\bhostname\x12B\n" +
	"\bport_map\x18\x03 \x03(\v2'.clustermetadata.MultiOrch.PortMapEntryR\aportMap\x1a:\n" +
	"\fPortMapEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\x05R\x05value:\x028\x01\"\xbd\x01\n" +
	"\x02ID\x12?\n" +
	"\tcomponent\x18\x01 \x01(\x0e2!.clustermetadata.ID.ComponentTypeR\tcomponent\x12\x12\n" +
	"\x04cell\x18\x02 \x01(\tR\x04cell\x12\x12\n" +
	"\x04name\x18\x03 \x01(\tR\x04name\"N\n" +
	"\rComponentType\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\x0f\n" +
	"\vMULTIPOOLER\x10\x01\x12\x10\n" +
	"\fMULTIGATEWAY\x10\x02\x12\r\n" +
	"\tMULTIORCH\x10\x03\"2\n" +
	"\bKeyRange\x12\x14\n" +
	"\x05start\x18\x01 \x01(\fR\x05start\x12\x10\n" +
	"\x03end\x18\x02 \x01(\fR\x03end\"\xab\x02\n" +
	"\x10DurabilityPolicy\x12\x1f\n" +
	"\vpolicy_name\x18\x01 \x01(\tR\n" +
	"policyName\x12%\n" +
	"\x0epolicy_version\x18\x02 \x01(\x03R\rpolicyVersion\x12<\n" +
	"\vquorum_rule\x18\x03 \x01(\v2\x1b.clustermetadata.QuorumRuleR\n" +
	"quorumRule\x12\x1b\n" +
	"\tis_active\x18\x04 \x01(\bR\bisActive\x129\n" +
	"\n" +
	"created_at\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\tcreatedAt\x129\n" +
	"\n" +
	"updated_at\x18\x06 \x01(\v2\x1a.google.protobuf.TimestampR\tupdatedAt\"\xe9\x01\n" +
	"\n" +
	"QuorumRule\x12<\n" +
	"\vquorum_type\x18\x01 \x01(\x0e2\x1b.clustermetadata.QuorumTypeR\n" +
	"quorumType\x12%\n" +
	"\x0erequired_count\x18\x02 \x01(\x05R\rrequiredCount\x12 \n" +
	"\vdescription\x18\x03 \x01(\tR\vdescription\x12T\n" +
	"\x0easync_fallback\x18\x04 \x01(\x0e2-.clustermetadata.AsyncReplicationFallbackModeR\rasyncFallback*3\n" +
	"\n" +
	"PoolerType\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\v\n" +
	"\aPRIMARY\x10\x01\x12\v\n" +
	"\aREPLICA\x10\x02*m\n" +
	"\x13PoolerServingStatus\x12\v\n" +
	"\aSERVING\x10\x00\x12\x0f\n" +
	"\vNOT_SERVING\x10\x01\x12\n" +
	"\n" +
	"\x06BACKUP\x10\x02\x12\v\n" +
	"\aRESTORE\x10\x03\x12\v\n" +
	"\aDRAINED\x10\x04\x12\x12\n" +
	"\x0eSERVING_RDONLY\x10\x05*^\n" +
	"\n" +
	"QuorumType\x12\x17\n" +
	"\x13QUORUM_TYPE_UNKNOWN\x10\x00\x12\x15\n" +
	"\x11QUORUM_TYPE_ANY_N\x10\x01\x12 \n" +
	"\x1cQUORUM_TYPE_MULTI_CELL_ANY_N\x10\x02*\xa2\x01\n" +
	"\x1cAsyncReplicationFallbackMode\x12+\n" +
	"'ASYNC_REPLICATION_FALLBACK_MODE_UNKNOWN\x10\x00\x12)\n" +
	"%ASYNC_REPLICATION_FALLBACK_MODE_ALLOW\x10\x01\x12*\n" +
	"&ASYNC_REPLICATION_FALLBACK_MODE_REJECT\x10\x02B6Z4github.com/multigres/multigres/go/pb/clustermetadatab\x06proto3"

var (
	file_clustermetadata_proto_rawDescOnce sync.Once
	file_clustermetadata_proto_rawDescData []byte
)

func file_clustermetadata_proto_rawDescGZIP() []byte {
	file_clustermetadata_proto_rawDescOnce.Do(func() {
		file_clustermetadata_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_clustermetadata_proto_rawDesc), len(file_clustermetadata_proto_rawDesc)))
	})
	return file_clustermetadata_proto_rawDescData
}

var file_clustermetadata_proto_enumTypes = make([]protoimpl.EnumInfo, 5)
var file_clustermetadata_proto_msgTypes = make([]protoimpl.MessageInfo, 13)
var file_clustermetadata_proto_goTypes = []any{
	(PoolerType)(0),                   // 0: clustermetadata.PoolerType
	(PoolerServingStatus)(0),          // 1: clustermetadata.PoolerServingStatus
	(QuorumType)(0),                   // 2: clustermetadata.QuorumType
	(AsyncReplicationFallbackMode)(0), // 3: clustermetadata.AsyncReplicationFallbackMode
	(ID_ComponentType)(0),             // 4: clustermetadata.ID.ComponentType
	(*GlobalTopoConfig)(nil),          // 5: clustermetadata.GlobalTopoConfig
	(*Cell)(nil),                      // 6: clustermetadata.Cell
	(*Database)(nil),                  // 7: clustermetadata.Database
	(*MultiPooler)(nil),               // 8: clustermetadata.MultiPooler
	(*MultiGateway)(nil),              // 9: clustermetadata.MultiGateway
	(*MultiOrch)(nil),                 // 10: clustermetadata.MultiOrch
	(*ID)(nil),                        // 11: clustermetadata.ID
	(*KeyRange)(nil),                  // 12: clustermetadata.KeyRange
	(*DurabilityPolicy)(nil),          // 13: clustermetadata.DurabilityPolicy
	(*QuorumRule)(nil),                // 14: clustermetadata.QuorumRule
	nil,                               // 15: clustermetadata.MultiPooler.PortMapEntry
	nil,                               // 16: clustermetadata.MultiGateway.PortMapEntry
	nil,                               // 17: clustermetadata.MultiOrch.PortMapEntry
	(*timestamppb.Timestamp)(nil),     // 18: google.protobuf.Timestamp
}
var file_clustermetadata_proto_depIdxs = []int32{
	11, // 0: clustermetadata.MultiPooler.id:type_name -> clustermetadata.ID
	12, // 1: clustermetadata.MultiPooler.key_range:type_name -> clustermetadata.KeyRange
	0,  // 2: clustermetadata.MultiPooler.type:type_name -> clustermetadata.PoolerType
	1,  // 3: clustermetadata.MultiPooler.serving_status:type_name -> clustermetadata.PoolerServingStatus
	15, // 4: clustermetadata.MultiPooler.port_map:type_name -> clustermetadata.MultiPooler.PortMapEntry
	11, // 5: clustermetadata.MultiGateway.id:type_name -> clustermetadata.ID
	16, // 6: clustermetadata.MultiGateway.port_map:type_name -> clustermetadata.MultiGateway.PortMapEntry
	11, // 7: clustermetadata.MultiOrch.id:type_name -> clustermetadata.ID
	17, // 8: clustermetadata.MultiOrch.port_map:type_name -> clustermetadata.MultiOrch.PortMapEntry
	4,  // 9: clustermetadata.ID.component:type_name -> clustermetadata.ID.ComponentType
	14, // 10: clustermetadata.DurabilityPolicy.quorum_rule:type_name -> clustermetadata.QuorumRule
	18, // 11: clustermetadata.DurabilityPolicy.created_at:type_name -> google.protobuf.Timestamp
	18, // 12: clustermetadata.DurabilityPolicy.updated_at:type_name -> google.protobuf.Timestamp
	2,  // 13: clustermetadata.QuorumRule.quorum_type:type_name -> clustermetadata.QuorumType
	3,  // 14: clustermetadata.QuorumRule.async_fallback:type_name -> clustermetadata.AsyncReplicationFallbackMode
	15, // [15:15] is the sub-list for method output_type
	15, // [15:15] is the sub-list for method input_type
	15, // [15:15] is the sub-list for extension type_name
	15, // [15:15] is the sub-list for extension extendee
	0,  // [0:15] is the sub-list for field type_name
}

func init() { file_clustermetadata_proto_init() }
func file_clustermetadata_proto_init() {
	if File_clustermetadata_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_clustermetadata_proto_rawDesc), len(file_clustermetadata_proto_rawDesc)),
			NumEnums:      5,
			NumMessages:   13,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_clustermetadata_proto_goTypes,
		DependencyIndexes: file_clustermetadata_proto_depIdxs,
		EnumInfos:         file_clustermetadata_proto_enumTypes,
		MessageInfos:      file_clustermetadata_proto_msgTypes,
	}.Build()
	File_clustermetadata_proto = out.File
	file_clustermetadata_proto_goTypes = nil
	file_clustermetadata_proto_depIdxs = nil
}
