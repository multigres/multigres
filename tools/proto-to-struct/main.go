// Copyright 2025 Supabase, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// proto-to-struct generates plain Go structs from protobuf message definitions
// using protobuf reflection. This enables immutable data patterns without deep
// copies - the generated structs contain only value types.
//
// The generator discovers all messages dynamically from proto file descriptors,
// so it never needs updating when protos change.
//
// Usage:
//
//	go run ./tools/proto-to-struct -proto=clustermetadata.proto -output=go/common/types/
package main

import (
	"flag"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"
	"unicode"

	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/reflect/protoregistry"

	// Import the proto packages to register their file descriptors.
	// This is the ONLY place we reference specific protos - just to trigger registration.
	_ "github.com/multigres/multigres/go/pb/clustermetadata"
)

func main() {
	protoFile := flag.String("proto", "clustermetadata.proto", "Proto file name to generate from")
	outputDir := flag.String("output", "go/common/types/", "Output directory")
	packageName := flag.String("package", "types", "Go package name for generated file")
	flag.Parse()

	// Find the file descriptor
	fd, err := protoregistry.GlobalFiles.FindFileByPath(*protoFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error finding proto file %s: %v\n", *protoFile, err)
		fmt.Fprintf(os.Stderr, "Make sure the proto package is imported to register its descriptor.\n")
		os.Exit(1)
	}

	// Generate the code
	code := generateFile(fd, *packageName)

	// Format the code
	formatted, err := format.Source([]byte(code))
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error formatting code: %v\n", err)
		fmt.Fprintf(os.Stderr, "Raw code:\n%s\n", code)
		os.Exit(1)
	}

	// Write to file
	baseName := strings.TrimSuffix(*protoFile, ".proto")
	outputFile := filepath.Join(*outputDir, baseName+"_gen.go")
	if err := os.MkdirAll(*outputDir, 0o755); err != nil {
		fmt.Fprintf(os.Stderr, "Error creating output directory: %v\n", err)
		os.Exit(1)
	}

	if err := os.WriteFile(outputFile, formatted, 0o644); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing file: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Generated %s (%d messages, %d enums)\n",
		outputFile, fd.Messages().Len(), fd.Enums().Len())
}

func generateFile(fd protoreflect.FileDescriptor, packageName string) string {
	var sb strings.Builder

	protoPackage := string(fd.Package())
	goImportPath := inferGoImportPath(fd)

	// Header
	sb.WriteString(fmt.Sprintf(`// Copyright 2025 Supabase, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by proto-to-struct. DO NOT EDIT.
// Source: %s
// Generated: %s

package %s

import (
	"time"

	"google.golang.org/protobuf/types/known/timestamppb"

	pb "%s"
)

`, fd.Path(), time.Now().Format(time.RFC3339), packageName, goImportPath))

	// Generate helper functions
	sb.WriteString(generateHelpers())

	// Collect all messages (including nested) and sort by name for deterministic output
	messages := collectMessages(fd.Messages())
	sort.Slice(messages, func(i, j int) bool {
		return messages[i].FullName() < messages[j].FullName()
	})

	// Generate structs for all messages
	for _, md := range messages {
		sb.WriteString(generateMessage(md, protoPackage))
		sb.WriteString("\n")
	}

	return sb.String()
}

func generateHelpers() string {
	return `// Helper functions for type conversions

func copyStringSlice(s []string) []string {
	if s == nil {
		return nil
	}
	c := make([]string, len(s))
	copy(c, s)
	return c
}

func copyBytes(b []byte) []byte {
	if b == nil {
		return nil
	}
	c := make([]byte, len(b))
	copy(c, b)
	return c
}

func copyStringInt32Map(m map[string]int32) map[string]int32 {
	if m == nil {
		return nil
	}
	c := make(map[string]int32, len(m))
	for k, v := range m {
		c[k] = v
	}
	return c
}

func protoTimestampToTime(ts *timestamppb.Timestamp) time.Time {
	if ts == nil {
		return time.Time{}
	}
	return ts.AsTime()
}

func timeToProtoTimestamp(t time.Time) *timestamppb.Timestamp {
	if t.IsZero() {
		return nil
	}
	return timestamppb.New(t)
}

`
}

func collectMessages(messages protoreflect.MessageDescriptors) []protoreflect.MessageDescriptor {
	var result []protoreflect.MessageDescriptor
	for i := 0; i < messages.Len(); i++ {
		md := messages.Get(i)
		// Skip map entry messages (they're synthetic)
		if md.IsMapEntry() {
			continue
		}
		result = append(result, md)
		// Recursively collect nested messages
		result = append(result, collectMessages(md.Messages())...)
	}
	return result
}

func generateMessage(md protoreflect.MessageDescriptor, protoPackage string) string {
	var sb strings.Builder

	structName := messageStructName(md)
	pbTypeName := pbTypeName(md)

	// Struct definition with doc comment
	sb.WriteString(fmt.Sprintf("// %s is an immutable plain Go struct mirroring pb.%s.\n",
		structName, pbTypeName))
	sb.WriteString(fmt.Sprintf("type %s struct {\n", structName))

	// Generate fields
	fields := md.Fields()
	for i := 0; i < fields.Len(); i++ {
		fd := fields.Get(i)
		fieldName := goFieldName(fd)
		fieldType := goFieldType(fd)
		sb.WriteString(fmt.Sprintf("\t%s %s\n", fieldName, fieldType))
	}

	sb.WriteString("}\n\n")

	// FromProto function
	sb.WriteString(generateFromProto(md, structName, pbTypeName))

	// ToProto method
	sb.WriteString(generateToProto(md, structName, pbTypeName))

	return sb.String()
}

func generateFromProto(md protoreflect.MessageDescriptor, structName, pbTypeName string) string {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("// %sFromProto creates a %s from a protobuf message.\n",
		structName, structName))
	sb.WriteString(fmt.Sprintf("func %sFromProto(p *pb.%s) %s {\n", structName, pbTypeName, structName))
	sb.WriteString(fmt.Sprintf("\tif p == nil {\n\t\treturn %s{}\n\t}\n", structName))
	sb.WriteString(fmt.Sprintf("\treturn %s{\n", structName))

	fields := md.Fields()
	for i := 0; i < fields.Len(); i++ {
		fd := fields.Get(i)
		fieldName := goFieldName(fd)
		conversion := fromProtoConversion(fd)
		sb.WriteString(fmt.Sprintf("\t\t%s: %s,\n", fieldName, conversion))
	}

	sb.WriteString("\t}\n}\n\n")
	return sb.String()
}

func generateToProto(md protoreflect.MessageDescriptor, structName, pbTypeName string) string {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("// ToProto converts back to a protobuf message.\n"))
	sb.WriteString(fmt.Sprintf("func (s %s) ToProto() *pb.%s {\n", structName, pbTypeName))
	sb.WriteString(fmt.Sprintf("\treturn &pb.%s{\n", pbTypeName))

	fields := md.Fields()
	for i := 0; i < fields.Len(); i++ {
		fd := fields.Get(i)
		fieldName := goFieldName(fd)
		conversion := toProtoConversion(fd, fieldName)
		sb.WriteString(fmt.Sprintf("\t\t%s: %s,\n", fieldName, conversion))
	}

	sb.WriteString("\t}\n}\n\n")
	return sb.String()
}

func fromProtoConversion(fd protoreflect.FieldDescriptor) string {
	fieldName := goFieldName(fd)
	getter := fmt.Sprintf("p.Get%s()", fieldName)

	// Handle maps
	if fd.IsMap() {
		keyKind := fd.MapKey().Kind()
		valueKind := fd.MapValue().Kind()
		if keyKind == protoreflect.StringKind && valueKind == protoreflect.Int32Kind {
			return fmt.Sprintf("copyStringInt32Map(%s)", getter)
		}
		// For other map types, just copy directly (may need more helpers)
		return getter
	}

	// Handle repeated fields (but not maps, not bytes)
	if fd.IsList() {
		if fd.Kind() == protoreflect.StringKind {
			return fmt.Sprintf("copyStringSlice(%s)", getter)
		}
		if fd.Kind() == protoreflect.BytesKind {
			return fmt.Sprintf("copyBytes(%s)", getter)
		}
		// For other slice types, copy directly
		return getter
	}

	// Handle message types
	if fd.Kind() == protoreflect.MessageKind {
		msgDesc := fd.Message()

		// Special case: google.protobuf.Timestamp
		if msgDesc.FullName() == "google.protobuf.Timestamp" {
			return fmt.Sprintf("protoTimestampToTime(%s)", getter)
		}

		// Nested message - use FromProto converter
		nestedStructName := messageStructName(msgDesc)
		return fmt.Sprintf("%sFromProto(%s)", nestedStructName, getter)
	}

	// Handle bytes
	if fd.Kind() == protoreflect.BytesKind {
		return fmt.Sprintf("copyBytes(%s)", getter)
	}

	// Enums and primitives - direct copy
	return getter
}

func toProtoConversion(fd protoreflect.FieldDescriptor, fieldName string) string {
	fieldAccess := fmt.Sprintf("s.%s", fieldName)

	// Handle maps
	if fd.IsMap() {
		keyKind := fd.MapKey().Kind()
		valueKind := fd.MapValue().Kind()
		if keyKind == protoreflect.StringKind && valueKind == protoreflect.Int32Kind {
			return fmt.Sprintf("copyStringInt32Map(%s)", fieldAccess)
		}
		return fieldAccess
	}

	// Handle repeated fields
	if fd.IsList() {
		if fd.Kind() == protoreflect.StringKind {
			return fmt.Sprintf("copyStringSlice(%s)", fieldAccess)
		}
		if fd.Kind() == protoreflect.BytesKind {
			return fmt.Sprintf("copyBytes(%s)", fieldAccess)
		}
		return fieldAccess
	}

	// Handle message types
	if fd.Kind() == protoreflect.MessageKind {
		msgDesc := fd.Message()

		// Special case: google.protobuf.Timestamp
		if msgDesc.FullName() == "google.protobuf.Timestamp" {
			return fmt.Sprintf("timeToProtoTimestamp(%s)", fieldAccess)
		}

		// Nested message - use ToProto converter
		return fmt.Sprintf("%s.ToProto()", fieldAccess)
	}

	// Handle bytes
	if fd.Kind() == protoreflect.BytesKind {
		return fmt.Sprintf("copyBytes(%s)", fieldAccess)
	}

	// Enums and primitives - direct copy
	return fieldAccess
}

func goFieldType(fd protoreflect.FieldDescriptor) string {
	// Handle maps
	if fd.IsMap() {
		keyType := scalarKindToGoType(fd.MapKey().Kind())
		var valueType string
		if fd.MapValue().Kind() == protoreflect.MessageKind {
			valueType = messageStructName(fd.MapValue().Message())
		} else if fd.MapValue().Kind() == protoreflect.EnumKind {
			valueType = enumGoType(fd.MapValue().Enum())
		} else {
			valueType = scalarKindToGoType(fd.MapValue().Kind())
		}
		return fmt.Sprintf("map[%s]%s", keyType, valueType)
	}

	// Handle repeated fields
	if fd.IsList() {
		return "[]" + singleFieldType(fd)
	}

	// Scalar, enum, or message
	return singleFieldType(fd)
}

func singleFieldType(fd protoreflect.FieldDescriptor) string {
	switch fd.Kind() {
	case protoreflect.EnumKind:
		return enumGoType(fd.Enum())
	case protoreflect.MessageKind:
		msgDesc := fd.Message()
		if msgDesc == nil {
			return "interface{}"
		}
		// Special case: google.protobuf.Timestamp -> time.Time
		if msgDesc.FullName() == "google.protobuf.Timestamp" {
			return "time.Time"
		}
		// Use our generated struct type (value type, not pointer)
		return messageStructName(msgDesc)
	default:
		return scalarKindToGoType(fd.Kind())
	}
}

func scalarKindToGoType(kind protoreflect.Kind) string {
	switch kind {
	case protoreflect.BoolKind:
		return "bool"
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		return "int32"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		return "int64"
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		return "uint32"
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		return "uint64"
	case protoreflect.FloatKind:
		return "float32"
	case protoreflect.DoubleKind:
		return "float64"
	case protoreflect.StringKind:
		return "string"
	case protoreflect.BytesKind:
		return "[]byte"
	default:
		return "interface{}"
	}
}

func enumGoType(ed protoreflect.EnumDescriptor) string {
	if ed == nil {
		return "int32"
	}
	// Build the Go type name for the enum
	// Handle nested enums (e.g., ID.ComponentType -> ID_ComponentType)
	var parts []string

	// First, check if the enum is nested inside a message
	parent := ed.Parent()
	for {
		if md, ok := parent.(protoreflect.MessageDescriptor); ok {
			parts = append([]string{string(md.Name())}, parts...)
			parent = md.Parent()
		} else {
			break
		}
	}

	// Add the enum name itself
	parts = append(parts, string(ed.Name()))

	return "pb." + strings.Join(parts, "_")
}

// messageStructName returns the Go struct name for a message descriptor.
// For nested messages like ID.ComponentType, returns "ID_ComponentType".
func messageStructName(md protoreflect.MessageDescriptor) string {
	var parts []string
	for m := md; m != nil; m = m.Parent().(protoreflect.MessageDescriptor) {
		parts = append([]string{string(m.Name())}, parts...)
		if _, ok := m.Parent().(protoreflect.FileDescriptor); ok {
			break
		}
	}
	return strings.Join(parts, "_")
}

// pbTypeName returns the protobuf Go type name (how it appears in the pb package).
func pbTypeName(md protoreflect.MessageDescriptor) string {
	return messageStructName(md)
}

// goFieldName converts a proto field name to Go field name (PascalCase).
func goFieldName(fd protoreflect.FieldDescriptor) string {
	name := string(fd.Name())
	return snakeToPascal(name)
}

// snakeToPascal converts snake_case to PascalCase.
func snakeToPascal(s string) string {
	var result strings.Builder
	capitalizeNext := true
	for _, r := range s {
		if r == '_' {
			capitalizeNext = true
			continue
		}
		if capitalizeNext {
			result.WriteRune(unicode.ToUpper(r))
			capitalizeNext = false
		} else {
			result.WriteRune(r)
		}
	}
	return result.String()
}

// inferGoImportPath extracts the Go import path from the file descriptor options.
func inferGoImportPath(fd protoreflect.FileDescriptor) string {
	// Construct from package name
	pkg := string(fd.Package())
	return "github.com/multigres/multigres/go/pb/" + pkg
}
